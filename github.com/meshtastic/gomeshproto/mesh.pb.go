// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.1
// 	protoc        v4.25.3
// source: meshtastic/mesh.proto

package generated

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Note: these enum names must EXACTLY match the string used in the device
// bin/build-all.sh script.
// Because they will be used to find firmware filenames in the android app for OTA updates.
// To match the old style filenames, _ is converted to -, p is converted to .
type HardwareModel int32

const (
	// TODO: REPLACE
	HardwareModel_UNSET HardwareModel = 0
	// TODO: REPLACE
	HardwareModel_TLORA_V2 HardwareModel = 1
	// TODO: REPLACE
	HardwareModel_TLORA_V1 HardwareModel = 2
	// TODO: REPLACE
	HardwareModel_TLORA_V2_1_1P6 HardwareModel = 3
	// TODO: REPLACE
	HardwareModel_TBEAM HardwareModel = 4
	// The original heltec WiFi_Lora_32_V2, which had battery voltage sensing hooked to GPIO 13
	// (see HELTEC_V2 for the new version).
	HardwareModel_HELTEC_V2_0 HardwareModel = 5
	// TODO: REPLACE
	HardwareModel_TBEAM_V0P7 HardwareModel = 6
	// TODO: REPLACE
	HardwareModel_T_ECHO HardwareModel = 7
	// TODO: REPLACE
	HardwareModel_TLORA_V1_1P3 HardwareModel = 8
	// TODO: REPLACE
	HardwareModel_RAK4631 HardwareModel = 9
	// The new version of the heltec WiFi_Lora_32_V2 board that has battery sensing hooked to GPIO 37.
	// Sadly they did not update anything on the silkscreen to identify this board
	HardwareModel_HELTEC_V2_1 HardwareModel = 10
	// Ancient heltec WiFi_Lora_32 board
	HardwareModel_HELTEC_V1 HardwareModel = 11
	// New T-BEAM with ESP32-S3 CPU
	HardwareModel_LILYGO_TBEAM_S3_CORE HardwareModel = 12
	// RAK WisBlock ESP32 core: https://docs.rakwireless.com/Product-Categories/WisBlock/RAK11200/Overview/
	HardwareModel_RAK11200 HardwareModel = 13
	// B&Q Consulting Nano Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:nano
	HardwareModel_NANO_G1 HardwareModel = 14
	// TODO: REPLACE
	HardwareModel_TLORA_V2_1_1P8 HardwareModel = 15
	// TODO: REPLACE
	HardwareModel_TLORA_T3_S3 HardwareModel = 16
	// B&Q Consulting Nano G1 Explorer: https://wiki.uniteng.com/en/meshtastic/nano-g1-explorer
	HardwareModel_NANO_G1_EXPLORER HardwareModel = 17
	// B&Q Consulting Nano G2 Ultra: https://wiki.uniteng.com/en/meshtastic/nano-g2-ultra
	HardwareModel_NANO_G2_ULTRA HardwareModel = 18
	// LoRAType device: https://loratype.org/
	HardwareModel_LORA_TYPE HardwareModel = 19
	// B&Q Consulting Station Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:station
	HardwareModel_STATION_G1 HardwareModel = 25
	// RAK11310 (RP2040 + SX1262)
	HardwareModel_RAK11310 HardwareModel = 26
	// Makerfabs SenseLoRA Receiver (RP2040 + RFM96)
	HardwareModel_SENSELORA_RP2040 HardwareModel = 27
	// Makerfabs SenseLoRA Industrial Monitor (ESP32-S3 + RFM96)
	HardwareModel_SENSELORA_S3 HardwareModel = 28
	// Canary Radio Company - CanaryOne: https://canaryradio.io/products/canaryone
	HardwareModel_CANARYONE HardwareModel = 29
	// Waveshare RP2040 LoRa - https://www.waveshare.com/rp2040-lora.htm
	HardwareModel_RP2040_LORA HardwareModel = 30
	// B&Q Consulting Station G2: https://wiki.uniteng.com/en/meshtastic/station-g2
	HardwareModel_STATION_G2 HardwareModel = 31
	// ---------------------------------------------------------------------------
	// Less common/prototype boards listed here (needs one more byte over the air)
	// ---------------------------------------------------------------------------
	HardwareModel_LORA_RELAY_V1 HardwareModel = 32
	// TODO: REPLACE
	HardwareModel_NRF52840DK HardwareModel = 33
	// TODO: REPLACE
	HardwareModel_PPR HardwareModel = 34
	// TODO: REPLACE
	HardwareModel_GENIEBLOCKS HardwareModel = 35
	// TODO: REPLACE
	HardwareModel_NRF52_UNKNOWN HardwareModel = 36
	// TODO: REPLACE
	HardwareModel_PORTDUINO HardwareModel = 37
	// The simulator built into the android app
	HardwareModel_ANDROID_SIM HardwareModel = 38
	// Custom DIY device based on @NanoVHF schematics: https://github.com/NanoVHF/Meshtastic-DIY/tree/main/Schematics
	HardwareModel_DIY_V1 HardwareModel = 39
	// nRF52840 Dongle : https://www.nordicsemi.com/Products/Development-hardware/nrf52840-dongle/
	HardwareModel_NRF52840_PCA10059 HardwareModel = 40
	// Custom Disaster Radio esp32 v3 device https://github.com/sudomesh/disaster-radio/tree/master/hardware/board_esp32_v3
	HardwareModel_DR_DEV HardwareModel = 41
	// M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, Paper) https://m5stack.com/
	HardwareModel_M5STACK HardwareModel = 42
	// New Heltec LoRA32 with ESP32-S3 CPU
	HardwareModel_HELTEC_V3 HardwareModel = 43
	// New Heltec Wireless Stick Lite with ESP32-S3 CPU
	HardwareModel_HELTEC_WSL_V3 HardwareModel = 44
	// New BETAFPV ELRS Micro TX Module 2.4G with ESP32 CPU
	HardwareModel_BETAFPV_2400_TX HardwareModel = 45
	// BetaFPV ExpressLRS "Nano" TX Module 900MHz with ESP32 CPU
	HardwareModel_BETAFPV_900_NANO_TX HardwareModel = 46
	// Raspberry Pi Pico (W) with Waveshare SX1262 LoRa Node Module
	HardwareModel_RPI_PICO HardwareModel = 47
	// Heltec Wireless Tracker with ESP32-S3 CPU, built-in GPS, and TFT
	// Newer V1.1, version is written on the PCB near the display.
	HardwareModel_HELTEC_WIRELESS_TRACKER HardwareModel = 48
	// Heltec Wireless Paper with ESP32-S3 CPU and E-Ink display
	HardwareModel_HELTEC_WIRELESS_PAPER HardwareModel = 49
	// LilyGo T-Deck with ESP32-S3 CPU, Keyboard and IPS display
	HardwareModel_T_DECK HardwareModel = 50
	// LilyGo T-Watch S3 with ESP32-S3 CPU and IPS display
	HardwareModel_T_WATCH_S3 HardwareModel = 51
	// Bobricius Picomputer with ESP32-S3 CPU, Keyboard and IPS display
	HardwareModel_PICOMPUTER_S3 HardwareModel = 52
	// Heltec HT-CT62 with ESP32-C3 CPU and SX1262 LoRa
	HardwareModel_HELTEC_HT62 HardwareModel = 53
	// EBYTE SPI LoRa module and ESP32-S3
	HardwareModel_EBYTE_ESP32_S3 HardwareModel = 54
	// Waveshare ESP32-S3-PICO with PICO LoRa HAT and 2.9inch e-Ink
	HardwareModel_ESP32_S3_PICO HardwareModel = 55
	// CircuitMess Chatter 2 LLCC68 Lora Module and ESP32 Wroom
	// Lora module can be swapped out for a Heltec RA-62 which is "almost" pin compatible
	// with one cut and one jumper Meshtastic works
	HardwareModel_CHATTER_2 HardwareModel = 56
	// Heltec Wireless Paper, With ESP32-S3 CPU and E-Ink display
	// Older "V1.0" Variant, has no "version sticker"
	// E-Ink model is DEPG0213BNS800
	// Tab on the screen protector is RED
	// Flex connector marking is FPC-7528B
	HardwareModel_HELTEC_WIRELESS_PAPER_V1_0 HardwareModel = 57
	// Heltec Wireless Tracker with ESP32-S3 CPU, built-in GPS, and TFT
	// Older "V1.0" Variant
	HardwareModel_HELTEC_WIRELESS_TRACKER_V1_0 HardwareModel = 58
	// ------------------------------------------------------------------------------------------------------------------------------------------
	// Reserved ID For developing private Ports. These will show up in live traffic sparsely, so we can use a high number. Keep it within 8 bits.
	// ------------------------------------------------------------------------------------------------------------------------------------------
	HardwareModel_PRIVATE_HW HardwareModel = 255
)

// Enum value maps for HardwareModel.
var (
	HardwareModel_name = map[int32]string{
		0:   "UNSET",
		1:   "TLORA_V2",
		2:   "TLORA_V1",
		3:   "TLORA_V2_1_1P6",
		4:   "TBEAM",
		5:   "HELTEC_V2_0",
		6:   "TBEAM_V0P7",
		7:   "T_ECHO",
		8:   "TLORA_V1_1P3",
		9:   "RAK4631",
		10:  "HELTEC_V2_1",
		11:  "HELTEC_V1",
		12:  "LILYGO_TBEAM_S3_CORE",
		13:  "RAK11200",
		14:  "NANO_G1",
		15:  "TLORA_V2_1_1P8",
		16:  "TLORA_T3_S3",
		17:  "NANO_G1_EXPLORER",
		18:  "NANO_G2_ULTRA",
		19:  "LORA_TYPE",
		25:  "STATION_G1",
		26:  "RAK11310",
		27:  "SENSELORA_RP2040",
		28:  "SENSELORA_S3",
		29:  "CANARYONE",
		30:  "RP2040_LORA",
		31:  "STATION_G2",
		32:  "LORA_RELAY_V1",
		33:  "NRF52840DK",
		34:  "PPR",
		35:  "GENIEBLOCKS",
		36:  "NRF52_UNKNOWN",
		37:  "PORTDUINO",
		38:  "ANDROID_SIM",
		39:  "DIY_V1",
		40:  "NRF52840_PCA10059",
		41:  "DR_DEV",
		42:  "M5STACK",
		43:  "HELTEC_V3",
		44:  "HELTEC_WSL_V3",
		45:  "BETAFPV_2400_TX",
		46:  "BETAFPV_900_NANO_TX",
		47:  "RPI_PICO",
		48:  "HELTEC_WIRELESS_TRACKER",
		49:  "HELTEC_WIRELESS_PAPER",
		50:  "T_DECK",
		51:  "T_WATCH_S3",
		52:  "PICOMPUTER_S3",
		53:  "HELTEC_HT62",
		54:  "EBYTE_ESP32_S3",
		55:  "ESP32_S3_PICO",
		56:  "CHATTER_2",
		57:  "HELTEC_WIRELESS_PAPER_V1_0",
		58:  "HELTEC_WIRELESS_TRACKER_V1_0",
		255: "PRIVATE_HW",
	}
	HardwareModel_value = map[string]int32{
		"UNSET":                        0,
		"TLORA_V2":                     1,
		"TLORA_V1":                     2,
		"TLORA_V2_1_1P6":               3,
		"TBEAM":                        4,
		"HELTEC_V2_0":                  5,
		"TBEAM_V0P7":                   6,
		"T_ECHO":                       7,
		"TLORA_V1_1P3":                 8,
		"RAK4631":                      9,
		"HELTEC_V2_1":                  10,
		"HELTEC_V1":                    11,
		"LILYGO_TBEAM_S3_CORE":         12,
		"RAK11200":                     13,
		"NANO_G1":                      14,
		"TLORA_V2_1_1P8":               15,
		"TLORA_T3_S3":                  16,
		"NANO_G1_EXPLORER":             17,
		"NANO_G2_ULTRA":                18,
		"LORA_TYPE":                    19,
		"STATION_G1":                   25,
		"RAK11310":                     26,
		"SENSELORA_RP2040":             27,
		"SENSELORA_S3":                 28,
		"CANARYONE":                    29,
		"RP2040_LORA":                  30,
		"STATION_G2":                   31,
		"LORA_RELAY_V1":                32,
		"NRF52840DK":                   33,
		"PPR":                          34,
		"GENIEBLOCKS":                  35,
		"NRF52_UNKNOWN":                36,
		"PORTDUINO":                    37,
		"ANDROID_SIM":                  38,
		"DIY_V1":                       39,
		"NRF52840_PCA10059":            40,
		"DR_DEV":                       41,
		"M5STACK":                      42,
		"HELTEC_V3":                    43,
		"HELTEC_WSL_V3":                44,
		"BETAFPV_2400_TX":              45,
		"BETAFPV_900_NANO_TX":          46,
		"RPI_PICO":                     47,
		"HELTEC_WIRELESS_TRACKER":      48,
		"HELTEC_WIRELESS_PAPER":        49,
		"T_DECK":                       50,
		"T_WATCH_S3":                   51,
		"PICOMPUTER_S3":                52,
		"HELTEC_HT62":                  53,
		"EBYTE_ESP32_S3":               54,
		"ESP32_S3_PICO":                55,
		"CHATTER_2":                    56,
		"HELTEC_WIRELESS_PAPER_V1_0":   57,
		"HELTEC_WIRELESS_TRACKER_V1_0": 58,
		"PRIVATE_HW":                   255,
	}
)

func (x HardwareModel) Enum() *HardwareModel {
	p := new(HardwareModel)
	*p = x
	return p
}

func (x HardwareModel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HardwareModel) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[0].Descriptor()
}

func (HardwareModel) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[0]
}

func (x HardwareModel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HardwareModel.Descriptor instead.
func (HardwareModel) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{0}
}

// Shared constants between device and phone
type Constants int32

const (
	// First enum must be zero, and we are just using this enum to
	// pass int constants between two very different environments
	Constants_ZERO Constants = 0
	// From mesh.options
	// note: this payload length is ONLY the bytes that are sent inside of the Data protobuf (excluding protobuf overhead). The 16 byte header is
	// outside of this envelope
	Constants_DATA_PAYLOAD_LEN Constants = 237
)

// Enum value maps for Constants.
var (
	Constants_name = map[int32]string{
		0:   "ZERO",
		237: "DATA_PAYLOAD_LEN",
	}
	Constants_value = map[string]int32{
		"ZERO":             0,
		"DATA_PAYLOAD_LEN": 237,
	}
)

func (x Constants) Enum() *Constants {
	p := new(Constants)
	*p = x
	return p
}

func (x Constants) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Constants) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[1].Descriptor()
}

func (Constants) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[1]
}

func (x Constants) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Constants.Descriptor instead.
func (Constants) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{1}
}

// Error codes for critical errors
// The device might report these fault codes on the screen.
// If you encounter a fault code, please post on the meshtastic.discourse.group
// and we'll try to help.
type CriticalErrorCode int32

const (
	// TODO: REPLACE
	CriticalErrorCode_NONE CriticalErrorCode = 0
	// A software bug was detected while trying to send lora
	CriticalErrorCode_TX_WATCHDOG CriticalErrorCode = 1
	// A software bug was detected on entry to sleep
	CriticalErrorCode_SLEEP_ENTER_WAIT CriticalErrorCode = 2
	// No Lora radio hardware could be found
	CriticalErrorCode_NO_RADIO CriticalErrorCode = 3
	// Not normally used
	CriticalErrorCode_UNSPECIFIED CriticalErrorCode = 4
	// We failed while configuring a UBlox GPS
	CriticalErrorCode_UBLOX_UNIT_FAILED CriticalErrorCode = 5
	// This board was expected to have a power management chip and it is missing or broken
	CriticalErrorCode_NO_AXP192 CriticalErrorCode = 6
	// The channel tried to set a radio setting which is not supported by this chipset,
	// radio comms settings are now undefined.
	CriticalErrorCode_INVALID_RADIO_SETTING CriticalErrorCode = 7
	// Radio transmit hardware failure. We sent data to the radio chip, but it didn't
	// reply with an interrupt.
	CriticalErrorCode_TRANSMIT_FAILED CriticalErrorCode = 8
	// We detected that the main CPU voltage dropped below the minimum acceptable value
	CriticalErrorCode_BROWNOUT CriticalErrorCode = 9
	// Selftest of SX1262 radio chip failed
	CriticalErrorCode_SX1262_FAILURE CriticalErrorCode = 10
	// A (likely software but possibly hardware) failure was detected while trying to send packets.
	// If this occurs on your board, please post in the forum so that we can ask you to collect some information to allow fixing this bug
	CriticalErrorCode_RADIO_SPI_BUG CriticalErrorCode = 11
)

// Enum value maps for CriticalErrorCode.
var (
	CriticalErrorCode_name = map[int32]string{
		0:  "NONE",
		1:  "TX_WATCHDOG",
		2:  "SLEEP_ENTER_WAIT",
		3:  "NO_RADIO",
		4:  "UNSPECIFIED",
		5:  "UBLOX_UNIT_FAILED",
		6:  "NO_AXP192",
		7:  "INVALID_RADIO_SETTING",
		8:  "TRANSMIT_FAILED",
		9:  "BROWNOUT",
		10: "SX1262_FAILURE",
		11: "RADIO_SPI_BUG",
	}
	CriticalErrorCode_value = map[string]int32{
		"NONE":                  0,
		"TX_WATCHDOG":           1,
		"SLEEP_ENTER_WAIT":      2,
		"NO_RADIO":              3,
		"UNSPECIFIED":           4,
		"UBLOX_UNIT_FAILED":     5,
		"NO_AXP192":             6,
		"INVALID_RADIO_SETTING": 7,
		"TRANSMIT_FAILED":       8,
		"BROWNOUT":              9,
		"SX1262_FAILURE":        10,
		"RADIO_SPI_BUG":         11,
	}
)

func (x CriticalErrorCode) Enum() *CriticalErrorCode {
	p := new(CriticalErrorCode)
	*p = x
	return p
}

func (x CriticalErrorCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CriticalErrorCode) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[2].Descriptor()
}

func (CriticalErrorCode) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[2]
}

func (x CriticalErrorCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CriticalErrorCode.Descriptor instead.
func (CriticalErrorCode) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{2}
}

// How the location was acquired: manual, onboard GPS, external (EUD) GPS
type Position_LocSource int32

const (
	// TODO: REPLACE
	Position_LOC_UNSET Position_LocSource = 0
	// TODO: REPLACE
	Position_LOC_MANUAL Position_LocSource = 1
	// TODO: REPLACE
	Position_LOC_INTERNAL Position_LocSource = 2
	// TODO: REPLACE
	Position_LOC_EXTERNAL Position_LocSource = 3
)

// Enum value maps for Position_LocSource.
var (
	Position_LocSource_name = map[int32]string{
		0: "LOC_UNSET",
		1: "LOC_MANUAL",
		2: "LOC_INTERNAL",
		3: "LOC_EXTERNAL",
	}
	Position_LocSource_value = map[string]int32{
		"LOC_UNSET":    0,
		"LOC_MANUAL":   1,
		"LOC_INTERNAL": 2,
		"LOC_EXTERNAL": 3,
	}
)

func (x Position_LocSource) Enum() *Position_LocSource {
	p := new(Position_LocSource)
	*p = x
	return p
}

func (x Position_LocSource) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Position_LocSource) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[3].Descriptor()
}

func (Position_LocSource) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[3]
}

func (x Position_LocSource) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Position_LocSource.Descriptor instead.
func (Position_LocSource) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{0, 0}
}

// How the altitude was acquired: manual, GPS int/ext, etc
// Default: same as location_source if present
type Position_AltSource int32

const (
	// TODO: REPLACE
	Position_ALT_UNSET Position_AltSource = 0
	// TODO: REPLACE
	Position_ALT_MANUAL Position_AltSource = 1
	// TODO: REPLACE
	Position_ALT_INTERNAL Position_AltSource = 2
	// TODO: REPLACE
	Position_ALT_EXTERNAL Position_AltSource = 3
	// TODO: REPLACE
	Position_ALT_BAROMETRIC Position_AltSource = 4
)

// Enum value maps for Position_AltSource.
var (
	Position_AltSource_name = map[int32]string{
		0: "ALT_UNSET",
		1: "ALT_MANUAL",
		2: "ALT_INTERNAL",
		3: "ALT_EXTERNAL",
		4: "ALT_BAROMETRIC",
	}
	Position_AltSource_value = map[string]int32{
		"ALT_UNSET":      0,
		"ALT_MANUAL":     1,
		"ALT_INTERNAL":   2,
		"ALT_EXTERNAL":   3,
		"ALT_BAROMETRIC": 4,
	}
)

func (x Position_AltSource) Enum() *Position_AltSource {
	p := new(Position_AltSource)
	*p = x
	return p
}

func (x Position_AltSource) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Position_AltSource) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[4].Descriptor()
}

func (Position_AltSource) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[4]
}

func (x Position_AltSource) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Position_AltSource.Descriptor instead.
func (Position_AltSource) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{0, 1}
}

// A failure in delivering a message (usually used for routing control messages, but might be provided in addition to ack.fail_id to provide
// details on the type of failure).
type Routing_Error int32

const (
	// This message is not a failure
	Routing_NONE Routing_Error = 0
	// Our node doesn't have a route to the requested destination anymore.
	Routing_NO_ROUTE Routing_Error = 1
	// We received a nak while trying to forward on your behalf
	Routing_GOT_NAK Routing_Error = 2
	// TODO: REPLACE
	Routing_TIMEOUT Routing_Error = 3
	// No suitable interface could be found for delivering this packet
	Routing_NO_INTERFACE Routing_Error = 4
	// We reached the max retransmission count (typically for naive flood routing)
	Routing_MAX_RETRANSMIT Routing_Error = 5
	// No suitable channel was found for sending this packet (i.e. was requested channel index disabled?)
	Routing_NO_CHANNEL Routing_Error = 6
	// The packet was too big for sending (exceeds interface MTU after encoding)
	Routing_TOO_LARGE Routing_Error = 7
	// The request had want_response set, the request reached the destination node, but no service on that node wants to send a response
	// (possibly due to bad channel permissions)
	Routing_NO_RESPONSE Routing_Error = 8
	// Cannot send currently because duty cycle regulations will be violated.
	Routing_DUTY_CYCLE_LIMIT Routing_Error = 9
	// The application layer service on the remote node received your request, but considered your request somehow invalid
	Routing_BAD_REQUEST Routing_Error = 32
	// The application layer service on the remote node received your request, but considered your request not authorized
	// (i.e you did not send the request on the required bound channel)
	Routing_NOT_AUTHORIZED Routing_Error = 33
)

// Enum value maps for Routing_Error.
var (
	Routing_Error_name = map[int32]string{
		0:  "NONE",
		1:  "NO_ROUTE",
		2:  "GOT_NAK",
		3:  "TIMEOUT",
		4:  "NO_INTERFACE",
		5:  "MAX_RETRANSMIT",
		6:  "NO_CHANNEL",
		7:  "TOO_LARGE",
		8:  "NO_RESPONSE",
		9:  "DUTY_CYCLE_LIMIT",
		32: "BAD_REQUEST",
		33: "NOT_AUTHORIZED",
	}
	Routing_Error_value = map[string]int32{
		"NONE":             0,
		"NO_ROUTE":         1,
		"GOT_NAK":          2,
		"TIMEOUT":          3,
		"NO_INTERFACE":     4,
		"MAX_RETRANSMIT":   5,
		"NO_CHANNEL":       6,
		"TOO_LARGE":        7,
		"NO_RESPONSE":      8,
		"DUTY_CYCLE_LIMIT": 9,
		"BAD_REQUEST":      32,
		"NOT_AUTHORIZED":   33,
	}
)

func (x Routing_Error) Enum() *Routing_Error {
	p := new(Routing_Error)
	*p = x
	return p
}

func (x Routing_Error) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Routing_Error) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[5].Descriptor()
}

func (Routing_Error) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[5]
}

func (x Routing_Error) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Routing_Error.Descriptor instead.
func (Routing_Error) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{3, 0}
}

// The priority of this message for sending.
// Higher priorities are sent first (when managing the transmit queue).
// This field is never sent over the air, it is only used internally inside of a local device node.
// API clients (either on the local node or connected directly to the node)
// can set this parameter if necessary.
// (values must be <= 127 to keep protobuf field to one byte in size.
// Detailed background on this field:
// I noticed a funny side effect of lora being so slow: Usually when making
// a protocol there isnâ€™t much need to use message priority to change the order
// of transmission (because interfaces are fairly fast).
// But for lora where packets can take a few seconds each, it is very important
// to make sure that critical packets are sent ASAP.
// In the case of meshtastic that means we want to send protocol acks as soon as possible
// (to prevent unneeded retransmissions), we want routing messages to be sent next,
// then messages marked as reliable and finally 'background' packets like periodic position updates.
// So I bit the bullet and implemented a new (internal - not sent over the air)
// field in MeshPacket called 'priority'.
// And the transmission queue in the router object is now a priority queue.
type MeshPacket_Priority int32

const (
	// Treated as Priority.DEFAULT
	MeshPacket_UNSET MeshPacket_Priority = 0
	// TODO: REPLACE
	MeshPacket_MIN MeshPacket_Priority = 1
	// Background position updates are sent with very low priority -
	// if the link is super congested they might not go out at all
	MeshPacket_BACKGROUND MeshPacket_Priority = 10
	// This priority is used for most messages that don't have a priority set
	MeshPacket_DEFAULT MeshPacket_Priority = 64
	// If priority is unset but the message is marked as want_ack,
	// assume it is important and use a slightly higher priority
	MeshPacket_RELIABLE MeshPacket_Priority = 70
	// Ack/naks are sent with very high priority to ensure that retransmission
	// stops as soon as possible
	MeshPacket_ACK MeshPacket_Priority = 120
	// TODO: REPLACE
	MeshPacket_MAX MeshPacket_Priority = 127
)

// Enum value maps for MeshPacket_Priority.
var (
	MeshPacket_Priority_name = map[int32]string{
		0:   "UNSET",
		1:   "MIN",
		10:  "BACKGROUND",
		64:  "DEFAULT",
		70:  "RELIABLE",
		120: "ACK",
		127: "MAX",
	}
	MeshPacket_Priority_value = map[string]int32{
		"UNSET":      0,
		"MIN":        1,
		"BACKGROUND": 10,
		"DEFAULT":    64,
		"RELIABLE":   70,
		"ACK":        120,
		"MAX":        127,
	}
)

func (x MeshPacket_Priority) Enum() *MeshPacket_Priority {
	p := new(MeshPacket_Priority)
	*p = x
	return p
}

func (x MeshPacket_Priority) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MeshPacket_Priority) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[6].Descriptor()
}

func (MeshPacket_Priority) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[6]
}

func (x MeshPacket_Priority) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MeshPacket_Priority.Descriptor instead.
func (MeshPacket_Priority) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{7, 0}
}

// Identify if this is a delayed packet
type MeshPacket_Delayed int32

const (
	// If unset, the message is being sent in real time.
	MeshPacket_NO_DELAY MeshPacket_Delayed = 0
	// The message is delayed and was originally a broadcast
	MeshPacket_DELAYED_BROADCAST MeshPacket_Delayed = 1
	// The message is delayed and was originally a direct message
	MeshPacket_DELAYED_DIRECT MeshPacket_Delayed = 2
)

// Enum value maps for MeshPacket_Delayed.
var (
	MeshPacket_Delayed_name = map[int32]string{
		0: "NO_DELAY",
		1: "DELAYED_BROADCAST",
		2: "DELAYED_DIRECT",
	}
	MeshPacket_Delayed_value = map[string]int32{
		"NO_DELAY":          0,
		"DELAYED_BROADCAST": 1,
		"DELAYED_DIRECT":    2,
	}
)

func (x MeshPacket_Delayed) Enum() *MeshPacket_Delayed {
	p := new(MeshPacket_Delayed)
	*p = x
	return p
}

func (x MeshPacket_Delayed) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MeshPacket_Delayed) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[7].Descriptor()
}

func (MeshPacket_Delayed) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[7]
}

func (x MeshPacket_Delayed) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MeshPacket_Delayed.Descriptor instead.
func (MeshPacket_Delayed) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{7, 1}
}

// Log levels, chosen to match python logging conventions.
type LogRecord_Level int32

const (
	// Log levels, chosen to match python logging conventions.
	LogRecord_UNSET LogRecord_Level = 0
	// Log levels, chosen to match python logging conventions.
	LogRecord_CRITICAL LogRecord_Level = 50
	// Log levels, chosen to match python logging conventions.
	LogRecord_ERROR LogRecord_Level = 40
	// Log levels, chosen to match python logging conventions.
	LogRecord_WARNING LogRecord_Level = 30
	// Log levels, chosen to match python logging conventions.
	LogRecord_INFO LogRecord_Level = 20
	// Log levels, chosen to match python logging conventions.
	LogRecord_DEBUG LogRecord_Level = 10
	// Log levels, chosen to match python logging conventions.
	LogRecord_TRACE LogRecord_Level = 5
)

// Enum value maps for LogRecord_Level.
var (
	LogRecord_Level_name = map[int32]string{
		0:  "UNSET",
		50: "CRITICAL",
		40: "ERROR",
		30: "WARNING",
		20: "INFO",
		10: "DEBUG",
		5:  "TRACE",
	}
	LogRecord_Level_value = map[string]int32{
		"UNSET":    0,
		"CRITICAL": 50,
		"ERROR":    40,
		"WARNING":  30,
		"INFO":     20,
		"DEBUG":    10,
		"TRACE":    5,
	}
)

func (x LogRecord_Level) Enum() *LogRecord_Level {
	p := new(LogRecord_Level)
	*p = x
	return p
}

func (x LogRecord_Level) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LogRecord_Level) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[8].Descriptor()
}

func (LogRecord_Level) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[8]
}

func (x LogRecord_Level) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LogRecord_Level.Descriptor instead.
func (LogRecord_Level) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{10, 0}
}

// a gps position
type Position struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The new preferred location encoding, multiply by 1e-7 to get degrees
	// in floating point
	LatitudeI int32 `protobuf:"fixed32,1,opt,name=latitude_i,json=latitudeI,proto3" json:"latitude_i,omitempty"`
	// TODO: REPLACE
	LongitudeI int32 `protobuf:"fixed32,2,opt,name=longitude_i,json=longitudeI,proto3" json:"longitude_i,omitempty"`
	// In meters above MSL (but see issue #359)
	Altitude int32 `protobuf:"varint,3,opt,name=altitude,proto3" json:"altitude,omitempty"`
	// This is usually not sent over the mesh (to save space), but it is sent
	// from the phone so that the local device can set its time if it is sent over
	// the mesh (because there are devices on the mesh without GPS or RTC).
	// seconds since 1970
	Time uint32 `protobuf:"fixed32,4,opt,name=time,proto3" json:"time,omitempty"`
	// TODO: REPLACE
	LocationSource Position_LocSource `protobuf:"varint,5,opt,name=location_source,json=locationSource,proto3,enum=meshtastic.Position_LocSource" json:"location_source,omitempty"`
	// TODO: REPLACE
	AltitudeSource Position_AltSource `protobuf:"varint,6,opt,name=altitude_source,json=altitudeSource,proto3,enum=meshtastic.Position_AltSource" json:"altitude_source,omitempty"`
	// Positional timestamp (actual timestamp of GPS solution) in integer epoch seconds
	Timestamp uint32 `protobuf:"fixed32,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Pos. timestamp milliseconds adjustment (rarely available or required)
	TimestampMillisAdjust int32 `protobuf:"varint,8,opt,name=timestamp_millis_adjust,json=timestampMillisAdjust,proto3" json:"timestamp_millis_adjust,omitempty"`
	// HAE altitude in meters - can be used instead of MSL altitude
	AltitudeHae int32 `protobuf:"zigzag32,9,opt,name=altitude_hae,json=altitudeHae,proto3" json:"altitude_hae,omitempty"`
	// Geoidal separation in meters
	AltitudeGeoidalSeparation int32 `protobuf:"zigzag32,10,opt,name=altitude_geoidal_separation,json=altitudeGeoidalSeparation,proto3" json:"altitude_geoidal_separation,omitempty"`
	// Horizontal, Vertical and Position Dilution of Precision, in 1/100 units
	//   - PDOP is sufficient for most cases
	//   - for higher precision scenarios, HDOP and VDOP can be used instead,
	//     in which case PDOP becomes redundant (PDOP=sqrt(HDOP^2 + VDOP^2))
	//
	// TODO: REMOVE/INTEGRATE
	PDOP uint32 `protobuf:"varint,11,opt,name=PDOP,proto3" json:"PDOP,omitempty"`
	// TODO: REPLACE
	HDOP uint32 `protobuf:"varint,12,opt,name=HDOP,proto3" json:"HDOP,omitempty"`
	// TODO: REPLACE
	VDOP uint32 `protobuf:"varint,13,opt,name=VDOP,proto3" json:"VDOP,omitempty"`
	// GPS accuracy (a hardware specific constant) in mm
	//
	//	multiplied with DOP to calculate positional accuracy
	//
	// Default: "'bout three meters-ish" :)
	GpsAccuracy uint32 `protobuf:"varint,14,opt,name=gps_accuracy,json=gpsAccuracy,proto3" json:"gps_accuracy,omitempty"`
	// Ground speed in m/s and True North TRACK in 1/100 degrees
	// Clarification of terms:
	// - "track" is the direction of motion (measured in horizontal plane)
	// - "heading" is where the fuselage points (measured in horizontal plane)
	// - "yaw" indicates a relative rotation about the vertical axis
	// TODO: REMOVE/INTEGRATE
	GroundSpeed uint32 `protobuf:"varint,15,opt,name=ground_speed,json=groundSpeed,proto3" json:"ground_speed,omitempty"`
	// TODO: REPLACE
	GroundTrack uint32 `protobuf:"varint,16,opt,name=ground_track,json=groundTrack,proto3" json:"ground_track,omitempty"`
	// GPS fix quality (from NMEA GxGGA statement or similar)
	FixQuality uint32 `protobuf:"varint,17,opt,name=fix_quality,json=fixQuality,proto3" json:"fix_quality,omitempty"`
	// GPS fix type 2D/3D (from NMEA GxGSA statement)
	FixType uint32 `protobuf:"varint,18,opt,name=fix_type,json=fixType,proto3" json:"fix_type,omitempty"`
	// GPS "Satellites in View" number
	SatsInView uint32 `protobuf:"varint,19,opt,name=sats_in_view,json=satsInView,proto3" json:"sats_in_view,omitempty"`
	// Sensor ID - in case multiple positioning sensors are being used
	SensorId uint32 `protobuf:"varint,20,opt,name=sensor_id,json=sensorId,proto3" json:"sensor_id,omitempty"`
	// Estimated/expected time (in seconds) until next update:
	//   - if we update at fixed intervals of X seconds, use X
	//   - if we update at dynamic intervals (based on relative movement etc),
	//     but "AT LEAST every Y seconds", use Y
	NextUpdate uint32 `protobuf:"varint,21,opt,name=next_update,json=nextUpdate,proto3" json:"next_update,omitempty"`
	// A sequence number, incremented with each Position message to help
	//
	//	detect lost updates if needed
	SeqNumber uint32 `protobuf:"varint,22,opt,name=seq_number,json=seqNumber,proto3" json:"seq_number,omitempty"`
	// Indicates the bits of precision set by the sending node
	PrecisionBits uint32 `protobuf:"varint,23,opt,name=precision_bits,json=precisionBits,proto3" json:"precision_bits,omitempty"`
}

func (x *Position) Reset() {
	*x = Position{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Position) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Position) ProtoMessage() {}

func (x *Position) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Position.ProtoReflect.Descriptor instead.
func (*Position) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{0}
}

func (x *Position) GetLatitudeI() int32 {
	if x != nil {
		return x.LatitudeI
	}
	return 0
}

func (x *Position) GetLongitudeI() int32 {
	if x != nil {
		return x.LongitudeI
	}
	return 0
}

func (x *Position) GetAltitude() int32 {
	if x != nil {
		return x.Altitude
	}
	return 0
}

func (x *Position) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *Position) GetLocationSource() Position_LocSource {
	if x != nil {
		return x.LocationSource
	}
	return Position_LOC_UNSET
}

func (x *Position) GetAltitudeSource() Position_AltSource {
	if x != nil {
		return x.AltitudeSource
	}
	return Position_ALT_UNSET
}

func (x *Position) GetTimestamp() uint32 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *Position) GetTimestampMillisAdjust() int32 {
	if x != nil {
		return x.TimestampMillisAdjust
	}
	return 0
}

func (x *Position) GetAltitudeHae() int32 {
	if x != nil {
		return x.AltitudeHae
	}
	return 0
}

func (x *Position) GetAltitudeGeoidalSeparation() int32 {
	if x != nil {
		return x.AltitudeGeoidalSeparation
	}
	return 0
}

func (x *Position) GetPDOP() uint32 {
	if x != nil {
		return x.PDOP
	}
	return 0
}

func (x *Position) GetHDOP() uint32 {
	if x != nil {
		return x.HDOP
	}
	return 0
}

func (x *Position) GetVDOP() uint32 {
	if x != nil {
		return x.VDOP
	}
	return 0
}

func (x *Position) GetGpsAccuracy() uint32 {
	if x != nil {
		return x.GpsAccuracy
	}
	return 0
}

func (x *Position) GetGroundSpeed() uint32 {
	if x != nil {
		return x.GroundSpeed
	}
	return 0
}

func (x *Position) GetGroundTrack() uint32 {
	if x != nil {
		return x.GroundTrack
	}
	return 0
}

func (x *Position) GetFixQuality() uint32 {
	if x != nil {
		return x.FixQuality
	}
	return 0
}

func (x *Position) GetFixType() uint32 {
	if x != nil {
		return x.FixType
	}
	return 0
}

func (x *Position) GetSatsInView() uint32 {
	if x != nil {
		return x.SatsInView
	}
	return 0
}

func (x *Position) GetSensorId() uint32 {
	if x != nil {
		return x.SensorId
	}
	return 0
}

func (x *Position) GetNextUpdate() uint32 {
	if x != nil {
		return x.NextUpdate
	}
	return 0
}

func (x *Position) GetSeqNumber() uint32 {
	if x != nil {
		return x.SeqNumber
	}
	return 0
}

func (x *Position) GetPrecisionBits() uint32 {
	if x != nil {
		return x.PrecisionBits
	}
	return 0
}

// Broadcast when a newly powered mesh node wants to find a node num it can use
// Sent from the phone over bluetooth to set the user id for the owner of this node.
// Also sent from nodes to each other when a new node signs on (so all clients can have this info)
// The algorithm is as follows:
// when a node starts up, it broadcasts their user and the normal flow is for all
// other nodes to reply with their User as well (so the new node can build its nodedb)
// If a node ever receives a User (not just the first broadcast) message where
// the sender node number equals our node number, that indicates a collision has
// occurred and the following steps should happen:
// If the receiving node (that was already in the mesh)'s macaddr is LOWER than the
// new User who just tried to sign in: it gets to keep its nodenum.
// We send a broadcast message of OUR User (we use a broadcast so that the other node can
// receive our message, considering we have the same id - it also serves to let
// observers correct their nodedb) - this case is rare so it should be okay.
// If any node receives a User where the macaddr is GTE than their local macaddr,
// they have been vetoed and should pick a new random nodenum (filtering against
// whatever it knows about the nodedb) and rebroadcast their User.
// A few nodenums are reserved and will never be requested:
// 0xff - broadcast
// 0 through 3 - for future use
type User struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A globally unique ID string for this user.
	// In the case of Signal that would mean +16504442323, for the default macaddr derived id it would be !<8 hexidecimal bytes>.
	// Note: app developers are encouraged to also use the following standard
	// node IDs "^all" (for broadcast), "^local" (for the locally connected node)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// A full name for this user, i.e. "Kevin Hester"
	LongName string `protobuf:"bytes,2,opt,name=long_name,json=longName,proto3" json:"long_name,omitempty"`
	// A VERY short name, ideally two characters.
	// Suitable for a tiny OLED screen
	ShortName string `protobuf:"bytes,3,opt,name=short_name,json=shortName,proto3" json:"short_name,omitempty"`
	// Deprecated in Meshtastic 2.1.x
	// This is the addr of the radio.
	// Not populated by the phone, but added by the esp32 when broadcasting
	//
	// Deprecated: Do not use.
	Macaddr []byte `protobuf:"bytes,4,opt,name=macaddr,proto3" json:"macaddr,omitempty"`
	// TBEAM, HELTEC, etc...
	// Starting in 1.2.11 moved to hw_model enum in the NodeInfo object.
	// Apps will still need the string here for older builds
	// (so OTA update can find the right image), but if the enum is available it will be used instead.
	HwModel HardwareModel `protobuf:"varint,5,opt,name=hw_model,json=hwModel,proto3,enum=meshtastic.HardwareModel" json:"hw_model,omitempty"`
	// In some regions Ham radio operators have different bandwidth limitations than others.
	// If this user is a licensed operator, set this flag.
	// Also, "long_name" should be their licence number.
	IsLicensed bool `protobuf:"varint,6,opt,name=is_licensed,json=isLicensed,proto3" json:"is_licensed,omitempty"`
	// Indicates that the user's role in the mesh
	Role Config_DeviceConfig_Role `protobuf:"varint,7,opt,name=role,proto3,enum=meshtastic.Config_DeviceConfig_Role" json:"role,omitempty"`
}

func (x *User) Reset() {
	*x = User{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *User) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*User) ProtoMessage() {}

func (x *User) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{1}
}

func (x *User) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *User) GetLongName() string {
	if x != nil {
		return x.LongName
	}
	return ""
}

func (x *User) GetShortName() string {
	if x != nil {
		return x.ShortName
	}
	return ""
}

// Deprecated: Do not use.
func (x *User) GetMacaddr() []byte {
	if x != nil {
		return x.Macaddr
	}
	return nil
}

func (x *User) GetHwModel() HardwareModel {
	if x != nil {
		return x.HwModel
	}
	return HardwareModel_UNSET
}

func (x *User) GetIsLicensed() bool {
	if x != nil {
		return x.IsLicensed
	}
	return false
}

func (x *User) GetRole() Config_DeviceConfig_Role {
	if x != nil {
		return x.Role
	}
	return Config_DeviceConfig_CLIENT
}

// A message used in our Dynamic Source Routing protocol (RFC 4728 based)
type RouteDiscovery struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The list of nodenums this packet has visited so far
	Route []uint32 `protobuf:"fixed32,1,rep,packed,name=route,proto3" json:"route,omitempty"`
}

func (x *RouteDiscovery) Reset() {
	*x = RouteDiscovery{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteDiscovery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteDiscovery) ProtoMessage() {}

func (x *RouteDiscovery) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteDiscovery.ProtoReflect.Descriptor instead.
func (*RouteDiscovery) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{2}
}

func (x *RouteDiscovery) GetRoute() []uint32 {
	if x != nil {
		return x.Route
	}
	return nil
}

// A Routing control Data packet handled by the routing module
type Routing struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Variant:
	//
	//	*Routing_RouteRequest
	//	*Routing_RouteReply
	//	*Routing_ErrorReason
	Variant isRouting_Variant `protobuf_oneof:"variant"`
}

func (x *Routing) Reset() {
	*x = Routing{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Routing) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Routing) ProtoMessage() {}

func (x *Routing) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Routing.ProtoReflect.Descriptor instead.
func (*Routing) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{3}
}

func (m *Routing) GetVariant() isRouting_Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

func (x *Routing) GetRouteRequest() *RouteDiscovery {
	if x, ok := x.GetVariant().(*Routing_RouteRequest); ok {
		return x.RouteRequest
	}
	return nil
}

func (x *Routing) GetRouteReply() *RouteDiscovery {
	if x, ok := x.GetVariant().(*Routing_RouteReply); ok {
		return x.RouteReply
	}
	return nil
}

func (x *Routing) GetErrorReason() Routing_Error {
	if x, ok := x.GetVariant().(*Routing_ErrorReason); ok {
		return x.ErrorReason
	}
	return Routing_NONE
}

type isRouting_Variant interface {
	isRouting_Variant()
}

type Routing_RouteRequest struct {
	// A route request going from the requester
	RouteRequest *RouteDiscovery `protobuf:"bytes,1,opt,name=route_request,json=routeRequest,proto3,oneof"`
}

type Routing_RouteReply struct {
	// A route reply
	RouteReply *RouteDiscovery `protobuf:"bytes,2,opt,name=route_reply,json=routeReply,proto3,oneof"`
}

type Routing_ErrorReason struct {
	// A failure in delivering a message (usually used for routing control messages, but might be provided
	// in addition to ack.fail_id to provide details on the type of failure).
	ErrorReason Routing_Error `protobuf:"varint,3,opt,name=error_reason,json=errorReason,proto3,enum=meshtastic.Routing_Error,oneof"`
}

func (*Routing_RouteRequest) isRouting_Variant() {}

func (*Routing_RouteReply) isRouting_Variant() {}

func (*Routing_ErrorReason) isRouting_Variant() {}

// (Formerly called SubPacket)
// The payload portion fo a packet, this is the actual bytes that are sent
// inside a radio packet (because from/to are broken out by the comms library)
type Data struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Formerly named typ and of type Type
	Portnum PortNum `protobuf:"varint,1,opt,name=portnum,proto3,enum=meshtastic.PortNum" json:"portnum,omitempty"`
	// TODO: REPLACE
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	// Not normally used, but for testing a sender can request that recipient
	// responds in kind (i.e. if it received a position, it should unicast back it's position).
	// Note: that if you set this on a broadcast you will receive many replies.
	WantResponse bool `protobuf:"varint,3,opt,name=want_response,json=wantResponse,proto3" json:"want_response,omitempty"`
	// The address of the destination node.
	// This field is is filled in by the mesh radio device software, application
	// layer software should never need it.
	// RouteDiscovery messages _must_ populate this.
	// Other message types might need to if they are doing multihop routing.
	Dest uint32 `protobuf:"fixed32,4,opt,name=dest,proto3" json:"dest,omitempty"`
	// The address of the original sender for this message.
	// This field should _only_ be populated for reliable multihop packets (to keep
	// packets small).
	Source uint32 `protobuf:"fixed32,5,opt,name=source,proto3" json:"source,omitempty"`
	// Only used in routing or response messages.
	// Indicates the original message ID that this message is reporting failure on. (formerly called original_id)
	RequestId uint32 `protobuf:"fixed32,6,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// If set, this message is intened to be a reply to a previously sent message with the defined id.
	ReplyId uint32 `protobuf:"fixed32,7,opt,name=reply_id,json=replyId,proto3" json:"reply_id,omitempty"`
	// Defaults to false. If true, then what is in the payload should be treated as an emoji like giving
	// a message a heart or poop emoji.
	Emoji uint32 `protobuf:"fixed32,8,opt,name=emoji,proto3" json:"emoji,omitempty"`
}

func (x *Data) Reset() {
	*x = Data{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Data) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Data) ProtoMessage() {}

func (x *Data) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Data.ProtoReflect.Descriptor instead.
func (*Data) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{4}
}

func (x *Data) GetPortnum() PortNum {
	if x != nil {
		return x.Portnum
	}
	return PortNum_UNKNOWN_APP
}

func (x *Data) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *Data) GetWantResponse() bool {
	if x != nil {
		return x.WantResponse
	}
	return false
}

func (x *Data) GetDest() uint32 {
	if x != nil {
		return x.Dest
	}
	return 0
}

func (x *Data) GetSource() uint32 {
	if x != nil {
		return x.Source
	}
	return 0
}

func (x *Data) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *Data) GetReplyId() uint32 {
	if x != nil {
		return x.ReplyId
	}
	return 0
}

func (x *Data) GetEmoji() uint32 {
	if x != nil {
		return x.Emoji
	}
	return 0
}

// Waypoint message, used to share arbitrary locations across the mesh
type Waypoint struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Id of the waypoint
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// latitude_i
	LatitudeI int32 `protobuf:"fixed32,2,opt,name=latitude_i,json=latitudeI,proto3" json:"latitude_i,omitempty"`
	// longitude_i
	LongitudeI int32 `protobuf:"fixed32,3,opt,name=longitude_i,json=longitudeI,proto3" json:"longitude_i,omitempty"`
	// Time the waypoint is to expire (epoch)
	Expire uint32 `protobuf:"varint,4,opt,name=expire,proto3" json:"expire,omitempty"`
	// If greater than zero, treat the value as a nodenum only allowing them to update the waypoint.
	// If zero, the waypoint is open to be edited by any member of the mesh.
	LockedTo uint32 `protobuf:"varint,5,opt,name=locked_to,json=lockedTo,proto3" json:"locked_to,omitempty"`
	// Name of the waypoint - max 30 chars
	Name string `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the waypoint - max 100 chars
	Description string `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	// Designator icon for the waypoint in the form of a unicode emoji
	Icon uint32 `protobuf:"fixed32,8,opt,name=icon,proto3" json:"icon,omitempty"`
}

func (x *Waypoint) Reset() {
	*x = Waypoint{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Waypoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Waypoint) ProtoMessage() {}

func (x *Waypoint) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Waypoint.ProtoReflect.Descriptor instead.
func (*Waypoint) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{5}
}

func (x *Waypoint) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Waypoint) GetLatitudeI() int32 {
	if x != nil {
		return x.LatitudeI
	}
	return 0
}

func (x *Waypoint) GetLongitudeI() int32 {
	if x != nil {
		return x.LongitudeI
	}
	return 0
}

func (x *Waypoint) GetExpire() uint32 {
	if x != nil {
		return x.Expire
	}
	return 0
}

func (x *Waypoint) GetLockedTo() uint32 {
	if x != nil {
		return x.LockedTo
	}
	return 0
}

func (x *Waypoint) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Waypoint) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Waypoint) GetIcon() uint32 {
	if x != nil {
		return x.Icon
	}
	return 0
}

// This message will be proxied over the PhoneAPI for the client to deliver to the MQTT server
type MqttClientProxyMessage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The MQTT topic this message will be sent /received on
	Topic string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	// The actual service envelope payload or text for mqtt pub / sub
	//
	// Types that are assignable to PayloadVariant:
	//
	//	*MqttClientProxyMessage_Data
	//	*MqttClientProxyMessage_Text
	PayloadVariant isMqttClientProxyMessage_PayloadVariant `protobuf_oneof:"payload_variant"`
	// Whether the message should be retained (or not)
	Retained bool `protobuf:"varint,4,opt,name=retained,proto3" json:"retained,omitempty"`
}

func (x *MqttClientProxyMessage) Reset() {
	*x = MqttClientProxyMessage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MqttClientProxyMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MqttClientProxyMessage) ProtoMessage() {}

func (x *MqttClientProxyMessage) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MqttClientProxyMessage.ProtoReflect.Descriptor instead.
func (*MqttClientProxyMessage) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{6}
}

func (x *MqttClientProxyMessage) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (m *MqttClientProxyMessage) GetPayloadVariant() isMqttClientProxyMessage_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *MqttClientProxyMessage) GetData() []byte {
	if x, ok := x.GetPayloadVariant().(*MqttClientProxyMessage_Data); ok {
		return x.Data
	}
	return nil
}

func (x *MqttClientProxyMessage) GetText() string {
	if x, ok := x.GetPayloadVariant().(*MqttClientProxyMessage_Text); ok {
		return x.Text
	}
	return ""
}

func (x *MqttClientProxyMessage) GetRetained() bool {
	if x != nil {
		return x.Retained
	}
	return false
}

type isMqttClientProxyMessage_PayloadVariant interface {
	isMqttClientProxyMessage_PayloadVariant()
}

type MqttClientProxyMessage_Data struct {
	// Bytes
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

type MqttClientProxyMessage_Text struct {
	// Text
	Text string `protobuf:"bytes,3,opt,name=text,proto3,oneof"`
}

func (*MqttClientProxyMessage_Data) isMqttClientProxyMessage_PayloadVariant() {}

func (*MqttClientProxyMessage_Text) isMqttClientProxyMessage_PayloadVariant() {}

// A packet envelope sent/received over the mesh
// only payload_variant is sent in the payload portion of the LORA packet.
// The other fields are either not sent at all, or sent in the special 16 byte LORA header.
type MeshPacket struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The sending node number.
	// Note: Our crypto implementation uses this field as well.
	// See [crypto](/docs/overview/encryption) for details.
	From uint32 `protobuf:"fixed32,1,opt,name=from,proto3" json:"from,omitempty"`
	// The (immediate) destination for this packet
	To uint32 `protobuf:"fixed32,2,opt,name=to,proto3" json:"to,omitempty"`
	// (Usually) If set, this indicates the index in the secondary_channels table that this packet was sent/received on.
	// If unset, packet was on the primary channel.
	// A particular node might know only a subset of channels in use on the mesh.
	// Therefore channel_index is inherently a local concept and meaningless to send between nodes.
	// Very briefly, while sending and receiving deep inside the device Router code, this field instead
	// contains the 'channel hash' instead of the index.
	// This 'trick' is only used while the payload_variant is an 'encrypted'.
	Channel uint32 `protobuf:"varint,3,opt,name=channel,proto3" json:"channel,omitempty"`
	// Types that are assignable to PayloadVariant:
	//
	//	*MeshPacket_Decoded
	//	*MeshPacket_Encrypted
	PayloadVariant isMeshPacket_PayloadVariant `protobuf_oneof:"payload_variant"`
	// A unique ID for this packet.
	// Always 0 for no-ack packets or non broadcast packets (and therefore take zero bytes of space).
	// Otherwise a unique ID for this packet, useful for flooding algorithms.
	// ID only needs to be unique on a _per sender_ basis, and it only
	// needs to be unique for a few minutes (long enough to last for the length of
	// any ACK or the completion of a mesh broadcast flood).
	// Note: Our crypto implementation uses this id as well.
	// See [crypto](/docs/overview/encryption) for details.
	Id uint32 `protobuf:"fixed32,6,opt,name=id,proto3" json:"id,omitempty"`
	// The time this message was received by the esp32 (secs since 1970).
	// Note: this field is _never_ sent on the radio link itself (to save space) Times
	// are typically not sent over the mesh, but they will be added to any Packet
	// (chain of SubPacket) sent to the phone (so the phone can know exact time of reception)
	RxTime uint32 `protobuf:"fixed32,7,opt,name=rx_time,json=rxTime,proto3" json:"rx_time,omitempty"`
	// *Never* sent over the radio links.
	// Set during reception to indicate the SNR of this packet.
	// Used to collect statistics on current link quality.
	RxSnr float32 `protobuf:"fixed32,8,opt,name=rx_snr,json=rxSnr,proto3" json:"rx_snr,omitempty"`
	// If unset treated as zero (no forwarding, send to adjacent nodes only)
	// if 1, allow hopping through one node, etc...
	// For our usecase real world topologies probably have a max of about 3.
	// This field is normally placed into a few of bits in the header.
	HopLimit uint32 `protobuf:"varint,9,opt,name=hop_limit,json=hopLimit,proto3" json:"hop_limit,omitempty"`
	// This packet is being sent as a reliable message, we would prefer it to arrive at the destination.
	// We would like to receive a ack packet in response.
	// Broadcasts messages treat this flag specially: Since acks for broadcasts would
	// rapidly flood the channel, the normal ack behavior is suppressed.
	// Instead, the original sender listens to see if at least one node is rebroadcasting this packet (because naive flooding algorithm).
	// If it hears that the odds (given typical LoRa topologies) the odds are very high that every node should eventually receive the message.
	// So FloodingRouter.cpp generates an implicit ack which is delivered to the original sender.
	// If after some time we don't hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
	// Note: This flag is normally sent in a flag bit in the header when sent over the wire
	WantAck bool `protobuf:"varint,10,opt,name=want_ack,json=wantAck,proto3" json:"want_ack,omitempty"`
	// The priority of this message for sending.
	// See MeshPacket.Priority description for more details.
	Priority MeshPacket_Priority `protobuf:"varint,11,opt,name=priority,proto3,enum=meshtastic.MeshPacket_Priority" json:"priority,omitempty"`
	// rssi of received packet. Only sent to phone for dispay purposes.
	RxRssi int32 `protobuf:"varint,12,opt,name=rx_rssi,json=rxRssi,proto3" json:"rx_rssi,omitempty"`
	// Describe if this message is delayed
	//
	// Deprecated: Do not use.
	Delayed MeshPacket_Delayed `protobuf:"varint,13,opt,name=delayed,proto3,enum=meshtastic.MeshPacket_Delayed" json:"delayed,omitempty"`
	// Describes whether this packet passed via MQTT somewhere along the path it currently took.
	ViaMqtt bool `protobuf:"varint,14,opt,name=via_mqtt,json=viaMqtt,proto3" json:"via_mqtt,omitempty"`
	// Hop limit with which the original packet started. Sent via LoRa using three bits in the unencrypted header.
	// When receiving a packet, the difference between hop_start and hop_limit gives how many hops it traveled.
	HopStart uint32 `protobuf:"varint,15,opt,name=hop_start,json=hopStart,proto3" json:"hop_start,omitempty"`
}

func (x *MeshPacket) Reset() {
	*x = MeshPacket{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MeshPacket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MeshPacket) ProtoMessage() {}

func (x *MeshPacket) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MeshPacket.ProtoReflect.Descriptor instead.
func (*MeshPacket) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{7}
}

func (x *MeshPacket) GetFrom() uint32 {
	if x != nil {
		return x.From
	}
	return 0
}

func (x *MeshPacket) GetTo() uint32 {
	if x != nil {
		return x.To
	}
	return 0
}

func (x *MeshPacket) GetChannel() uint32 {
	if x != nil {
		return x.Channel
	}
	return 0
}

func (m *MeshPacket) GetPayloadVariant() isMeshPacket_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *MeshPacket) GetDecoded() *Data {
	if x, ok := x.GetPayloadVariant().(*MeshPacket_Decoded); ok {
		return x.Decoded
	}
	return nil
}

func (x *MeshPacket) GetEncrypted() []byte {
	if x, ok := x.GetPayloadVariant().(*MeshPacket_Encrypted); ok {
		return x.Encrypted
	}
	return nil
}

func (x *MeshPacket) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *MeshPacket) GetRxTime() uint32 {
	if x != nil {
		return x.RxTime
	}
	return 0
}

func (x *MeshPacket) GetRxSnr() float32 {
	if x != nil {
		return x.RxSnr
	}
	return 0
}

func (x *MeshPacket) GetHopLimit() uint32 {
	if x != nil {
		return x.HopLimit
	}
	return 0
}

func (x *MeshPacket) GetWantAck() bool {
	if x != nil {
		return x.WantAck
	}
	return false
}

func (x *MeshPacket) GetPriority() MeshPacket_Priority {
	if x != nil {
		return x.Priority
	}
	return MeshPacket_UNSET
}

func (x *MeshPacket) GetRxRssi() int32 {
	if x != nil {
		return x.RxRssi
	}
	return 0
}

// Deprecated: Do not use.
func (x *MeshPacket) GetDelayed() MeshPacket_Delayed {
	if x != nil {
		return x.Delayed
	}
	return MeshPacket_NO_DELAY
}

func (x *MeshPacket) GetViaMqtt() bool {
	if x != nil {
		return x.ViaMqtt
	}
	return false
}

func (x *MeshPacket) GetHopStart() uint32 {
	if x != nil {
		return x.HopStart
	}
	return 0
}

type isMeshPacket_PayloadVariant interface {
	isMeshPacket_PayloadVariant()
}

type MeshPacket_Decoded struct {
	// TODO: REPLACE
	Decoded *Data `protobuf:"bytes,4,opt,name=decoded,proto3,oneof"`
}

type MeshPacket_Encrypted struct {
	// TODO: REPLACE
	Encrypted []byte `protobuf:"bytes,5,opt,name=encrypted,proto3,oneof"`
}

func (*MeshPacket_Decoded) isMeshPacket_PayloadVariant() {}

func (*MeshPacket_Encrypted) isMeshPacket_PayloadVariant() {}

// The bluetooth to device link:
// Old BTLE protocol docs from TODO, merge in above and make real docs...
// use protocol buffers, and NanoPB
// messages from device to phone:
// POSITION_UPDATE (..., time)
// TEXT_RECEIVED(from, text, time)
// OPAQUE_RECEIVED(from, payload, time) (for signal messages or other applications)
// messages from phone to device:
// SET_MYID(id, human readable long, human readable short) (send down the unique ID
// string used for this node, a human readable string shown for that id, and a very
// short human readable string suitable for oled screen) SEND_OPAQUE(dest, payload)
// (for signal messages or other applications) SEND_TEXT(dest, text) Get all
// nodes() (returns list of nodes, with full info, last time seen, loc, battery
// level etc) SET_CONFIG (switches device to a new set of radio params and
// preshared key, drops all existing nodes, force our node to rejoin this new group)
// Full information about a node on the mesh
type NodeInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The node number
	Num uint32 `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"`
	// The user info for this node
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// This position data. Note: before 1.2.14 we would also store the last time we've heard from this node in position.time, that is no longer true.
	// Position.time now indicates the last time we received a POSITION from that node.
	Position *Position `protobuf:"bytes,3,opt,name=position,proto3" json:"position,omitempty"`
	// Returns the Signal-to-noise ratio (SNR) of the last received message,
	// as measured by the receiver. Return SNR of the last received message in dB
	Snr float32 `protobuf:"fixed32,4,opt,name=snr,proto3" json:"snr,omitempty"`
	// Set to indicate the last time we received a packet from this node
	LastHeard uint32 `protobuf:"fixed32,5,opt,name=last_heard,json=lastHeard,proto3" json:"last_heard,omitempty"`
	// The latest device metrics for the node.
	DeviceMetrics *DeviceMetrics `protobuf:"bytes,6,opt,name=device_metrics,json=deviceMetrics,proto3" json:"device_metrics,omitempty"`
	// local channel index we heard that node on. Only populated if its not the default channel.
	Channel uint32 `protobuf:"varint,7,opt,name=channel,proto3" json:"channel,omitempty"`
	// True if we witnessed the node over MQTT instead of LoRA transport
	ViaMqtt bool `protobuf:"varint,8,opt,name=via_mqtt,json=viaMqtt,proto3" json:"via_mqtt,omitempty"`
	// Number of hops away from us this node is (0 if adjacent)
	HopsAway uint32 `protobuf:"varint,9,opt,name=hops_away,json=hopsAway,proto3" json:"hops_away,omitempty"`
}

func (x *NodeInfo) Reset() {
	*x = NodeInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeInfo) ProtoMessage() {}

func (x *NodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeInfo.ProtoReflect.Descriptor instead.
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{8}
}

func (x *NodeInfo) GetNum() uint32 {
	if x != nil {
		return x.Num
	}
	return 0
}

func (x *NodeInfo) GetUser() *User {
	if x != nil {
		return x.User
	}
	return nil
}

func (x *NodeInfo) GetPosition() *Position {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *NodeInfo) GetSnr() float32 {
	if x != nil {
		return x.Snr
	}
	return 0
}

func (x *NodeInfo) GetLastHeard() uint32 {
	if x != nil {
		return x.LastHeard
	}
	return 0
}

func (x *NodeInfo) GetDeviceMetrics() *DeviceMetrics {
	if x != nil {
		return x.DeviceMetrics
	}
	return nil
}

func (x *NodeInfo) GetChannel() uint32 {
	if x != nil {
		return x.Channel
	}
	return 0
}

func (x *NodeInfo) GetViaMqtt() bool {
	if x != nil {
		return x.ViaMqtt
	}
	return false
}

func (x *NodeInfo) GetHopsAway() uint32 {
	if x != nil {
		return x.HopsAway
	}
	return 0
}

// Unique local debugging info for this node
// Note: we don't include position or the user info, because that will come in the
// Sent to the phone in response to WantNodes.
type MyNodeInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Tells the phone what our node number is, default starting value is
	// lowbyte of macaddr, but it will be fixed if that is already in use
	MyNodeNum uint32 `protobuf:"varint,1,opt,name=my_node_num,json=myNodeNum,proto3" json:"my_node_num,omitempty"`
	// The total number of reboots this node has ever encountered
	// (well - since the last time we discarded preferences)
	RebootCount uint32 `protobuf:"varint,8,opt,name=reboot_count,json=rebootCount,proto3" json:"reboot_count,omitempty"`
	// The minimum app version that can talk to this device.
	// Phone/PC apps should compare this to their build number and if too low tell the user they must update their app
	MinAppVersion uint32 `protobuf:"varint,11,opt,name=min_app_version,json=minAppVersion,proto3" json:"min_app_version,omitempty"`
}

func (x *MyNodeInfo) Reset() {
	*x = MyNodeInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MyNodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MyNodeInfo) ProtoMessage() {}

func (x *MyNodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MyNodeInfo.ProtoReflect.Descriptor instead.
func (*MyNodeInfo) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{9}
}

func (x *MyNodeInfo) GetMyNodeNum() uint32 {
	if x != nil {
		return x.MyNodeNum
	}
	return 0
}

func (x *MyNodeInfo) GetRebootCount() uint32 {
	if x != nil {
		return x.RebootCount
	}
	return 0
}

func (x *MyNodeInfo) GetMinAppVersion() uint32 {
	if x != nil {
		return x.MinAppVersion
	}
	return 0
}

// Debug output from the device.
// To minimize the size of records inside the device code, if a time/source/level is not set
// on the message it is assumed to be a continuation of the previously sent message.
// This allows the device code to use fixed maxlen 64 byte strings for messages,
// and then extend as needed by emitting multiple records.
type LogRecord struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Log levels, chosen to match python logging conventions.
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	// Seconds since 1970 - or 0 for unknown/unset
	Time uint32 `protobuf:"fixed32,2,opt,name=time,proto3" json:"time,omitempty"`
	// Usually based on thread name - if known
	Source string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	// Not yet set
	Level LogRecord_Level `protobuf:"varint,4,opt,name=level,proto3,enum=meshtastic.LogRecord_Level" json:"level,omitempty"`
}

func (x *LogRecord) Reset() {
	*x = LogRecord{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LogRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogRecord) ProtoMessage() {}

func (x *LogRecord) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogRecord.ProtoReflect.Descriptor instead.
func (*LogRecord) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{10}
}

func (x *LogRecord) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *LogRecord) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *LogRecord) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *LogRecord) GetLevel() LogRecord_Level {
	if x != nil {
		return x.Level
	}
	return LogRecord_UNSET
}

type QueueStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Last attempt to queue status, ErrorCode
	Res int32 `protobuf:"varint,1,opt,name=res,proto3" json:"res,omitempty"`
	// Free entries in the outgoing queue
	Free uint32 `protobuf:"varint,2,opt,name=free,proto3" json:"free,omitempty"`
	// Maximum entries in the outgoing queue
	Maxlen uint32 `protobuf:"varint,3,opt,name=maxlen,proto3" json:"maxlen,omitempty"`
	// What was mesh packet id that generated this response?
	MeshPacketId uint32 `protobuf:"varint,4,opt,name=mesh_packet_id,json=meshPacketId,proto3" json:"mesh_packet_id,omitempty"`
}

func (x *QueueStatus) Reset() {
	*x = QueueStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QueueStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueueStatus) ProtoMessage() {}

func (x *QueueStatus) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueueStatus.ProtoReflect.Descriptor instead.
func (*QueueStatus) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{11}
}

func (x *QueueStatus) GetRes() int32 {
	if x != nil {
		return x.Res
	}
	return 0
}

func (x *QueueStatus) GetFree() uint32 {
	if x != nil {
		return x.Free
	}
	return 0
}

func (x *QueueStatus) GetMaxlen() uint32 {
	if x != nil {
		return x.Maxlen
	}
	return 0
}

func (x *QueueStatus) GetMeshPacketId() uint32 {
	if x != nil {
		return x.MeshPacketId
	}
	return 0
}

// Packets from the radio to the phone will appear on the fromRadio characteristic.
// It will support READ and NOTIFY. When a new packet arrives the device will BLE notify?
// It will sit in that descriptor until consumed by the phone,
// at which point the next item in the FIFO will be populated.
type FromRadio struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The packet id, used to allow the phone to request missing read packets from the FIFO,
	// see our bluetooth docs
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Log levels, chosen to match python logging conventions.
	//
	// Types that are assignable to PayloadVariant:
	//
	//	*FromRadio_Packet
	//	*FromRadio_MyInfo
	//	*FromRadio_NodeInfo
	//	*FromRadio_Config
	//	*FromRadio_LogRecord
	//	*FromRadio_ConfigCompleteId
	//	*FromRadio_Rebooted
	//	*FromRadio_ModuleConfig
	//	*FromRadio_Channel
	//	*FromRadio_QueueStatus
	//	*FromRadio_XmodemPacket
	//	*FromRadio_Metadata
	//	*FromRadio_MqttClientProxyMessage
	PayloadVariant isFromRadio_PayloadVariant `protobuf_oneof:"payload_variant"`
}

func (x *FromRadio) Reset() {
	*x = FromRadio{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FromRadio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FromRadio) ProtoMessage() {}

func (x *FromRadio) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FromRadio.ProtoReflect.Descriptor instead.
func (*FromRadio) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{12}
}

func (x *FromRadio) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (m *FromRadio) GetPayloadVariant() isFromRadio_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *FromRadio) GetPacket() *MeshPacket {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Packet); ok {
		return x.Packet
	}
	return nil
}

func (x *FromRadio) GetMyInfo() *MyNodeInfo {
	if x, ok := x.GetPayloadVariant().(*FromRadio_MyInfo); ok {
		return x.MyInfo
	}
	return nil
}

func (x *FromRadio) GetNodeInfo() *NodeInfo {
	if x, ok := x.GetPayloadVariant().(*FromRadio_NodeInfo); ok {
		return x.NodeInfo
	}
	return nil
}

func (x *FromRadio) GetConfig() *Config {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Config); ok {
		return x.Config
	}
	return nil
}

func (x *FromRadio) GetLogRecord() *LogRecord {
	if x, ok := x.GetPayloadVariant().(*FromRadio_LogRecord); ok {
		return x.LogRecord
	}
	return nil
}

func (x *FromRadio) GetConfigCompleteId() uint32 {
	if x, ok := x.GetPayloadVariant().(*FromRadio_ConfigCompleteId); ok {
		return x.ConfigCompleteId
	}
	return 0
}

func (x *FromRadio) GetRebooted() bool {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Rebooted); ok {
		return x.Rebooted
	}
	return false
}

func (x *FromRadio) GetModuleConfig() *ModuleConfig {
	if x, ok := x.GetPayloadVariant().(*FromRadio_ModuleConfig); ok {
		return x.ModuleConfig
	}
	return nil
}

func (x *FromRadio) GetChannel() *Channel {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Channel); ok {
		return x.Channel
	}
	return nil
}

func (x *FromRadio) GetQueueStatus() *QueueStatus {
	if x, ok := x.GetPayloadVariant().(*FromRadio_QueueStatus); ok {
		return x.QueueStatus
	}
	return nil
}

func (x *FromRadio) GetXmodemPacket() *XModem {
	if x, ok := x.GetPayloadVariant().(*FromRadio_XmodemPacket); ok {
		return x.XmodemPacket
	}
	return nil
}

func (x *FromRadio) GetMetadata() *DeviceMetadata {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Metadata); ok {
		return x.Metadata
	}
	return nil
}

func (x *FromRadio) GetMqttClientProxyMessage() *MqttClientProxyMessage {
	if x, ok := x.GetPayloadVariant().(*FromRadio_MqttClientProxyMessage); ok {
		return x.MqttClientProxyMessage
	}
	return nil
}

type isFromRadio_PayloadVariant interface {
	isFromRadio_PayloadVariant()
}

type FromRadio_Packet struct {
	// Log levels, chosen to match python logging conventions.
	Packet *MeshPacket `protobuf:"bytes,2,opt,name=packet,proto3,oneof"`
}

type FromRadio_MyInfo struct {
	// Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
	// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
	MyInfo *MyNodeInfo `protobuf:"bytes,3,opt,name=my_info,json=myInfo,proto3,oneof"`
}

type FromRadio_NodeInfo struct {
	// One packet is sent for each node in the on radio DB
	// starts over with the first node in our DB
	NodeInfo *NodeInfo `protobuf:"bytes,4,opt,name=node_info,json=nodeInfo,proto3,oneof"`
}

type FromRadio_Config struct {
	// Include a part of the config (was: RadioConfig radio)
	Config *Config `protobuf:"bytes,5,opt,name=config,proto3,oneof"`
}

type FromRadio_LogRecord struct {
	// Set to send debug console output over our protobuf stream
	LogRecord *LogRecord `protobuf:"bytes,6,opt,name=log_record,json=logRecord,proto3,oneof"`
}

type FromRadio_ConfigCompleteId struct {
	// Sent as true once the device has finished sending all of the responses to want_config
	// recipient should check if this ID matches our original request nonce, if
	// not, it means your config responses haven't started yet.
	// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
	ConfigCompleteId uint32 `protobuf:"varint,7,opt,name=config_complete_id,json=configCompleteId,proto3,oneof"`
}

type FromRadio_Rebooted struct {
	// Sent to tell clients the radio has just rebooted.
	// Set to true if present.
	// Not used on all transports, currently just used for the serial console.
	// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
	Rebooted bool `protobuf:"varint,8,opt,name=rebooted,proto3,oneof"`
}

type FromRadio_ModuleConfig struct {
	// Include module config
	ModuleConfig *ModuleConfig `protobuf:"bytes,9,opt,name=moduleConfig,proto3,oneof"`
}

type FromRadio_Channel struct {
	// One packet is sent for each channel
	Channel *Channel `protobuf:"bytes,10,opt,name=channel,proto3,oneof"`
}

type FromRadio_QueueStatus struct {
	// Queue status info
	QueueStatus *QueueStatus `protobuf:"bytes,11,opt,name=queueStatus,proto3,oneof"`
}

type FromRadio_XmodemPacket struct {
	// File Transfer Chunk
	XmodemPacket *XModem `protobuf:"bytes,12,opt,name=xmodemPacket,proto3,oneof"`
}

type FromRadio_Metadata struct {
	// Device metadata message
	Metadata *DeviceMetadata `protobuf:"bytes,13,opt,name=metadata,proto3,oneof"`
}

type FromRadio_MqttClientProxyMessage struct {
	// MQTT Client Proxy Message (device sending to client / phone for publishing to MQTT)
	MqttClientProxyMessage *MqttClientProxyMessage `protobuf:"bytes,14,opt,name=mqttClientProxyMessage,proto3,oneof"`
}

func (*FromRadio_Packet) isFromRadio_PayloadVariant() {}

func (*FromRadio_MyInfo) isFromRadio_PayloadVariant() {}

func (*FromRadio_NodeInfo) isFromRadio_PayloadVariant() {}

func (*FromRadio_Config) isFromRadio_PayloadVariant() {}

func (*FromRadio_LogRecord) isFromRadio_PayloadVariant() {}

func (*FromRadio_ConfigCompleteId) isFromRadio_PayloadVariant() {}

func (*FromRadio_Rebooted) isFromRadio_PayloadVariant() {}

func (*FromRadio_ModuleConfig) isFromRadio_PayloadVariant() {}

func (*FromRadio_Channel) isFromRadio_PayloadVariant() {}

func (*FromRadio_QueueStatus) isFromRadio_PayloadVariant() {}

func (*FromRadio_XmodemPacket) isFromRadio_PayloadVariant() {}

func (*FromRadio_Metadata) isFromRadio_PayloadVariant() {}

func (*FromRadio_MqttClientProxyMessage) isFromRadio_PayloadVariant() {}

// Packets/commands to the radio will be written (reliably) to the toRadio characteristic.
// Once the write completes the phone can assume it is handled.
type ToRadio struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Log levels, chosen to match python logging conventions.
	//
	// Types that are assignable to PayloadVariant:
	//
	//	*ToRadio_Packet
	//	*ToRadio_WantConfigId
	//	*ToRadio_Disconnect
	//	*ToRadio_XmodemPacket
	//	*ToRadio_MqttClientProxyMessage
	PayloadVariant isToRadio_PayloadVariant `protobuf_oneof:"payload_variant"`
}

func (x *ToRadio) Reset() {
	*x = ToRadio{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ToRadio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToRadio) ProtoMessage() {}

func (x *ToRadio) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToRadio.ProtoReflect.Descriptor instead.
func (*ToRadio) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{13}
}

func (m *ToRadio) GetPayloadVariant() isToRadio_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *ToRadio) GetPacket() *MeshPacket {
	if x, ok := x.GetPayloadVariant().(*ToRadio_Packet); ok {
		return x.Packet
	}
	return nil
}

func (x *ToRadio) GetWantConfigId() uint32 {
	if x, ok := x.GetPayloadVariant().(*ToRadio_WantConfigId); ok {
		return x.WantConfigId
	}
	return 0
}

func (x *ToRadio) GetDisconnect() bool {
	if x, ok := x.GetPayloadVariant().(*ToRadio_Disconnect); ok {
		return x.Disconnect
	}
	return false
}

func (x *ToRadio) GetXmodemPacket() *XModem {
	if x, ok := x.GetPayloadVariant().(*ToRadio_XmodemPacket); ok {
		return x.XmodemPacket
	}
	return nil
}

func (x *ToRadio) GetMqttClientProxyMessage() *MqttClientProxyMessage {
	if x, ok := x.GetPayloadVariant().(*ToRadio_MqttClientProxyMessage); ok {
		return x.MqttClientProxyMessage
	}
	return nil
}

type isToRadio_PayloadVariant interface {
	isToRadio_PayloadVariant()
}

type ToRadio_Packet struct {
	// Send this packet on the mesh
	Packet *MeshPacket `protobuf:"bytes,1,opt,name=packet,proto3,oneof"`
}

type ToRadio_WantConfigId struct {
	// Phone wants radio to send full node db to the phone, This is
	// typically the first packet sent to the radio when the phone gets a
	// bluetooth connection. The radio will respond by sending back a
	// MyNodeInfo, a owner, a radio config and a series of
	// FromRadio.node_infos, and config_complete
	// the integer you write into this field will be reported back in the
	// config_complete_id response this allows clients to never be confused by
	// a stale old partially sent config.
	WantConfigId uint32 `protobuf:"varint,3,opt,name=want_config_id,json=wantConfigId,proto3,oneof"`
}

type ToRadio_Disconnect struct {
	// Tell API server we are disconnecting now.
	// This is useful for serial links where there is no hardware/protocol based notification that the client has dropped the link.
	// (Sending this message is optional for clients)
	Disconnect bool `protobuf:"varint,4,opt,name=disconnect,proto3,oneof"`
}

type ToRadio_XmodemPacket struct {
	XmodemPacket *XModem `protobuf:"bytes,5,opt,name=xmodemPacket,proto3,oneof"`
}

type ToRadio_MqttClientProxyMessage struct {
	// MQTT Client Proxy Message (for client / phone subscribed to MQTT sending to device)
	MqttClientProxyMessage *MqttClientProxyMessage `protobuf:"bytes,6,opt,name=mqttClientProxyMessage,proto3,oneof"`
}

func (*ToRadio_Packet) isToRadio_PayloadVariant() {}

func (*ToRadio_WantConfigId) isToRadio_PayloadVariant() {}

func (*ToRadio_Disconnect) isToRadio_PayloadVariant() {}

func (*ToRadio_XmodemPacket) isToRadio_PayloadVariant() {}

func (*ToRadio_MqttClientProxyMessage) isToRadio_PayloadVariant() {}

// Compressed message payload
type Compressed struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// PortNum to determine the how to handle the compressed payload.
	Portnum PortNum `protobuf:"varint,1,opt,name=portnum,proto3,enum=meshtastic.PortNum" json:"portnum,omitempty"`
	// Compressed data.
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (x *Compressed) Reset() {
	*x = Compressed{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Compressed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Compressed) ProtoMessage() {}

func (x *Compressed) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Compressed.ProtoReflect.Descriptor instead.
func (*Compressed) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{14}
}

func (x *Compressed) GetPortnum() PortNum {
	if x != nil {
		return x.Portnum
	}
	return PortNum_UNKNOWN_APP
}

func (x *Compressed) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

// Full info on edges for a single node
type NeighborInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The node ID of the node sending info on its neighbors
	NodeId uint32 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Field to pass neighbor info for the next sending cycle
	LastSentById uint32 `protobuf:"varint,2,opt,name=last_sent_by_id,json=lastSentById,proto3" json:"last_sent_by_id,omitempty"`
	// Broadcast interval of the represented node (in seconds)
	NodeBroadcastIntervalSecs uint32 `protobuf:"varint,3,opt,name=node_broadcast_interval_secs,json=nodeBroadcastIntervalSecs,proto3" json:"node_broadcast_interval_secs,omitempty"`
	// The list of out edges from this node
	Neighbors []*Neighbor `protobuf:"bytes,4,rep,name=neighbors,proto3" json:"neighbors,omitempty"`
}

func (x *NeighborInfo) Reset() {
	*x = NeighborInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NeighborInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NeighborInfo) ProtoMessage() {}

func (x *NeighborInfo) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NeighborInfo.ProtoReflect.Descriptor instead.
func (*NeighborInfo) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{15}
}

func (x *NeighborInfo) GetNodeId() uint32 {
	if x != nil {
		return x.NodeId
	}
	return 0
}

func (x *NeighborInfo) GetLastSentById() uint32 {
	if x != nil {
		return x.LastSentById
	}
	return 0
}

func (x *NeighborInfo) GetNodeBroadcastIntervalSecs() uint32 {
	if x != nil {
		return x.NodeBroadcastIntervalSecs
	}
	return 0
}

func (x *NeighborInfo) GetNeighbors() []*Neighbor {
	if x != nil {
		return x.Neighbors
	}
	return nil
}

// A single edge in the mesh
type Neighbor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Node ID of neighbor
	NodeId uint32 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// SNR of last heard message
	Snr float32 `protobuf:"fixed32,2,opt,name=snr,proto3" json:"snr,omitempty"`
	// Reception time (in secs since 1970) of last message that was last sent by this ID.
	// Note: this is for local storage only and will not be sent out over the mesh.
	LastRxTime uint32 `protobuf:"fixed32,3,opt,name=last_rx_time,json=lastRxTime,proto3" json:"last_rx_time,omitempty"`
	// Broadcast interval of this neighbor (in seconds).
	// Note: this is for local storage only and will not be sent out over the mesh.
	NodeBroadcastIntervalSecs uint32 `protobuf:"varint,4,opt,name=node_broadcast_interval_secs,json=nodeBroadcastIntervalSecs,proto3" json:"node_broadcast_interval_secs,omitempty"`
}

func (x *Neighbor) Reset() {
	*x = Neighbor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Neighbor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Neighbor) ProtoMessage() {}

func (x *Neighbor) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Neighbor.ProtoReflect.Descriptor instead.
func (*Neighbor) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{16}
}

func (x *Neighbor) GetNodeId() uint32 {
	if x != nil {
		return x.NodeId
	}
	return 0
}

func (x *Neighbor) GetSnr() float32 {
	if x != nil {
		return x.Snr
	}
	return 0
}

func (x *Neighbor) GetLastRxTime() uint32 {
	if x != nil {
		return x.LastRxTime
	}
	return 0
}

func (x *Neighbor) GetNodeBroadcastIntervalSecs() uint32 {
	if x != nil {
		return x.NodeBroadcastIntervalSecs
	}
	return 0
}

// Device metadata response
type DeviceMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Device firmware version string
	FirmwareVersion string `protobuf:"bytes,1,opt,name=firmware_version,json=firmwareVersion,proto3" json:"firmware_version,omitempty"`
	// Device state version
	DeviceStateVersion uint32 `protobuf:"varint,2,opt,name=device_state_version,json=deviceStateVersion,proto3" json:"device_state_version,omitempty"`
	// Indicates whether the device can shutdown CPU natively or via power management chip
	CanShutdown bool `protobuf:"varint,3,opt,name=canShutdown,proto3" json:"canShutdown,omitempty"`
	// Indicates that the device has native wifi capability
	HasWifi bool `protobuf:"varint,4,opt,name=hasWifi,proto3" json:"hasWifi,omitempty"`
	// Indicates that the device has native bluetooth capability
	HasBluetooth bool `protobuf:"varint,5,opt,name=hasBluetooth,proto3" json:"hasBluetooth,omitempty"`
	// Indicates that the device has an ethernet peripheral
	HasEthernet bool `protobuf:"varint,6,opt,name=hasEthernet,proto3" json:"hasEthernet,omitempty"`
	// Indicates that the device's role in the mesh
	Role Config_DeviceConfig_Role `protobuf:"varint,7,opt,name=role,proto3,enum=meshtastic.Config_DeviceConfig_Role" json:"role,omitempty"`
	// Indicates the device's current enabled position flags
	PositionFlags uint32 `protobuf:"varint,8,opt,name=position_flags,json=positionFlags,proto3" json:"position_flags,omitempty"`
	// Device hardware model
	HwModel HardwareModel `protobuf:"varint,9,opt,name=hw_model,json=hwModel,proto3,enum=meshtastic.HardwareModel" json:"hw_model,omitempty"`
	// Has Remote Hardware enabled
	HasRemoteHardware bool `protobuf:"varint,10,opt,name=hasRemoteHardware,proto3" json:"hasRemoteHardware,omitempty"`
}

func (x *DeviceMetadata) Reset() {
	*x = DeviceMetadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DeviceMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeviceMetadata) ProtoMessage() {}

func (x *DeviceMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeviceMetadata.ProtoReflect.Descriptor instead.
func (*DeviceMetadata) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{17}
}

func (x *DeviceMetadata) GetFirmwareVersion() string {
	if x != nil {
		return x.FirmwareVersion
	}
	return ""
}

func (x *DeviceMetadata) GetDeviceStateVersion() uint32 {
	if x != nil {
		return x.DeviceStateVersion
	}
	return 0
}

func (x *DeviceMetadata) GetCanShutdown() bool {
	if x != nil {
		return x.CanShutdown
	}
	return false
}

func (x *DeviceMetadata) GetHasWifi() bool {
	if x != nil {
		return x.HasWifi
	}
	return false
}

func (x *DeviceMetadata) GetHasBluetooth() bool {
	if x != nil {
		return x.HasBluetooth
	}
	return false
}

func (x *DeviceMetadata) GetHasEthernet() bool {
	if x != nil {
		return x.HasEthernet
	}
	return false
}

func (x *DeviceMetadata) GetRole() Config_DeviceConfig_Role {
	if x != nil {
		return x.Role
	}
	return Config_DeviceConfig_CLIENT
}

func (x *DeviceMetadata) GetPositionFlags() uint32 {
	if x != nil {
		return x.PositionFlags
	}
	return 0
}

func (x *DeviceMetadata) GetHwModel() HardwareModel {
	if x != nil {
		return x.HwModel
	}
	return HardwareModel_UNSET
}

func (x *DeviceMetadata) GetHasRemoteHardware() bool {
	if x != nil {
		return x.HasRemoteHardware
	}
	return false
}

var File_meshtastic_mesh_proto protoreflect.FileDescriptor

var file_meshtastic_mesh_proto_rawDesc = []byte{
	0x0a, 0x15, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2f, 0x6d, 0x65, 0x73,
	0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73,
	0x74, 0x69, 0x63, 0x1a, 0x18, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2f,
	0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x6d,
	0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74,
	0x69, 0x63, 0x2f, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74,
	0x69, 0x63, 0x2f, 0x70, 0x6f, 0x72, 0x74, 0x6e, 0x75, 0x6d, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x1a, 0x1a, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2f, 0x74, 0x65,
	0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x6d,
	0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2f, 0x78, 0x6d, 0x6f, 0x64, 0x65, 0x6d,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x80, 0x08, 0x0a, 0x08, 0x50, 0x6f, 0x73, 0x69, 0x74,
	0x69, 0x6f, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f,
	0x69, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0f, 0x52, 0x09, 0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64,
	0x65, 0x49, 0x12, 0x1f, 0x0a, 0x0b, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f,
	0x69, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0f, 0x52, 0x0a, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75,
	0x64, 0x65, 0x49, 0x12, 0x1a, 0x0a, 0x08, 0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x12,
	0x12, 0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x07, 0x52, 0x04, 0x74,
	0x69, 0x6d, 0x65, 0x12, 0x47, 0x0a, 0x0f, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1e, 0x2e, 0x6d,
	0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x2e, 0x4c, 0x6f, 0x63, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x0e, 0x6c, 0x6f,
	0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x47, 0x0a, 0x0f,
	0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1e, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74,
	0x69, 0x63, 0x2e, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x41, 0x6c, 0x74, 0x53,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x0e, 0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x53,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
	0x6d, 0x70, 0x18, 0x07, 0x20, 0x01, 0x28, 0x07, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x12, 0x36, 0x0a, 0x17, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
	0x5f, 0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x73, 0x5f, 0x61, 0x64, 0x6a, 0x75, 0x73, 0x74, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x15, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x4d,
	0x69, 0x6c, 0x6c, 0x69, 0x73, 0x41, 0x64, 0x6a, 0x75, 0x73, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x61,
	0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x68, 0x61, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x11, 0x52, 0x0b, 0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x48, 0x61, 0x65, 0x12, 0x3e,
	0x0a, 0x1b, 0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x67, 0x65, 0x6f, 0x69, 0x64,
	0x61, 0x6c, 0x5f, 0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x0a, 0x20,
	0x01, 0x28, 0x11, 0x52, 0x19, 0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x47, 0x65, 0x6f,
	0x69, 0x64, 0x61, 0x6c, 0x53, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12,
	0x0a, 0x04, 0x50, 0x44, 0x4f, 0x50, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x50, 0x44,
	0x4f, 0x50, 0x12, 0x12, 0x0a, 0x04, 0x48, 0x44, 0x4f, 0x50, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x04, 0x48, 0x44, 0x4f, 0x50, 0x12, 0x12, 0x0a, 0x04, 0x56, 0x44, 0x4f, 0x50, 0x18, 0x0d,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x56, 0x44, 0x4f, 0x50, 0x12, 0x21, 0x0a, 0x0c, 0x67, 0x70,
	0x73, 0x5f, 0x61, 0x63, 0x63, 0x75, 0x72, 0x61, 0x63, 0x79, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x0b, 0x67, 0x70, 0x73, 0x41, 0x63, 0x63, 0x75, 0x72, 0x61, 0x63, 0x79, 0x12, 0x21, 0x0a,
	0x0c, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x5f, 0x73, 0x70, 0x65, 0x65, 0x64, 0x18, 0x0f, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x0b, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x53, 0x70, 0x65, 0x65, 0x64,
	0x12, 0x21, 0x0a, 0x0c, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x5f, 0x74, 0x72, 0x61, 0x63, 0x6b,
	0x18, 0x10, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x54, 0x72,
	0x61, 0x63, 0x6b, 0x12, 0x1f, 0x0a, 0x0b, 0x66, 0x69, 0x78, 0x5f, 0x71, 0x75, 0x61, 0x6c, 0x69,
	0x74, 0x79, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x66, 0x69, 0x78, 0x51, 0x75, 0x61,
	0x6c, 0x69, 0x74, 0x79, 0x12, 0x19, 0x0a, 0x08, 0x66, 0x69, 0x78, 0x5f, 0x74, 0x79, 0x70, 0x65,
	0x18, 0x12, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x66, 0x69, 0x78, 0x54, 0x79, 0x70, 0x65, 0x12,
	0x20, 0x0a, 0x0c, 0x73, 0x61, 0x74, 0x73, 0x5f, 0x69, 0x6e, 0x5f, 0x76, 0x69, 0x65, 0x77, 0x18,
	0x13, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x73, 0x61, 0x74, 0x73, 0x49, 0x6e, 0x56, 0x69, 0x65,
	0x77, 0x12, 0x1b, 0x0a, 0x09, 0x73, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x14,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x73, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x49, 0x64, 0x12, 0x1f,
	0x0a, 0x0b, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x18, 0x15, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x0a, 0x6e, 0x65, 0x78, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x12,
	0x1d, 0x0a, 0x0a, 0x73, 0x65, 0x71, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x16, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x09, 0x73, 0x65, 0x71, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x25,
	0x0a, 0x0e, 0x70, 0x72, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x62, 0x69, 0x74, 0x73,
	0x18, 0x17, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0d, 0x70, 0x72, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f,
	0x6e, 0x42, 0x69, 0x74, 0x73, 0x22, 0x4e, 0x0a, 0x09, 0x4c, 0x6f, 0x63, 0x53, 0x6f, 0x75, 0x72,
	0x63, 0x65, 0x12, 0x0d, 0x0a, 0x09, 0x4c, 0x4f, 0x43, 0x5f, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10,
	0x00, 0x12, 0x0e, 0x0a, 0x0a, 0x4c, 0x4f, 0x43, 0x5f, 0x4d, 0x41, 0x4e, 0x55, 0x41, 0x4c, 0x10,
	0x01, 0x12, 0x10, 0x0a, 0x0c, 0x4c, 0x4f, 0x43, 0x5f, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x4e, 0x41,
	0x4c, 0x10, 0x02, 0x12, 0x10, 0x0a, 0x0c, 0x4c, 0x4f, 0x43, 0x5f, 0x45, 0x58, 0x54, 0x45, 0x52,
	0x4e, 0x41, 0x4c, 0x10, 0x03, 0x22, 0x62, 0x0a, 0x09, 0x41, 0x6c, 0x74, 0x53, 0x6f, 0x75, 0x72,
	0x63, 0x65, 0x12, 0x0d, 0x0a, 0x09, 0x41, 0x4c, 0x54, 0x5f, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10,
	0x00, 0x12, 0x0e, 0x0a, 0x0a, 0x41, 0x4c, 0x54, 0x5f, 0x4d, 0x41, 0x4e, 0x55, 0x41, 0x4c, 0x10,
	0x01, 0x12, 0x10, 0x0a, 0x0c, 0x41, 0x4c, 0x54, 0x5f, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x4e, 0x41,
	0x4c, 0x10, 0x02, 0x12, 0x10, 0x0a, 0x0c, 0x41, 0x4c, 0x54, 0x5f, 0x45, 0x58, 0x54, 0x45, 0x52,
	0x4e, 0x41, 0x4c, 0x10, 0x03, 0x12, 0x12, 0x0a, 0x0e, 0x41, 0x4c, 0x54, 0x5f, 0x42, 0x41, 0x52,
	0x4f, 0x4d, 0x45, 0x54, 0x52, 0x49, 0x43, 0x10, 0x04, 0x22, 0x81, 0x02, 0x0a, 0x04, 0x55, 0x73,
	0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02,
	0x69, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x6f, 0x6e, 0x67, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x6f, 0x6e, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0x12,
	0x1d, 0x0a, 0x0a, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1c,
	0x0a, 0x07, 0x6d, 0x61, 0x63, 0x61, 0x64, 0x64, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x42,
	0x02, 0x18, 0x01, 0x52, 0x07, 0x6d, 0x61, 0x63, 0x61, 0x64, 0x64, 0x72, 0x12, 0x34, 0x0a, 0x08,
	0x68, 0x77, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x19,
	0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x48, 0x61, 0x72, 0x64,
	0x77, 0x61, 0x72, 0x65, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x52, 0x07, 0x68, 0x77, 0x4d, 0x6f, 0x64,
	0x65, 0x6c, 0x12, 0x1f, 0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65,
	0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x69, 0x73, 0x4c, 0x69, 0x63, 0x65, 0x6e,
	0x73, 0x65, 0x64, 0x12, 0x38, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x24, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x43, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x2e, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x22, 0x26, 0x0a,
	0x0e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x12,
	0x14, 0x0a, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x18, 0x01, 0x20, 0x03, 0x28, 0x07, 0x52, 0x05,
	0x72, 0x6f, 0x75, 0x74, 0x65, 0x22, 0xa3, 0x03, 0x0a, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x69, 0x6e,
	0x67, 0x12, 0x41, 0x0a, 0x0d, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74,
	0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x69, 0x73, 0x63, 0x6f,
	0x76, 0x65, 0x72, 0x79, 0x48, 0x00, 0x52, 0x0c, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x3d, 0x0a, 0x0b, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x72, 0x65,
	0x70, 0x6c, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x65, 0x73, 0x68,
	0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x69, 0x73, 0x63,
	0x6f, 0x76, 0x65, 0x72, 0x79, 0x48, 0x00, 0x52, 0x0a, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65,
	0x70, 0x6c, 0x79, 0x12, 0x3e, 0x0a, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x72, 0x65, 0x61,
	0x73, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x19, 0x2e, 0x6d, 0x65, 0x73, 0x68,
	0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x2e, 0x45,
	0x72, 0x72, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x0b, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x52, 0x65, 0x61,
	0x73, 0x6f, 0x6e, 0x22, 0xca, 0x01, 0x0a, 0x05, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x08, 0x0a,
	0x04, 0x4e, 0x4f, 0x4e, 0x45, 0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x4e, 0x4f, 0x5f, 0x52, 0x4f,
	0x55, 0x54, 0x45, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x47, 0x4f, 0x54, 0x5f, 0x4e, 0x41, 0x4b,
	0x10, 0x02, 0x12, 0x0b, 0x0a, 0x07, 0x54, 0x49, 0x4d, 0x45, 0x4f, 0x55, 0x54, 0x10, 0x03, 0x12,
	0x10, 0x0a, 0x0c, 0x4e, 0x4f, 0x5f, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x46, 0x41, 0x43, 0x45, 0x10,
	0x04, 0x12, 0x12, 0x0a, 0x0e, 0x4d, 0x41, 0x58, 0x5f, 0x52, 0x45, 0x54, 0x52, 0x41, 0x4e, 0x53,
	0x4d, 0x49, 0x54, 0x10, 0x05, 0x12, 0x0e, 0x0a, 0x0a, 0x4e, 0x4f, 0x5f, 0x43, 0x48, 0x41, 0x4e,
	0x4e, 0x45, 0x4c, 0x10, 0x06, 0x12, 0x0d, 0x0a, 0x09, 0x54, 0x4f, 0x4f, 0x5f, 0x4c, 0x41, 0x52,
	0x47, 0x45, 0x10, 0x07, 0x12, 0x0f, 0x0a, 0x0b, 0x4e, 0x4f, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f,
	0x4e, 0x53, 0x45, 0x10, 0x08, 0x12, 0x14, 0x0a, 0x10, 0x44, 0x55, 0x54, 0x59, 0x5f, 0x43, 0x59,
	0x43, 0x4c, 0x45, 0x5f, 0x4c, 0x49, 0x4d, 0x49, 0x54, 0x10, 0x09, 0x12, 0x0f, 0x0a, 0x0b, 0x42,
	0x41, 0x44, 0x5f, 0x52, 0x45, 0x51, 0x55, 0x45, 0x53, 0x54, 0x10, 0x20, 0x12, 0x12, 0x0a, 0x0e,
	0x4e, 0x4f, 0x54, 0x5f, 0x41, 0x55, 0x54, 0x48, 0x4f, 0x52, 0x49, 0x5a, 0x45, 0x44, 0x10, 0x21,
	0x42, 0x09, 0x0a, 0x07, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x22, 0xf0, 0x01, 0x0a, 0x04,
	0x44, 0x61, 0x74, 0x61, 0x12, 0x2d, 0x0a, 0x07, 0x70, 0x6f, 0x72, 0x74, 0x6e, 0x75, 0x6d, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74,
	0x69, 0x63, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x4e, 0x75, 0x6d, 0x52, 0x07, 0x70, 0x6f, 0x72, 0x74,
	0x6e, 0x75, 0x6d, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x23, 0x0a,
	0x0d, 0x77, 0x61, 0x6e, 0x74, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x77, 0x61, 0x6e, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x65, 0x73, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x07,
	0x52, 0x04, 0x64, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x07, 0x52, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x1d,
	0x0a, 0x0a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x07, 0x52, 0x09, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x12, 0x19, 0x0a,
	0x08, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x5f, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x07, 0x52,
	0x07, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x6f, 0x6a,
	0x69, 0x18, 0x08, 0x20, 0x01, 0x28, 0x07, 0x52, 0x05, 0x65, 0x6d, 0x6f, 0x6a, 0x69, 0x22, 0xd9,
	0x01, 0x0a, 0x08, 0x57, 0x61, 0x79, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x6c,
	0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x69, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0f, 0x52,
	0x09, 0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x49, 0x12, 0x1f, 0x0a, 0x0b, 0x6c, 0x6f,
	0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x69, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0f, 0x52,
	0x0a, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x49, 0x12, 0x16, 0x0a, 0x06, 0x65,
	0x78, 0x70, 0x69, 0x72, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x65, 0x78, 0x70,
	0x69, 0x72, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x5f, 0x74, 0x6f,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x54, 0x6f,
	0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x6e, 0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
	0x69, 0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72,
	0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x69, 0x63, 0x6f, 0x6e, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x07, 0x52, 0x04, 0x69, 0x63, 0x6f, 0x6e, 0x22, 0x89, 0x01, 0x0a, 0x16, 0x4d,
	0x71, 0x74, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x4d, 0x65,
	0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x70, 0x69, 0x63, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x6f, 0x70, 0x69, 0x63, 0x12, 0x14, 0x0a, 0x04, 0x64,
	0x61, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x04, 0x64, 0x61, 0x74,
	0x61, 0x12, 0x14, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x48,
	0x00, 0x52, 0x04, 0x74, 0x65, 0x78, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x74, 0x61, 0x69,
	0x6e, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x74, 0x61, 0x69,
	0x6e, 0x65, 0x64, 0x42, 0x11, 0x0a, 0x0f, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x76,
	0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x22, 0x90, 0x05, 0x0a, 0x0a, 0x4d, 0x65, 0x73, 0x68, 0x50,
	0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x07, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x0e, 0x0a, 0x02, 0x74, 0x6f, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x07, 0x52, 0x02, 0x74, 0x6f, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x68, 0x61,
	0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x63, 0x68, 0x61, 0x6e,
	0x6e, 0x65, 0x6c, 0x12, 0x2c, 0x0a, 0x07, 0x64, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69,
	0x63, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x48, 0x00, 0x52, 0x07, 0x64, 0x65, 0x63, 0x6f, 0x64, 0x65,
	0x64, 0x12, 0x1e, 0x0a, 0x09, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x09, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65,
	0x64, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x07, 0x52, 0x02, 0x69,
	0x64, 0x12, 0x17, 0x0a, 0x07, 0x72, 0x78, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x07, 0x20, 0x01,
	0x28, 0x07, 0x52, 0x06, 0x72, 0x78, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x15, 0x0a, 0x06, 0x72, 0x78,
	0x5f, 0x73, 0x6e, 0x72, 0x18, 0x08, 0x20, 0x01, 0x28, 0x02, 0x52, 0x05, 0x72, 0x78, 0x53, 0x6e,
	0x72, 0x12, 0x1b, 0x0a, 0x09, 0x68, 0x6f, 0x70, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x09,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x68, 0x6f, 0x70, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x19,
	0x0a, 0x08, 0x77, 0x61, 0x6e, 0x74, 0x5f, 0x61, 0x63, 0x6b, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x07, 0x77, 0x61, 0x6e, 0x74, 0x41, 0x63, 0x6b, 0x12, 0x3b, 0x0a, 0x08, 0x70, 0x72, 0x69,
	0x6f, 0x72, 0x69, 0x74, 0x79, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x6d, 0x65,
	0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63,
	0x6b, 0x65, 0x74, 0x2e, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x52, 0x08, 0x70, 0x72,
	0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x12, 0x17, 0x0a, 0x07, 0x72, 0x78, 0x5f, 0x72, 0x73, 0x73,
	0x69, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x72, 0x78, 0x52, 0x73, 0x73, 0x69, 0x12,
	0x3c, 0x0a, 0x07, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x1e, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4d, 0x65,
	0x73, 0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x2e, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x65, 0x64,
	0x42, 0x02, 0x18, 0x01, 0x52, 0x07, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x12, 0x19, 0x0a,
	0x08, 0x76, 0x69, 0x61, 0x5f, 0x6d, 0x71, 0x74, 0x74, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x07, 0x76, 0x69, 0x61, 0x4d, 0x71, 0x74, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x68, 0x6f, 0x70, 0x5f,
	0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x68, 0x6f, 0x70,
	0x53, 0x74, 0x61, 0x72, 0x74, 0x22, 0x5b, 0x0a, 0x08, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74,
	0x79, 0x12, 0x09, 0x0a, 0x05, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03,
	0x4d, 0x49, 0x4e, 0x10, 0x01, 0x12, 0x0e, 0x0a, 0x0a, 0x42, 0x41, 0x43, 0x4b, 0x47, 0x52, 0x4f,
	0x55, 0x4e, 0x44, 0x10, 0x0a, 0x12, 0x0b, 0x0a, 0x07, 0x44, 0x45, 0x46, 0x41, 0x55, 0x4c, 0x54,
	0x10, 0x40, 0x12, 0x0c, 0x0a, 0x08, 0x52, 0x45, 0x4c, 0x49, 0x41, 0x42, 0x4c, 0x45, 0x10, 0x46,
	0x12, 0x07, 0x0a, 0x03, 0x41, 0x43, 0x4b, 0x10, 0x78, 0x12, 0x07, 0x0a, 0x03, 0x4d, 0x41, 0x58,
	0x10, 0x7f, 0x22, 0x42, 0x0a, 0x07, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x12, 0x0c, 0x0a,
	0x08, 0x4e, 0x4f, 0x5f, 0x44, 0x45, 0x4c, 0x41, 0x59, 0x10, 0x00, 0x12, 0x15, 0x0a, 0x11, 0x44,
	0x45, 0x4c, 0x41, 0x59, 0x45, 0x44, 0x5f, 0x42, 0x52, 0x4f, 0x41, 0x44, 0x43, 0x41, 0x53, 0x54,
	0x10, 0x01, 0x12, 0x12, 0x0a, 0x0e, 0x44, 0x45, 0x4c, 0x41, 0x59, 0x45, 0x44, 0x5f, 0x44, 0x49,
	0x52, 0x45, 0x43, 0x54, 0x10, 0x02, 0x42, 0x11, 0x0a, 0x0f, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61,
	0x64, 0x5f, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x22, 0xb9, 0x02, 0x0a, 0x08, 0x4e, 0x6f,
	0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x10, 0x0a, 0x03, 0x6e, 0x75, 0x6d, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x03, 0x6e, 0x75, 0x6d, 0x12, 0x24, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73,
	0x74, 0x69, 0x63, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x30,
	0x0a, 0x08, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x50, 0x6f,
	0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e,
	0x12, 0x10, 0x0a, 0x03, 0x73, 0x6e, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x02, 0x52, 0x03, 0x73,
	0x6e, 0x72, 0x12, 0x1d, 0x0a, 0x0a, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x68, 0x65, 0x61, 0x72, 0x64,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x07, 0x52, 0x09, 0x6c, 0x61, 0x73, 0x74, 0x48, 0x65, 0x61, 0x72,
	0x64, 0x12, 0x40, 0x0a, 0x0e, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6d, 0x65, 0x74, 0x72,
	0x69, 0x63, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6d, 0x65, 0x73, 0x68,
	0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x4d, 0x65, 0x74,
	0x72, 0x69, 0x63, 0x73, 0x52, 0x0d, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x4d, 0x65, 0x74, 0x72,
	0x69, 0x63, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x07,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x19, 0x0a,
	0x08, 0x76, 0x69, 0x61, 0x5f, 0x6d, 0x71, 0x74, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x07, 0x76, 0x69, 0x61, 0x4d, 0x71, 0x74, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x68, 0x6f, 0x70, 0x73,
	0x5f, 0x61, 0x77, 0x61, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x68, 0x6f, 0x70,
	0x73, 0x41, 0x77, 0x61, 0x79, 0x22, 0x77, 0x0a, 0x0a, 0x4d, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x49,
	0x6e, 0x66, 0x6f, 0x12, 0x1e, 0x0a, 0x0b, 0x6d, 0x79, 0x5f, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x6e,
	0x75, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x6d, 0x79, 0x4e, 0x6f, 0x64, 0x65,
	0x4e, 0x75, 0x6d, 0x12, 0x21, 0x0a, 0x0c, 0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74, 0x5f, 0x63, 0x6f,
	0x75, 0x6e, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x72, 0x65, 0x62, 0x6f, 0x6f,
	0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x26, 0x0a, 0x0f, 0x6d, 0x69, 0x6e, 0x5f, 0x61, 0x70,
	0x70, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x0d, 0x6d, 0x69, 0x6e, 0x41, 0x70, 0x70, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0xde,
	0x01, 0x0a, 0x09, 0x4c, 0x6f, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x18, 0x0a, 0x07,
	0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d,
	0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x07, 0x52, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x6f,
	0x75, 0x72, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x6f, 0x75, 0x72,
	0x63, 0x65, 0x12, 0x31, 0x0a, 0x05, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x1b, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4c,
	0x6f, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x2e, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52, 0x05,
	0x6c, 0x65, 0x76, 0x65, 0x6c, 0x22, 0x58, 0x0a, 0x05, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x09,
	0x0a, 0x05, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x43, 0x52, 0x49,
	0x54, 0x49, 0x43, 0x41, 0x4c, 0x10, 0x32, 0x12, 0x09, 0x0a, 0x05, 0x45, 0x52, 0x52, 0x4f, 0x52,
	0x10, 0x28, 0x12, 0x0b, 0x0a, 0x07, 0x57, 0x41, 0x52, 0x4e, 0x49, 0x4e, 0x47, 0x10, 0x1e, 0x12,
	0x08, 0x0a, 0x04, 0x49, 0x4e, 0x46, 0x4f, 0x10, 0x14, 0x12, 0x09, 0x0a, 0x05, 0x44, 0x45, 0x42,
	0x55, 0x47, 0x10, 0x0a, 0x12, 0x09, 0x0a, 0x05, 0x54, 0x52, 0x41, 0x43, 0x45, 0x10, 0x05, 0x22,
	0x71, 0x0a, 0x0b, 0x51, 0x75, 0x65, 0x75, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x10,
	0x0a, 0x03, 0x72, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x72, 0x65, 0x73,
	0x12, 0x12, 0x0a, 0x04, 0x66, 0x72, 0x65, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04,
	0x66, 0x72, 0x65, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6d, 0x61, 0x78, 0x6c, 0x65, 0x6e, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x6d, 0x61, 0x78, 0x6c, 0x65, 0x6e, 0x12, 0x24, 0x0a, 0x0e,
	0x6d, 0x65, 0x73, 0x68, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x6d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74,
	0x49, 0x64, 0x22, 0xfc, 0x05, 0x0a, 0x09, 0x46, 0x72, 0x6f, 0x6d, 0x52, 0x61, 0x64, 0x69, 0x6f,
	0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64,
	0x12, 0x30, 0x0a, 0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x16, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4d, 0x65,
	0x73, 0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x48, 0x00, 0x52, 0x06, 0x70, 0x61, 0x63, 0x6b,
	0x65, 0x74, 0x12, 0x31, 0x0a, 0x07, 0x6d, 0x79, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63,
	0x2e, 0x4d, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x48, 0x00, 0x52, 0x06, 0x6d,
	0x79, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x33, 0x0a, 0x09, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x6e,
	0x66, 0x6f, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74,
	0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x48, 0x00,
	0x52, 0x08, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x2c, 0x0a, 0x06, 0x63, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73,
	0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x48, 0x00,
	0x52, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x36, 0x0a, 0x0a, 0x6c, 0x6f, 0x67, 0x5f,
	0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d,
	0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4c, 0x6f, 0x67, 0x52, 0x65, 0x63,
	0x6f, 0x72, 0x64, 0x48, 0x00, 0x52, 0x09, 0x6c, 0x6f, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64,
	0x12, 0x2e, 0x0a, 0x12, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6c,
	0x65, 0x74, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x10,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x49, 0x64,
	0x12, 0x1c, 0x0a, 0x08, 0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74, 0x65, 0x64, 0x18, 0x08, 0x20, 0x01,
	0x28, 0x08, 0x48, 0x00, 0x52, 0x08, 0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74, 0x65, 0x64, 0x12, 0x3e,
	0x0a, 0x0c, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x09,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69,
	0x63, 0x2e, 0x4d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x48, 0x00,
	0x52, 0x0c, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x2f,
	0x0a, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x13, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x43, 0x68, 0x61,
	0x6e, 0x6e, 0x65, 0x6c, 0x48, 0x00, 0x52, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x12,
	0x3b, 0x0a, 0x0b, 0x71, 0x75, 0x65, 0x75, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x0b,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69,
	0x63, 0x2e, 0x51, 0x75, 0x65, 0x75, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x48, 0x00, 0x52,
	0x0b, 0x71, 0x75, 0x65, 0x75, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x38, 0x0a, 0x0c,
	0x78, 0x6d, 0x6f, 0x64, 0x65, 0x6d, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x0c, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e,
	0x58, 0x4d, 0x6f, 0x64, 0x65, 0x6d, 0x48, 0x00, 0x52, 0x0c, 0x78, 0x6d, 0x6f, 0x64, 0x65, 0x6d,
	0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x38, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61,
	0x74, 0x61, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74,
	0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0x48, 0x00, 0x52, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61,
	0x12, 0x5c, 0x0a, 0x16, 0x6d, 0x71, 0x74, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x72,
	0x6f, 0x78, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x22, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4d, 0x71,
	0x74, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x4d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x48, 0x00, 0x52, 0x16, 0x6d, 0x71, 0x74, 0x74, 0x43, 0x6c, 0x69, 0x65,
	0x6e, 0x74, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x11,
	0x0a, 0x0f, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e,
	0x74, 0x22, 0xb0, 0x02, 0x0a, 0x07, 0x54, 0x6f, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x12, 0x30, 0x0a,
	0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,
	0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4d, 0x65, 0x73, 0x68, 0x50,
	0x61, 0x63, 0x6b, 0x65, 0x74, 0x48, 0x00, 0x52, 0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12,
	0x26, 0x0a, 0x0e, 0x77, 0x61, 0x6e, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x69,
	0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x0c, 0x77, 0x61, 0x6e, 0x74, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x49, 0x64, 0x12, 0x20, 0x0a, 0x0a, 0x64, 0x69, 0x73, 0x63, 0x6f,
	0x6e, 0x6e, 0x65, 0x63, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x0a, 0x64,
	0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x12, 0x38, 0x0a, 0x0c, 0x78, 0x6d, 0x6f,
	0x64, 0x65, 0x6d, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x12, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x58, 0x4d, 0x6f,
	0x64, 0x65, 0x6d, 0x48, 0x00, 0x52, 0x0c, 0x78, 0x6d, 0x6f, 0x64, 0x65, 0x6d, 0x50, 0x61, 0x63,
	0x6b, 0x65, 0x74, 0x12, 0x5c, 0x0a, 0x16, 0x6d, 0x71, 0x74, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e,
	0x74, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x06, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63,
	0x2e, 0x4d, 0x71, 0x74, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x78, 0x79,
	0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x48, 0x00, 0x52, 0x16, 0x6d, 0x71, 0x74, 0x74, 0x43,
	0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67,
	0x65, 0x42, 0x11, 0x0a, 0x0f, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x76, 0x61, 0x72,
	0x69, 0x61, 0x6e, 0x74, 0x22, 0x4f, 0x0a, 0x0a, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73,
	0x65, 0x64, 0x12, 0x2d, 0x0a, 0x07, 0x70, 0x6f, 0x72, 0x74, 0x6e, 0x75, 0x6d, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63,
	0x2e, 0x50, 0x6f, 0x72, 0x74, 0x4e, 0x75, 0x6d, 0x52, 0x07, 0x70, 0x6f, 0x72, 0x74, 0x6e, 0x75,
	0x6d, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x04, 0x64, 0x61, 0x74, 0x61, 0x22, 0xc3, 0x01, 0x0a, 0x0c, 0x4e, 0x65, 0x69, 0x67, 0x68, 0x62,
	0x6f, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x64, 0x12,
	0x25, 0x0a, 0x0f, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x73, 0x65, 0x6e, 0x74, 0x5f, 0x62, 0x79, 0x5f,
	0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x6c, 0x61, 0x73, 0x74, 0x53, 0x65,
	0x6e, 0x74, 0x42, 0x79, 0x49, 0x64, 0x12, 0x3f, 0x0a, 0x1c, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x62,
	0x72, 0x6f, 0x61, 0x64, 0x63, 0x61, 0x73, 0x74, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61,
	0x6c, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x19, 0x6e, 0x6f,
	0x64, 0x65, 0x42, 0x72, 0x6f, 0x61, 0x64, 0x63, 0x61, 0x73, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72,
	0x76, 0x61, 0x6c, 0x53, 0x65, 0x63, 0x73, 0x12, 0x32, 0x0a, 0x09, 0x6e, 0x65, 0x69, 0x67, 0x68,
	0x62, 0x6f, 0x72, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73,
	0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4e, 0x65, 0x69, 0x67, 0x68, 0x62, 0x6f, 0x72,
	0x52, 0x09, 0x6e, 0x65, 0x69, 0x67, 0x68, 0x62, 0x6f, 0x72, 0x73, 0x22, 0x98, 0x01, 0x0a, 0x08,
	0x4e, 0x65, 0x69, 0x67, 0x68, 0x62, 0x6f, 0x72, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x6f, 0x64, 0x65,
	0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x6e, 0x6f, 0x64, 0x65, 0x49,
	0x64, 0x12, 0x10, 0x0a, 0x03, 0x73, 0x6e, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x03,
	0x73, 0x6e, 0x72, 0x12, 0x20, 0x0a, 0x0c, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x72, 0x78, 0x5f, 0x74,
	0x69, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x07, 0x52, 0x0a, 0x6c, 0x61, 0x73, 0x74, 0x52,
	0x78, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x3f, 0x0a, 0x1c, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x62, 0x72,
	0x6f, 0x61, 0x64, 0x63, 0x61, 0x73, 0x74, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c,
	0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x19, 0x6e, 0x6f, 0x64,
	0x65, 0x42, 0x72, 0x6f, 0x61, 0x64, 0x63, 0x61, 0x73, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76,
	0x61, 0x6c, 0x53, 0x65, 0x63, 0x73, 0x22, 0xb4, 0x03, 0x0a, 0x0e, 0x44, 0x65, 0x76, 0x69, 0x63,
	0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x29, 0x0a, 0x10, 0x66, 0x69, 0x72,
	0x6d, 0x77, 0x61, 0x72, 0x65, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0f, 0x66, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x56, 0x65, 0x72,
	0x73, 0x69, 0x6f, 0x6e, 0x12, 0x30, 0x0a, 0x14, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x73,
	0x74, 0x61, 0x74, 0x65, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x12, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x53, 0x74, 0x61, 0x74, 0x65, 0x56,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x20, 0x0a, 0x0b, 0x63, 0x61, 0x6e, 0x53, 0x68, 0x75,
	0x74, 0x64, 0x6f, 0x77, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x63, 0x61, 0x6e,
	0x53, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x12, 0x18, 0x0a, 0x07, 0x68, 0x61, 0x73, 0x57,
	0x69, 0x66, 0x69, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x68, 0x61, 0x73, 0x57, 0x69,
	0x66, 0x69, 0x12, 0x22, 0x0a, 0x0c, 0x68, 0x61, 0x73, 0x42, 0x6c, 0x75, 0x65, 0x74, 0x6f, 0x6f,
	0x74, 0x68, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x68, 0x61, 0x73, 0x42, 0x6c, 0x75,
	0x65, 0x74, 0x6f, 0x6f, 0x74, 0x68, 0x12, 0x20, 0x0a, 0x0b, 0x68, 0x61, 0x73, 0x45, 0x74, 0x68,
	0x65, 0x72, 0x6e, 0x65, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x68, 0x61, 0x73,
	0x45, 0x74, 0x68, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x12, 0x38, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65,
	0x18, 0x07, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x24, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73,
	0x74, 0x69, 0x63, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63,
	0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x04, 0x72, 0x6f,
	0x6c, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x66,
	0x6c, 0x61, 0x67, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0d, 0x70, 0x6f, 0x73, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x12, 0x34, 0x0a, 0x08, 0x68, 0x77, 0x5f,
	0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x19, 0x2e, 0x6d, 0x65,
	0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72,
	0x65, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x52, 0x07, 0x68, 0x77, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x12,
	0x2c, 0x0a, 0x11, 0x68, 0x61, 0x73, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x48, 0x61, 0x72, 0x64,
	0x77, 0x61, 0x72, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x11, 0x68, 0x61, 0x73, 0x52,
	0x65, 0x6d, 0x6f, 0x74, 0x65, 0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x2a, 0xd4, 0x07,
	0x0a, 0x0d, 0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x12,
	0x09, 0x0a, 0x05, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x54, 0x4c,
	0x4f, 0x52, 0x41, 0x5f, 0x56, 0x32, 0x10, 0x01, 0x12, 0x0c, 0x0a, 0x08, 0x54, 0x4c, 0x4f, 0x52,
	0x41, 0x5f, 0x56, 0x31, 0x10, 0x02, 0x12, 0x12, 0x0a, 0x0e, 0x54, 0x4c, 0x4f, 0x52, 0x41, 0x5f,
	0x56, 0x32, 0x5f, 0x31, 0x5f, 0x31, 0x50, 0x36, 0x10, 0x03, 0x12, 0x09, 0x0a, 0x05, 0x54, 0x42,
	0x45, 0x41, 0x4d, 0x10, 0x04, 0x12, 0x0f, 0x0a, 0x0b, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f,
	0x56, 0x32, 0x5f, 0x30, 0x10, 0x05, 0x12, 0x0e, 0x0a, 0x0a, 0x54, 0x42, 0x45, 0x41, 0x4d, 0x5f,
	0x56, 0x30, 0x50, 0x37, 0x10, 0x06, 0x12, 0x0a, 0x0a, 0x06, 0x54, 0x5f, 0x45, 0x43, 0x48, 0x4f,
	0x10, 0x07, 0x12, 0x10, 0x0a, 0x0c, 0x54, 0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x56, 0x31, 0x5f, 0x31,
	0x50, 0x33, 0x10, 0x08, 0x12, 0x0b, 0x0a, 0x07, 0x52, 0x41, 0x4b, 0x34, 0x36, 0x33, 0x31, 0x10,
	0x09, 0x12, 0x0f, 0x0a, 0x0b, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x56, 0x32, 0x5f, 0x31,
	0x10, 0x0a, 0x12, 0x0d, 0x0a, 0x09, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x56, 0x31, 0x10,
	0x0b, 0x12, 0x18, 0x0a, 0x14, 0x4c, 0x49, 0x4c, 0x59, 0x47, 0x4f, 0x5f, 0x54, 0x42, 0x45, 0x41,
	0x4d, 0x5f, 0x53, 0x33, 0x5f, 0x43, 0x4f, 0x52, 0x45, 0x10, 0x0c, 0x12, 0x0c, 0x0a, 0x08, 0x52,
	0x41, 0x4b, 0x31, 0x31, 0x32, 0x30, 0x30, 0x10, 0x0d, 0x12, 0x0b, 0x0a, 0x07, 0x4e, 0x41, 0x4e,
	0x4f, 0x5f, 0x47, 0x31, 0x10, 0x0e, 0x12, 0x12, 0x0a, 0x0e, 0x54, 0x4c, 0x4f, 0x52, 0x41, 0x5f,
	0x56, 0x32, 0x5f, 0x31, 0x5f, 0x31, 0x50, 0x38, 0x10, 0x0f, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x4c,
	0x4f, 0x52, 0x41, 0x5f, 0x54, 0x33, 0x5f, 0x53, 0x33, 0x10, 0x10, 0x12, 0x14, 0x0a, 0x10, 0x4e,
	0x41, 0x4e, 0x4f, 0x5f, 0x47, 0x31, 0x5f, 0x45, 0x58, 0x50, 0x4c, 0x4f, 0x52, 0x45, 0x52, 0x10,
	0x11, 0x12, 0x11, 0x0a, 0x0d, 0x4e, 0x41, 0x4e, 0x4f, 0x5f, 0x47, 0x32, 0x5f, 0x55, 0x4c, 0x54,
	0x52, 0x41, 0x10, 0x12, 0x12, 0x0d, 0x0a, 0x09, 0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x54, 0x59, 0x50,
	0x45, 0x10, 0x13, 0x12, 0x0e, 0x0a, 0x0a, 0x53, 0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x47,
	0x31, 0x10, 0x19, 0x12, 0x0c, 0x0a, 0x08, 0x52, 0x41, 0x4b, 0x31, 0x31, 0x33, 0x31, 0x30, 0x10,
	0x1a, 0x12, 0x14, 0x0a, 0x10, 0x53, 0x45, 0x4e, 0x53, 0x45, 0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x52,
	0x50, 0x32, 0x30, 0x34, 0x30, 0x10, 0x1b, 0x12, 0x10, 0x0a, 0x0c, 0x53, 0x45, 0x4e, 0x53, 0x45,
	0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x53, 0x33, 0x10, 0x1c, 0x12, 0x0d, 0x0a, 0x09, 0x43, 0x41, 0x4e,
	0x41, 0x52, 0x59, 0x4f, 0x4e, 0x45, 0x10, 0x1d, 0x12, 0x0f, 0x0a, 0x0b, 0x52, 0x50, 0x32, 0x30,
	0x34, 0x30, 0x5f, 0x4c, 0x4f, 0x52, 0x41, 0x10, 0x1e, 0x12, 0x0e, 0x0a, 0x0a, 0x53, 0x54, 0x41,
	0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x47, 0x32, 0x10, 0x1f, 0x12, 0x11, 0x0a, 0x0d, 0x4c, 0x4f, 0x52,
	0x41, 0x5f, 0x52, 0x45, 0x4c, 0x41, 0x59, 0x5f, 0x56, 0x31, 0x10, 0x20, 0x12, 0x0e, 0x0a, 0x0a,
	0x4e, 0x52, 0x46, 0x35, 0x32, 0x38, 0x34, 0x30, 0x44, 0x4b, 0x10, 0x21, 0x12, 0x07, 0x0a, 0x03,
	0x50, 0x50, 0x52, 0x10, 0x22, 0x12, 0x0f, 0x0a, 0x0b, 0x47, 0x45, 0x4e, 0x49, 0x45, 0x42, 0x4c,
	0x4f, 0x43, 0x4b, 0x53, 0x10, 0x23, 0x12, 0x11, 0x0a, 0x0d, 0x4e, 0x52, 0x46, 0x35, 0x32, 0x5f,
	0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x24, 0x12, 0x0d, 0x0a, 0x09, 0x50, 0x4f, 0x52,
	0x54, 0x44, 0x55, 0x49, 0x4e, 0x4f, 0x10, 0x25, 0x12, 0x0f, 0x0a, 0x0b, 0x41, 0x4e, 0x44, 0x52,
	0x4f, 0x49, 0x44, 0x5f, 0x53, 0x49, 0x4d, 0x10, 0x26, 0x12, 0x0a, 0x0a, 0x06, 0x44, 0x49, 0x59,
	0x5f, 0x56, 0x31, 0x10, 0x27, 0x12, 0x15, 0x0a, 0x11, 0x4e, 0x52, 0x46, 0x35, 0x32, 0x38, 0x34,
	0x30, 0x5f, 0x50, 0x43, 0x41, 0x31, 0x30, 0x30, 0x35, 0x39, 0x10, 0x28, 0x12, 0x0a, 0x0a, 0x06,
	0x44, 0x52, 0x5f, 0x44, 0x45, 0x56, 0x10, 0x29, 0x12, 0x0b, 0x0a, 0x07, 0x4d, 0x35, 0x53, 0x54,
	0x41, 0x43, 0x4b, 0x10, 0x2a, 0x12, 0x0d, 0x0a, 0x09, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f,
	0x56, 0x33, 0x10, 0x2b, 0x12, 0x11, 0x0a, 0x0d, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x57,
	0x53, 0x4c, 0x5f, 0x56, 0x33, 0x10, 0x2c, 0x12, 0x13, 0x0a, 0x0f, 0x42, 0x45, 0x54, 0x41, 0x46,
	0x50, 0x56, 0x5f, 0x32, 0x34, 0x30, 0x30, 0x5f, 0x54, 0x58, 0x10, 0x2d, 0x12, 0x17, 0x0a, 0x13,
	0x42, 0x45, 0x54, 0x41, 0x46, 0x50, 0x56, 0x5f, 0x39, 0x30, 0x30, 0x5f, 0x4e, 0x41, 0x4e, 0x4f,
	0x5f, 0x54, 0x58, 0x10, 0x2e, 0x12, 0x0c, 0x0a, 0x08, 0x52, 0x50, 0x49, 0x5f, 0x50, 0x49, 0x43,
	0x4f, 0x10, 0x2f, 0x12, 0x1b, 0x0a, 0x17, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x57, 0x49,
	0x52, 0x45, 0x4c, 0x45, 0x53, 0x53, 0x5f, 0x54, 0x52, 0x41, 0x43, 0x4b, 0x45, 0x52, 0x10, 0x30,
	0x12, 0x19, 0x0a, 0x15, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x57, 0x49, 0x52, 0x45, 0x4c,
	0x45, 0x53, 0x53, 0x5f, 0x50, 0x41, 0x50, 0x45, 0x52, 0x10, 0x31, 0x12, 0x0a, 0x0a, 0x06, 0x54,
	0x5f, 0x44, 0x45, 0x43, 0x4b, 0x10, 0x32, 0x12, 0x0e, 0x0a, 0x0a, 0x54, 0x5f, 0x57, 0x41, 0x54,
	0x43, 0x48, 0x5f, 0x53, 0x33, 0x10, 0x33, 0x12, 0x11, 0x0a, 0x0d, 0x50, 0x49, 0x43, 0x4f, 0x4d,
	0x50, 0x55, 0x54, 0x45, 0x52, 0x5f, 0x53, 0x33, 0x10, 0x34, 0x12, 0x0f, 0x0a, 0x0b, 0x48, 0x45,
	0x4c, 0x54, 0x45, 0x43, 0x5f, 0x48, 0x54, 0x36, 0x32, 0x10, 0x35, 0x12, 0x12, 0x0a, 0x0e, 0x45,
	0x42, 0x59, 0x54, 0x45, 0x5f, 0x45, 0x53, 0x50, 0x33, 0x32, 0x5f, 0x53, 0x33, 0x10, 0x36, 0x12,
	0x11, 0x0a, 0x0d, 0x45, 0x53, 0x50, 0x33, 0x32, 0x5f, 0x53, 0x33, 0x5f, 0x50, 0x49, 0x43, 0x4f,
	0x10, 0x37, 0x12, 0x0d, 0x0a, 0x09, 0x43, 0x48, 0x41, 0x54, 0x54, 0x45, 0x52, 0x5f, 0x32, 0x10,
	0x38, 0x12, 0x1e, 0x0a, 0x1a, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x57, 0x49, 0x52, 0x45,
	0x4c, 0x45, 0x53, 0x53, 0x5f, 0x50, 0x41, 0x50, 0x45, 0x52, 0x5f, 0x56, 0x31, 0x5f, 0x30, 0x10,
	0x39, 0x12, 0x20, 0x0a, 0x1c, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x57, 0x49, 0x52, 0x45,
	0x4c, 0x45, 0x53, 0x53, 0x5f, 0x54, 0x52, 0x41, 0x43, 0x4b, 0x45, 0x52, 0x5f, 0x56, 0x31, 0x5f,
	0x30, 0x10, 0x3a, 0x12, 0x0f, 0x0a, 0x0a, 0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x5f, 0x48,
	0x57, 0x10, 0xff, 0x01, 0x2a, 0x2c, 0x0a, 0x09, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74,
	0x73, 0x12, 0x08, 0x0a, 0x04, 0x5a, 0x45, 0x52, 0x4f, 0x10, 0x00, 0x12, 0x15, 0x0a, 0x10, 0x44,
	0x41, 0x54, 0x41, 0x5f, 0x50, 0x41, 0x59, 0x4c, 0x4f, 0x41, 0x44, 0x5f, 0x4c, 0x45, 0x4e, 0x10,
	0xed, 0x01, 0x2a, 0xee, 0x01, 0x0a, 0x11, 0x43, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x45,
	0x72, 0x72, 0x6f, 0x72, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x4f, 0x4e, 0x45,
	0x10, 0x00, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x58, 0x5f, 0x57, 0x41, 0x54, 0x43, 0x48, 0x44, 0x4f,
	0x47, 0x10, 0x01, 0x12, 0x14, 0x0a, 0x10, 0x53, 0x4c, 0x45, 0x45, 0x50, 0x5f, 0x45, 0x4e, 0x54,
	0x45, 0x52, 0x5f, 0x57, 0x41, 0x49, 0x54, 0x10, 0x02, 0x12, 0x0c, 0x0a, 0x08, 0x4e, 0x4f, 0x5f,
	0x52, 0x41, 0x44, 0x49, 0x4f, 0x10, 0x03, 0x12, 0x0f, 0x0a, 0x0b, 0x55, 0x4e, 0x53, 0x50, 0x45,
	0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x04, 0x12, 0x15, 0x0a, 0x11, 0x55, 0x42, 0x4c, 0x4f,
	0x58, 0x5f, 0x55, 0x4e, 0x49, 0x54, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x05, 0x12,
	0x0d, 0x0a, 0x09, 0x4e, 0x4f, 0x5f, 0x41, 0x58, 0x50, 0x31, 0x39, 0x32, 0x10, 0x06, 0x12, 0x19,
	0x0a, 0x15, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x5f, 0x52, 0x41, 0x44, 0x49, 0x4f, 0x5f,
	0x53, 0x45, 0x54, 0x54, 0x49, 0x4e, 0x47, 0x10, 0x07, 0x12, 0x13, 0x0a, 0x0f, 0x54, 0x52, 0x41,
	0x4e, 0x53, 0x4d, 0x49, 0x54, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x08, 0x12, 0x0c,
	0x0a, 0x08, 0x42, 0x52, 0x4f, 0x57, 0x4e, 0x4f, 0x55, 0x54, 0x10, 0x09, 0x12, 0x12, 0x0a, 0x0e,
	0x53, 0x58, 0x31, 0x32, 0x36, 0x32, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x55, 0x52, 0x45, 0x10, 0x0a,
	0x12, 0x11, 0x0a, 0x0d, 0x52, 0x41, 0x44, 0x49, 0x4f, 0x5f, 0x53, 0x50, 0x49, 0x5f, 0x42, 0x55,
	0x47, 0x10, 0x0b, 0x42, 0x5f, 0x0a, 0x13, 0x63, 0x6f, 0x6d, 0x2e, 0x67, 0x65, 0x65, 0x6b, 0x73,
	0x76, 0x69, 0x6c, 0x6c, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x42, 0x0a, 0x4d, 0x65, 0x73, 0x68,
	0x50, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x5a, 0x22, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2f, 0x67, 0x6f,
	0x2f, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0xaa, 0x02, 0x14, 0x4d, 0x65, 0x73,
	0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
	0x73, 0xba, 0x02, 0x00, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_meshtastic_mesh_proto_rawDescOnce sync.Once
	file_meshtastic_mesh_proto_rawDescData = file_meshtastic_mesh_proto_rawDesc
)

func file_meshtastic_mesh_proto_rawDescGZIP() []byte {
	file_meshtastic_mesh_proto_rawDescOnce.Do(func() {
		file_meshtastic_mesh_proto_rawDescData = protoimpl.X.CompressGZIP(file_meshtastic_mesh_proto_rawDescData)
	})
	return file_meshtastic_mesh_proto_rawDescData
}

var file_meshtastic_mesh_proto_enumTypes = make([]protoimpl.EnumInfo, 9)
var file_meshtastic_mesh_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_meshtastic_mesh_proto_goTypes = []interface{}{
	(HardwareModel)(0),             // 0: meshtastic.HardwareModel
	(Constants)(0),                 // 1: meshtastic.Constants
	(CriticalErrorCode)(0),         // 2: meshtastic.CriticalErrorCode
	(Position_LocSource)(0),        // 3: meshtastic.Position.LocSource
	(Position_AltSource)(0),        // 4: meshtastic.Position.AltSource
	(Routing_Error)(0),             // 5: meshtastic.Routing.Error
	(MeshPacket_Priority)(0),       // 6: meshtastic.MeshPacket.Priority
	(MeshPacket_Delayed)(0),        // 7: meshtastic.MeshPacket.Delayed
	(LogRecord_Level)(0),           // 8: meshtastic.LogRecord.Level
	(*Position)(nil),               // 9: meshtastic.Position
	(*User)(nil),                   // 10: meshtastic.User
	(*RouteDiscovery)(nil),         // 11: meshtastic.RouteDiscovery
	(*Routing)(nil),                // 12: meshtastic.Routing
	(*Data)(nil),                   // 13: meshtastic.Data
	(*Waypoint)(nil),               // 14: meshtastic.Waypoint
	(*MqttClientProxyMessage)(nil), // 15: meshtastic.MqttClientProxyMessage
	(*MeshPacket)(nil),             // 16: meshtastic.MeshPacket
	(*NodeInfo)(nil),               // 17: meshtastic.NodeInfo
	(*MyNodeInfo)(nil),             // 18: meshtastic.MyNodeInfo
	(*LogRecord)(nil),              // 19: meshtastic.LogRecord
	(*QueueStatus)(nil),            // 20: meshtastic.QueueStatus
	(*FromRadio)(nil),              // 21: meshtastic.FromRadio
	(*ToRadio)(nil),                // 22: meshtastic.ToRadio
	(*Compressed)(nil),             // 23: meshtastic.Compressed
	(*NeighborInfo)(nil),           // 24: meshtastic.NeighborInfo
	(*Neighbor)(nil),               // 25: meshtastic.Neighbor
	(*DeviceMetadata)(nil),         // 26: meshtastic.DeviceMetadata
	(Config_DeviceConfig_Role)(0),  // 27: meshtastic.Config.DeviceConfig.Role
	(PortNum)(0),                   // 28: meshtastic.PortNum
	(*DeviceMetrics)(nil),          // 29: meshtastic.DeviceMetrics
	(*Config)(nil),                 // 30: meshtastic.Config
	(*ModuleConfig)(nil),           // 31: meshtastic.ModuleConfig
	(*Channel)(nil),                // 32: meshtastic.Channel
	(*XModem)(nil),                 // 33: meshtastic.XModem
}
var file_meshtastic_mesh_proto_depIdxs = []int32{
	3,  // 0: meshtastic.Position.location_source:type_name -> meshtastic.Position.LocSource
	4,  // 1: meshtastic.Position.altitude_source:type_name -> meshtastic.Position.AltSource
	0,  // 2: meshtastic.User.hw_model:type_name -> meshtastic.HardwareModel
	27, // 3: meshtastic.User.role:type_name -> meshtastic.Config.DeviceConfig.Role
	11, // 4: meshtastic.Routing.route_request:type_name -> meshtastic.RouteDiscovery
	11, // 5: meshtastic.Routing.route_reply:type_name -> meshtastic.RouteDiscovery
	5,  // 6: meshtastic.Routing.error_reason:type_name -> meshtastic.Routing.Error
	28, // 7: meshtastic.Data.portnum:type_name -> meshtastic.PortNum
	13, // 8: meshtastic.MeshPacket.decoded:type_name -> meshtastic.Data
	6,  // 9: meshtastic.MeshPacket.priority:type_name -> meshtastic.MeshPacket.Priority
	7,  // 10: meshtastic.MeshPacket.delayed:type_name -> meshtastic.MeshPacket.Delayed
	10, // 11: meshtastic.NodeInfo.user:type_name -> meshtastic.User
	9,  // 12: meshtastic.NodeInfo.position:type_name -> meshtastic.Position
	29, // 13: meshtastic.NodeInfo.device_metrics:type_name -> meshtastic.DeviceMetrics
	8,  // 14: meshtastic.LogRecord.level:type_name -> meshtastic.LogRecord.Level
	16, // 15: meshtastic.FromRadio.packet:type_name -> meshtastic.MeshPacket
	18, // 16: meshtastic.FromRadio.my_info:type_name -> meshtastic.MyNodeInfo
	17, // 17: meshtastic.FromRadio.node_info:type_name -> meshtastic.NodeInfo
	30, // 18: meshtastic.FromRadio.config:type_name -> meshtastic.Config
	19, // 19: meshtastic.FromRadio.log_record:type_name -> meshtastic.LogRecord
	31, // 20: meshtastic.FromRadio.moduleConfig:type_name -> meshtastic.ModuleConfig
	32, // 21: meshtastic.FromRadio.channel:type_name -> meshtastic.Channel
	20, // 22: meshtastic.FromRadio.queueStatus:type_name -> meshtastic.QueueStatus
	33, // 23: meshtastic.FromRadio.xmodemPacket:type_name -> meshtastic.XModem
	26, // 24: meshtastic.FromRadio.metadata:type_name -> meshtastic.DeviceMetadata
	15, // 25: meshtastic.FromRadio.mqttClientProxyMessage:type_name -> meshtastic.MqttClientProxyMessage
	16, // 26: meshtastic.ToRadio.packet:type_name -> meshtastic.MeshPacket
	33, // 27: meshtastic.ToRadio.xmodemPacket:type_name -> meshtastic.XModem
	15, // 28: meshtastic.ToRadio.mqttClientProxyMessage:type_name -> meshtastic.MqttClientProxyMessage
	28, // 29: meshtastic.Compressed.portnum:type_name -> meshtastic.PortNum
	25, // 30: meshtastic.NeighborInfo.neighbors:type_name -> meshtastic.Neighbor
	27, // 31: meshtastic.DeviceMetadata.role:type_name -> meshtastic.Config.DeviceConfig.Role
	0,  // 32: meshtastic.DeviceMetadata.hw_model:type_name -> meshtastic.HardwareModel
	33, // [33:33] is the sub-list for method output_type
	33, // [33:33] is the sub-list for method input_type
	33, // [33:33] is the sub-list for extension type_name
	33, // [33:33] is the sub-list for extension extendee
	0,  // [0:33] is the sub-list for field type_name
}

func init() { file_meshtastic_mesh_proto_init() }
func file_meshtastic_mesh_proto_init() {
	if File_meshtastic_mesh_proto != nil {
		return
	}
	file_meshtastic_channel_proto_init()
	file_meshtastic_config_proto_init()
	file_meshtastic_module_config_proto_init()
	file_meshtastic_portnums_proto_init()
	file_meshtastic_telemetry_proto_init()
	file_meshtastic_xmodem_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_meshtastic_mesh_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Position); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*User); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteDiscovery); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Routing); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Data); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Waypoint); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MqttClientProxyMessage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MeshPacket); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NodeInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MyNodeInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LogRecord); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QueueStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FromRadio); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ToRadio); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Compressed); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NeighborInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Neighbor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DeviceMetadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_meshtastic_mesh_proto_msgTypes[3].OneofWrappers = []interface{}{
		(*Routing_RouteRequest)(nil),
		(*Routing_RouteReply)(nil),
		(*Routing_ErrorReason)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[6].OneofWrappers = []interface{}{
		(*MqttClientProxyMessage_Data)(nil),
		(*MqttClientProxyMessage_Text)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[7].OneofWrappers = []interface{}{
		(*MeshPacket_Decoded)(nil),
		(*MeshPacket_Encrypted)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[12].OneofWrappers = []interface{}{
		(*FromRadio_Packet)(nil),
		(*FromRadio_MyInfo)(nil),
		(*FromRadio_NodeInfo)(nil),
		(*FromRadio_Config)(nil),
		(*FromRadio_LogRecord)(nil),
		(*FromRadio_ConfigCompleteId)(nil),
		(*FromRadio_Rebooted)(nil),
		(*FromRadio_ModuleConfig)(nil),
		(*FromRadio_Channel)(nil),
		(*FromRadio_QueueStatus)(nil),
		(*FromRadio_XmodemPacket)(nil),
		(*FromRadio_Metadata)(nil),
		(*FromRadio_MqttClientProxyMessage)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[13].OneofWrappers = []interface{}{
		(*ToRadio_Packet)(nil),
		(*ToRadio_WantConfigId)(nil),
		(*ToRadio_Disconnect)(nil),
		(*ToRadio_XmodemPacket)(nil),
		(*ToRadio_MqttClientProxyMessage)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_meshtastic_mesh_proto_rawDesc,
			NumEnums:      9,
			NumMessages:   18,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_meshtastic_mesh_proto_goTypes,
		DependencyIndexes: file_meshtastic_mesh_proto_depIdxs,
		EnumInfos:         file_meshtastic_mesh_proto_enumTypes,
		MessageInfos:      file_meshtastic_mesh_proto_msgTypes,
	}.Build()
	File_meshtastic_mesh_proto = out.File
	file_meshtastic_mesh_proto_rawDesc = nil
	file_meshtastic_mesh_proto_goTypes = nil
	file_meshtastic_mesh_proto_depIdxs = nil
}
