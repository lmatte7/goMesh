// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.31.0
// 	protoc        v3.19.6
// source: meshtastic/mesh.proto

package gomeshproto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Note: these enum names must EXACTLY match the string used in the device
// bin/build-all.sh script.
// Because they will be used to find firmware filenames in the android app for OTA updates.
// To match the old style filenames, _ is converted to -, p is converted to .
type HardwareModel int32

const (
	// TODO: REPLACE
	HardwareModel_UNSET HardwareModel = 0
	// TODO: REPLACE
	HardwareModel_TLORA_V2 HardwareModel = 1
	// TODO: REPLACE
	HardwareModel_TLORA_V1 HardwareModel = 2
	// TODO: REPLACE
	HardwareModel_TLORA_V2_1_1P6 HardwareModel = 3
	// TODO: REPLACE
	HardwareModel_TBEAM HardwareModel = 4
	// The original heltec WiFi_Lora_32_V2, which had battery voltage sensing hooked to GPIO 13
	// (see HELTEC_V2 for the new version).
	HardwareModel_HELTEC_V2_0 HardwareModel = 5
	// TODO: REPLACE
	HardwareModel_TBEAM_V0P7 HardwareModel = 6
	// TODO: REPLACE
	HardwareModel_T_ECHO HardwareModel = 7
	// TODO: REPLACE
	HardwareModel_TLORA_V1_1P3 HardwareModel = 8
	// TODO: REPLACE
	HardwareModel_RAK4631 HardwareModel = 9
	// The new version of the heltec WiFi_Lora_32_V2 board that has battery sensing hooked to GPIO 37.
	// Sadly they did not update anything on the silkscreen to identify this board
	HardwareModel_HELTEC_V2_1 HardwareModel = 10
	// Ancient heltec WiFi_Lora_32 board
	HardwareModel_HELTEC_V1 HardwareModel = 11
	// New T-BEAM with ESP32-S3 CPU
	HardwareModel_LILYGO_TBEAM_S3_CORE HardwareModel = 12
	// RAK WisBlock ESP32 core: https://docs.rakwireless.com/Product-Categories/WisBlock/RAK11200/Overview/
	HardwareModel_RAK11200 HardwareModel = 13
	// B&Q Consulting Nano Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:nano
	HardwareModel_NANO_G1 HardwareModel = 14
	// TODO: REPLACE
	HardwareModel_TLORA_V2_1_1P8 HardwareModel = 15
	// TODO: REPLACE
	HardwareModel_TLORA_T3_S3 HardwareModel = 16
	// B&Q Consulting Nano G1 Explorer: https://wiki.uniteng.com/en/meshtastic/nano-g1-explorer
	HardwareModel_NANO_G1_EXPLORER HardwareModel = 17
	// B&Q Consulting Nano G2 Ultra: https://wiki.uniteng.com/en/meshtastic/nano-g2-ultra
	HardwareModel_NANO_G2_ULTRA HardwareModel = 18
	// LoRAType device: https://loratype.org/
	HardwareModel_LORA_TYPE HardwareModel = 19
	// wiphone https://www.wiphone.io/
	HardwareModel_WIPHONE HardwareModel = 20
	// WIO Tracker WM1110 family from Seeed Studio. Includes wio-1110-tracker and wio-1110-sdk
	HardwareModel_WIO_WM1110 HardwareModel = 21
	// RAK2560 Solar base station based on RAK4630
	HardwareModel_RAK2560 HardwareModel = 22
	// Heltec HRU-3601: https://heltec.org/project/hru-3601/
	HardwareModel_HELTEC_HRU_3601 HardwareModel = 23
	// Heltec Wireless Bridge
	HardwareModel_HELTEC_WIRELESS_BRIDGE HardwareModel = 24
	// B&Q Consulting Station Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:station
	HardwareModel_STATION_G1 HardwareModel = 25
	// RAK11310 (RP2040 + SX1262)
	HardwareModel_RAK11310 HardwareModel = 26
	// Makerfabs SenseLoRA Receiver (RP2040 + RFM96)
	HardwareModel_SENSELORA_RP2040 HardwareModel = 27
	// Makerfabs SenseLoRA Industrial Monitor (ESP32-S3 + RFM96)
	HardwareModel_SENSELORA_S3 HardwareModel = 28
	// Canary Radio Company - CanaryOne: https://canaryradio.io/products/canaryone
	HardwareModel_CANARYONE HardwareModel = 29
	// Waveshare RP2040 LoRa - https://www.waveshare.com/rp2040-lora.htm
	HardwareModel_RP2040_LORA HardwareModel = 30
	// B&Q Consulting Station G2: https://wiki.uniteng.com/en/meshtastic/station-g2
	HardwareModel_STATION_G2 HardwareModel = 31
	// ---------------------------------------------------------------------------
	// Less common/prototype boards listed here (needs one more byte over the air)
	// ---------------------------------------------------------------------------
	HardwareModel_LORA_RELAY_V1 HardwareModel = 32
	// TODO: REPLACE
	HardwareModel_NRF52840DK HardwareModel = 33
	// TODO: REPLACE
	HardwareModel_PPR HardwareModel = 34
	// TODO: REPLACE
	HardwareModel_GENIEBLOCKS HardwareModel = 35
	// TODO: REPLACE
	HardwareModel_NRF52_UNKNOWN HardwareModel = 36
	// TODO: REPLACE
	HardwareModel_PORTDUINO HardwareModel = 37
	// The simulator built into the android app
	HardwareModel_ANDROID_SIM HardwareModel = 38
	// Custom DIY device based on @NanoVHF schematics: https://github.com/NanoVHF/Meshtastic-DIY/tree/main/Schematics
	HardwareModel_DIY_V1 HardwareModel = 39
	// nRF52840 Dongle : https://www.nordicsemi.com/Products/Development-hardware/nrf52840-dongle/
	HardwareModel_NRF52840_PCA10059 HardwareModel = 40
	// Custom Disaster Radio esp32 v3 device https://github.com/sudomesh/disaster-radio/tree/master/hardware/board_esp32_v3
	HardwareModel_DR_DEV HardwareModel = 41
	// M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, CoreS3, Paper) https://m5stack.com/
	HardwareModel_M5STACK HardwareModel = 42
	// New Heltec LoRA32 with ESP32-S3 CPU
	HardwareModel_HELTEC_V3 HardwareModel = 43
	// New Heltec Wireless Stick Lite with ESP32-S3 CPU
	HardwareModel_HELTEC_WSL_V3 HardwareModel = 44
	// New BETAFPV ELRS Micro TX Module 2.4G with ESP32 CPU
	HardwareModel_BETAFPV_2400_TX HardwareModel = 45
	// BetaFPV ExpressLRS "Nano" TX Module 900MHz with ESP32 CPU
	HardwareModel_BETAFPV_900_NANO_TX HardwareModel = 46
	// Raspberry Pi Pico (W) with Waveshare SX1262 LoRa Node Module
	HardwareModel_RPI_PICO HardwareModel = 47
	// Heltec Wireless Tracker with ESP32-S3 CPU, built-in GPS, and TFT
	// Newer V1.1, version is written on the PCB near the display.
	HardwareModel_HELTEC_WIRELESS_TRACKER HardwareModel = 48
	// Heltec Wireless Paper with ESP32-S3 CPU and E-Ink display
	HardwareModel_HELTEC_WIRELESS_PAPER HardwareModel = 49
	// LilyGo T-Deck with ESP32-S3 CPU, Keyboard and IPS display
	HardwareModel_T_DECK HardwareModel = 50
	// LilyGo T-Watch S3 with ESP32-S3 CPU and IPS display
	HardwareModel_T_WATCH_S3 HardwareModel = 51
	// Bobricius Picomputer with ESP32-S3 CPU, Keyboard and IPS display
	HardwareModel_PICOMPUTER_S3 HardwareModel = 52
	// Heltec HT-CT62 with ESP32-C3 CPU and SX1262 LoRa
	HardwareModel_HELTEC_HT62 HardwareModel = 53
	// EBYTE SPI LoRa module and ESP32-S3
	HardwareModel_EBYTE_ESP32_S3 HardwareModel = 54
	// Waveshare ESP32-S3-PICO with PICO LoRa HAT and 2.9inch e-Ink
	HardwareModel_ESP32_S3_PICO HardwareModel = 55
	// CircuitMess Chatter 2 LLCC68 Lora Module and ESP32 Wroom
	// Lora module can be swapped out for a Heltec RA-62 which is "almost" pin compatible
	// with one cut and one jumper Meshtastic works
	HardwareModel_CHATTER_2 HardwareModel = 56
	// Heltec Wireless Paper, With ESP32-S3 CPU and E-Ink display
	// Older "V1.0" Variant, has no "version sticker"
	// E-Ink model is DEPG0213BNS800
	// Tab on the screen protector is RED
	// Flex connector marking is FPC-7528B
	HardwareModel_HELTEC_WIRELESS_PAPER_V1_0 HardwareModel = 57
	// Heltec Wireless Tracker with ESP32-S3 CPU, built-in GPS, and TFT
	// Older "V1.0" Variant
	HardwareModel_HELTEC_WIRELESS_TRACKER_V1_0 HardwareModel = 58
	// unPhone with ESP32-S3, TFT touchscreen,  LSM6DS3TR-C accelerometer and gyroscope
	HardwareModel_UNPHONE HardwareModel = 59
	// Teledatics TD-LORAC NRF52840 based M.2 LoRA module
	// Compatible with the TD-WRLS development board
	HardwareModel_TD_LORAC HardwareModel = 60
	// CDEBYTE EoRa-S3 board using their own MM modules, clone of LILYGO T3S3
	HardwareModel_CDEBYTE_EORA_S3 HardwareModel = 61
	// TWC_MESH_V4
	// Adafruit NRF52840 feather express with SX1262, SSD1306 OLED and NEO6M GPS
	HardwareModel_TWC_MESH_V4 HardwareModel = 62
	// NRF52_PROMICRO_DIY
	// Promicro NRF52840 with SX1262/LLCC68, SSD1306 OLED and NEO6M GPS
	HardwareModel_NRF52_PROMICRO_DIY HardwareModel = 63
	// RadioMaster 900 Bandit Nano, https://www.radiomasterrc.com/products/bandit-nano-expresslrs-rf-module
	// ESP32-D0WDQ6 With SX1276/SKY66122, SSD1306 OLED and No GPS
	HardwareModel_RADIOMASTER_900_BANDIT_NANO HardwareModel = 64
	// Heltec Capsule Sensor V3 with ESP32-S3 CPU, Portable LoRa device that can replace GNSS modules or sensors
	HardwareModel_HELTEC_CAPSULE_SENSOR_V3 HardwareModel = 65
	// Heltec Vision Master T190 with ESP32-S3 CPU, and a 1.90 inch TFT display
	HardwareModel_HELTEC_VISION_MASTER_T190 HardwareModel = 66
	// Heltec Vision Master E213 with ESP32-S3 CPU, and a 2.13 inch E-Ink display
	HardwareModel_HELTEC_VISION_MASTER_E213 HardwareModel = 67
	// Heltec Vision Master E290 with ESP32-S3 CPU, and a 2.9 inch E-Ink display
	HardwareModel_HELTEC_VISION_MASTER_E290 HardwareModel = 68
	// Heltec Mesh Node T114 board with nRF52840 CPU, and a 1.14 inch TFT display, Ultimate low-power design,
	// specifically adapted for the Meshtatic project
	HardwareModel_HELTEC_MESH_NODE_T114 HardwareModel = 69
	// Sensecap Indicator from Seeed Studio. ESP32-S3 device with TFT and RP2040 coprocessor
	HardwareModel_SENSECAP_INDICATOR HardwareModel = 70
	// Seeed studio T1000-E tracker card. NRF52840 w/ LR1110 radio, GPS, button, buzzer, and sensors.
	HardwareModel_TRACKER_T1000_E HardwareModel = 71
	// RAK3172 STM32WLE5 Module (https://store.rakwireless.com/products/wisduo-lpwan-module-rak3172)
	HardwareModel_RAK3172 HardwareModel = 72
	// Seeed Studio Wio-E5 (either mini or Dev kit) using STM32WL chip.
	HardwareModel_WIO_E5 HardwareModel = 73
	// RadioMaster 900 Bandit, https://www.radiomasterrc.com/products/bandit-expresslrs-rf-module
	// SSD1306 OLED and No GPS
	HardwareModel_RADIOMASTER_900_BANDIT HardwareModel = 74
	// Minewsemi ME25LS01 (ME25LE01_V1.0). NRF52840 w/ LR1110 radio, buttons and leds and pins.
	HardwareModel_ME25LS01_4Y10TD HardwareModel = 75
	// RP2040_FEATHER_RFM95
	// Adafruit Feather RP2040 with RFM95 LoRa Radio RFM95 with SX1272, SSD1306 OLED
	// https://www.adafruit.com/product/5714
	// https://www.adafruit.com/product/326
	// https://www.adafruit.com/product/938
	//
	//	^^^ short A0 to switch to I2C address 0x3C
	HardwareModel_RP2040_FEATHER_RFM95 HardwareModel = 76
	// M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, CoreS3, Paper) https://m5stack.com/
	HardwareModel_M5STACK_COREBASIC HardwareModel = 77
	HardwareModel_M5STACK_CORE2     HardwareModel = 78
	// Pico2 with Waveshare Hat, same as Pico
	HardwareModel_RPI_PICO2 HardwareModel = 79
	// M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, CoreS3, Paper) https://m5stack.com/
	HardwareModel_M5STACK_CORES3 HardwareModel = 80
	// Seeed XIAO S3 DK
	HardwareModel_SEEED_XIAO_S3 HardwareModel = 81
	// Nordic nRF52840+Semtech SX1262 LoRa BLE Combo Module. nRF52840+SX1262 MS24SF1
	HardwareModel_MS24SF1 HardwareModel = 82
	// Lilygo TLora-C6 with the new ESP32-C6 MCU
	HardwareModel_TLORA_C6 HardwareModel = 83
	// ------------------------------------------------------------------------------------------------------------------------------------------
	// Reserved ID For developing private Ports. These will show up in live traffic sparsely, so we can use a high number. Keep it within 8 bits.
	// ------------------------------------------------------------------------------------------------------------------------------------------
	HardwareModel_PRIVATE_HW HardwareModel = 255
)

// Enum value maps for HardwareModel.
var (
	HardwareModel_name = map[int32]string{
		0:   "UNSET",
		1:   "TLORA_V2",
		2:   "TLORA_V1",
		3:   "TLORA_V2_1_1P6",
		4:   "TBEAM",
		5:   "HELTEC_V2_0",
		6:   "TBEAM_V0P7",
		7:   "T_ECHO",
		8:   "TLORA_V1_1P3",
		9:   "RAK4631",
		10:  "HELTEC_V2_1",
		11:  "HELTEC_V1",
		12:  "LILYGO_TBEAM_S3_CORE",
		13:  "RAK11200",
		14:  "NANO_G1",
		15:  "TLORA_V2_1_1P8",
		16:  "TLORA_T3_S3",
		17:  "NANO_G1_EXPLORER",
		18:  "NANO_G2_ULTRA",
		19:  "LORA_TYPE",
		20:  "WIPHONE",
		21:  "WIO_WM1110",
		22:  "RAK2560",
		23:  "HELTEC_HRU_3601",
		24:  "HELTEC_WIRELESS_BRIDGE",
		25:  "STATION_G1",
		26:  "RAK11310",
		27:  "SENSELORA_RP2040",
		28:  "SENSELORA_S3",
		29:  "CANARYONE",
		30:  "RP2040_LORA",
		31:  "STATION_G2",
		32:  "LORA_RELAY_V1",
		33:  "NRF52840DK",
		34:  "PPR",
		35:  "GENIEBLOCKS",
		36:  "NRF52_UNKNOWN",
		37:  "PORTDUINO",
		38:  "ANDROID_SIM",
		39:  "DIY_V1",
		40:  "NRF52840_PCA10059",
		41:  "DR_DEV",
		42:  "M5STACK",
		43:  "HELTEC_V3",
		44:  "HELTEC_WSL_V3",
		45:  "BETAFPV_2400_TX",
		46:  "BETAFPV_900_NANO_TX",
		47:  "RPI_PICO",
		48:  "HELTEC_WIRELESS_TRACKER",
		49:  "HELTEC_WIRELESS_PAPER",
		50:  "T_DECK",
		51:  "T_WATCH_S3",
		52:  "PICOMPUTER_S3",
		53:  "HELTEC_HT62",
		54:  "EBYTE_ESP32_S3",
		55:  "ESP32_S3_PICO",
		56:  "CHATTER_2",
		57:  "HELTEC_WIRELESS_PAPER_V1_0",
		58:  "HELTEC_WIRELESS_TRACKER_V1_0",
		59:  "UNPHONE",
		60:  "TD_LORAC",
		61:  "CDEBYTE_EORA_S3",
		62:  "TWC_MESH_V4",
		63:  "NRF52_PROMICRO_DIY",
		64:  "RADIOMASTER_900_BANDIT_NANO",
		65:  "HELTEC_CAPSULE_SENSOR_V3",
		66:  "HELTEC_VISION_MASTER_T190",
		67:  "HELTEC_VISION_MASTER_E213",
		68:  "HELTEC_VISION_MASTER_E290",
		69:  "HELTEC_MESH_NODE_T114",
		70:  "SENSECAP_INDICATOR",
		71:  "TRACKER_T1000_E",
		72:  "RAK3172",
		73:  "WIO_E5",
		74:  "RADIOMASTER_900_BANDIT",
		75:  "ME25LS01_4Y10TD",
		76:  "RP2040_FEATHER_RFM95",
		77:  "M5STACK_COREBASIC",
		78:  "M5STACK_CORE2",
		79:  "RPI_PICO2",
		80:  "M5STACK_CORES3",
		81:  "SEEED_XIAO_S3",
		82:  "MS24SF1",
		83:  "TLORA_C6",
		255: "PRIVATE_HW",
	}
	HardwareModel_value = map[string]int32{
		"UNSET":                        0,
		"TLORA_V2":                     1,
		"TLORA_V1":                     2,
		"TLORA_V2_1_1P6":               3,
		"TBEAM":                        4,
		"HELTEC_V2_0":                  5,
		"TBEAM_V0P7":                   6,
		"T_ECHO":                       7,
		"TLORA_V1_1P3":                 8,
		"RAK4631":                      9,
		"HELTEC_V2_1":                  10,
		"HELTEC_V1":                    11,
		"LILYGO_TBEAM_S3_CORE":         12,
		"RAK11200":                     13,
		"NANO_G1":                      14,
		"TLORA_V2_1_1P8":               15,
		"TLORA_T3_S3":                  16,
		"NANO_G1_EXPLORER":             17,
		"NANO_G2_ULTRA":                18,
		"LORA_TYPE":                    19,
		"WIPHONE":                      20,
		"WIO_WM1110":                   21,
		"RAK2560":                      22,
		"HELTEC_HRU_3601":              23,
		"HELTEC_WIRELESS_BRIDGE":       24,
		"STATION_G1":                   25,
		"RAK11310":                     26,
		"SENSELORA_RP2040":             27,
		"SENSELORA_S3":                 28,
		"CANARYONE":                    29,
		"RP2040_LORA":                  30,
		"STATION_G2":                   31,
		"LORA_RELAY_V1":                32,
		"NRF52840DK":                   33,
		"PPR":                          34,
		"GENIEBLOCKS":                  35,
		"NRF52_UNKNOWN":                36,
		"PORTDUINO":                    37,
		"ANDROID_SIM":                  38,
		"DIY_V1":                       39,
		"NRF52840_PCA10059":            40,
		"DR_DEV":                       41,
		"M5STACK":                      42,
		"HELTEC_V3":                    43,
		"HELTEC_WSL_V3":                44,
		"BETAFPV_2400_TX":              45,
		"BETAFPV_900_NANO_TX":          46,
		"RPI_PICO":                     47,
		"HELTEC_WIRELESS_TRACKER":      48,
		"HELTEC_WIRELESS_PAPER":        49,
		"T_DECK":                       50,
		"T_WATCH_S3":                   51,
		"PICOMPUTER_S3":                52,
		"HELTEC_HT62":                  53,
		"EBYTE_ESP32_S3":               54,
		"ESP32_S3_PICO":                55,
		"CHATTER_2":                    56,
		"HELTEC_WIRELESS_PAPER_V1_0":   57,
		"HELTEC_WIRELESS_TRACKER_V1_0": 58,
		"UNPHONE":                      59,
		"TD_LORAC":                     60,
		"CDEBYTE_EORA_S3":              61,
		"TWC_MESH_V4":                  62,
		"NRF52_PROMICRO_DIY":           63,
		"RADIOMASTER_900_BANDIT_NANO":  64,
		"HELTEC_CAPSULE_SENSOR_V3":     65,
		"HELTEC_VISION_MASTER_T190":    66,
		"HELTEC_VISION_MASTER_E213":    67,
		"HELTEC_VISION_MASTER_E290":    68,
		"HELTEC_MESH_NODE_T114":        69,
		"SENSECAP_INDICATOR":           70,
		"TRACKER_T1000_E":              71,
		"RAK3172":                      72,
		"WIO_E5":                       73,
		"RADIOMASTER_900_BANDIT":       74,
		"ME25LS01_4Y10TD":              75,
		"RP2040_FEATHER_RFM95":         76,
		"M5STACK_COREBASIC":            77,
		"M5STACK_CORE2":                78,
		"RPI_PICO2":                    79,
		"M5STACK_CORES3":               80,
		"SEEED_XIAO_S3":                81,
		"MS24SF1":                      82,
		"TLORA_C6":                     83,
		"PRIVATE_HW":                   255,
	}
)

func (x HardwareModel) Enum() *HardwareModel {
	p := new(HardwareModel)
	*p = x
	return p
}

func (x HardwareModel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HardwareModel) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[0].Descriptor()
}

func (HardwareModel) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[0]
}

func (x HardwareModel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HardwareModel.Descriptor instead.
func (HardwareModel) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{0}
}

// Shared constants between device and phone
type Constants int32

const (
	// First enum must be zero, and we are just using this enum to
	// pass int constants between two very different environments
	Constants_ZERO Constants = 0
	// From mesh.options
	// note: this payload length is ONLY the bytes that are sent inside of the Data protobuf (excluding protobuf overhead). The 16 byte header is
	// outside of this envelope
	Constants_DATA_PAYLOAD_LEN Constants = 237
)

// Enum value maps for Constants.
var (
	Constants_name = map[int32]string{
		0:   "ZERO",
		237: "DATA_PAYLOAD_LEN",
	}
	Constants_value = map[string]int32{
		"ZERO":             0,
		"DATA_PAYLOAD_LEN": 237,
	}
)

func (x Constants) Enum() *Constants {
	p := new(Constants)
	*p = x
	return p
}

func (x Constants) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Constants) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[1].Descriptor()
}

func (Constants) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[1]
}

func (x Constants) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Constants.Descriptor instead.
func (Constants) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{1}
}

// Error codes for critical errors
// The device might report these fault codes on the screen.
// If you encounter a fault code, please post on the meshtastic.discourse.group
// and we'll try to help.
type CriticalErrorCode int32

const (
	// TODO: REPLACE
	CriticalErrorCode_NONE CriticalErrorCode = 0
	// A software bug was detected while trying to send lora
	CriticalErrorCode_TX_WATCHDOG CriticalErrorCode = 1
	// A software bug was detected on entry to sleep
	CriticalErrorCode_SLEEP_ENTER_WAIT CriticalErrorCode = 2
	// No Lora radio hardware could be found
	CriticalErrorCode_NO_RADIO CriticalErrorCode = 3
	// Not normally used
	CriticalErrorCode_UNSPECIFIED CriticalErrorCode = 4
	// We failed while configuring a UBlox GPS
	CriticalErrorCode_UBLOX_UNIT_FAILED CriticalErrorCode = 5
	// This board was expected to have a power management chip and it is missing or broken
	CriticalErrorCode_NO_AXP192 CriticalErrorCode = 6
	// The channel tried to set a radio setting which is not supported by this chipset,
	// radio comms settings are now undefined.
	CriticalErrorCode_INVALID_RADIO_SETTING CriticalErrorCode = 7
	// Radio transmit hardware failure. We sent data to the radio chip, but it didn't
	// reply with an interrupt.
	CriticalErrorCode_TRANSMIT_FAILED CriticalErrorCode = 8
	// We detected that the main CPU voltage dropped below the minimum acceptable value
	CriticalErrorCode_BROWNOUT CriticalErrorCode = 9
	// Selftest of SX1262 radio chip failed
	CriticalErrorCode_SX1262_FAILURE CriticalErrorCode = 10
	// A (likely software but possibly hardware) failure was detected while trying to send packets.
	// If this occurs on your board, please post in the forum so that we can ask you to collect some information to allow fixing this bug
	CriticalErrorCode_RADIO_SPI_BUG CriticalErrorCode = 11
	// Corruption was detected on the flash filesystem but we were able to repair things.
	// If you see this failure in the field please post in the forum because we are interested in seeing if this is occurring in the field.
	CriticalErrorCode_FLASH_CORRUPTION_RECOVERABLE CriticalErrorCode = 12
	// Corruption was detected on the flash filesystem but we were unable to repair things.
	// NOTE: Your node will probably need to be reconfigured the next time it reboots (it will lose the region code etc...)
	// If you see this failure in the field please post in the forum because we are interested in seeing if this is occurring in the field.
	CriticalErrorCode_FLASH_CORRUPTION_UNRECOVERABLE CriticalErrorCode = 13
)

// Enum value maps for CriticalErrorCode.
var (
	CriticalErrorCode_name = map[int32]string{
		0:  "NONE",
		1:  "TX_WATCHDOG",
		2:  "SLEEP_ENTER_WAIT",
		3:  "NO_RADIO",
		4:  "UNSPECIFIED",
		5:  "UBLOX_UNIT_FAILED",
		6:  "NO_AXP192",
		7:  "INVALID_RADIO_SETTING",
		8:  "TRANSMIT_FAILED",
		9:  "BROWNOUT",
		10: "SX1262_FAILURE",
		11: "RADIO_SPI_BUG",
		12: "FLASH_CORRUPTION_RECOVERABLE",
		13: "FLASH_CORRUPTION_UNRECOVERABLE",
	}
	CriticalErrorCode_value = map[string]int32{
		"NONE":                           0,
		"TX_WATCHDOG":                    1,
		"SLEEP_ENTER_WAIT":               2,
		"NO_RADIO":                       3,
		"UNSPECIFIED":                    4,
		"UBLOX_UNIT_FAILED":              5,
		"NO_AXP192":                      6,
		"INVALID_RADIO_SETTING":          7,
		"TRANSMIT_FAILED":                8,
		"BROWNOUT":                       9,
		"SX1262_FAILURE":                 10,
		"RADIO_SPI_BUG":                  11,
		"FLASH_CORRUPTION_RECOVERABLE":   12,
		"FLASH_CORRUPTION_UNRECOVERABLE": 13,
	}
)

func (x CriticalErrorCode) Enum() *CriticalErrorCode {
	p := new(CriticalErrorCode)
	*p = x
	return p
}

func (x CriticalErrorCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CriticalErrorCode) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[2].Descriptor()
}

func (CriticalErrorCode) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[2]
}

func (x CriticalErrorCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CriticalErrorCode.Descriptor instead.
func (CriticalErrorCode) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{2}
}

// How the location was acquired: manual, onboard GPS, external (EUD) GPS
type Position_LocSource int32

const (
	// TODO: REPLACE
	Position_LOC_UNSET Position_LocSource = 0
	// TODO: REPLACE
	Position_LOC_MANUAL Position_LocSource = 1
	// TODO: REPLACE
	Position_LOC_INTERNAL Position_LocSource = 2
	// TODO: REPLACE
	Position_LOC_EXTERNAL Position_LocSource = 3
)

// Enum value maps for Position_LocSource.
var (
	Position_LocSource_name = map[int32]string{
		0: "LOC_UNSET",
		1: "LOC_MANUAL",
		2: "LOC_INTERNAL",
		3: "LOC_EXTERNAL",
	}
	Position_LocSource_value = map[string]int32{
		"LOC_UNSET":    0,
		"LOC_MANUAL":   1,
		"LOC_INTERNAL": 2,
		"LOC_EXTERNAL": 3,
	}
)

func (x Position_LocSource) Enum() *Position_LocSource {
	p := new(Position_LocSource)
	*p = x
	return p
}

func (x Position_LocSource) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Position_LocSource) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[3].Descriptor()
}

func (Position_LocSource) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[3]
}

func (x Position_LocSource) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Position_LocSource.Descriptor instead.
func (Position_LocSource) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{0, 0}
}

// How the altitude was acquired: manual, GPS int/ext, etc
// Default: same as location_source if present
type Position_AltSource int32

const (
	// TODO: REPLACE
	Position_ALT_UNSET Position_AltSource = 0
	// TODO: REPLACE
	Position_ALT_MANUAL Position_AltSource = 1
	// TODO: REPLACE
	Position_ALT_INTERNAL Position_AltSource = 2
	// TODO: REPLACE
	Position_ALT_EXTERNAL Position_AltSource = 3
	// TODO: REPLACE
	Position_ALT_BAROMETRIC Position_AltSource = 4
)

// Enum value maps for Position_AltSource.
var (
	Position_AltSource_name = map[int32]string{
		0: "ALT_UNSET",
		1: "ALT_MANUAL",
		2: "ALT_INTERNAL",
		3: "ALT_EXTERNAL",
		4: "ALT_BAROMETRIC",
	}
	Position_AltSource_value = map[string]int32{
		"ALT_UNSET":      0,
		"ALT_MANUAL":     1,
		"ALT_INTERNAL":   2,
		"ALT_EXTERNAL":   3,
		"ALT_BAROMETRIC": 4,
	}
)

func (x Position_AltSource) Enum() *Position_AltSource {
	p := new(Position_AltSource)
	*p = x
	return p
}

func (x Position_AltSource) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Position_AltSource) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[4].Descriptor()
}

func (Position_AltSource) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[4]
}

func (x Position_AltSource) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Position_AltSource.Descriptor instead.
func (Position_AltSource) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{0, 1}
}

// A failure in delivering a message (usually used for routing control messages, but might be provided in addition to ack.fail_id to provide
// details on the type of failure).
type Routing_Error int32

const (
	// This message is not a failure
	Routing_NONE Routing_Error = 0
	// Our node doesn't have a route to the requested destination anymore.
	Routing_NO_ROUTE Routing_Error = 1
	// We received a nak while trying to forward on your behalf
	Routing_GOT_NAK Routing_Error = 2
	// TODO: REPLACE
	Routing_TIMEOUT Routing_Error = 3
	// No suitable interface could be found for delivering this packet
	Routing_NO_INTERFACE Routing_Error = 4
	// We reached the max retransmission count (typically for naive flood routing)
	Routing_MAX_RETRANSMIT Routing_Error = 5
	// No suitable channel was found for sending this packet (i.e. was requested channel index disabled?)
	Routing_NO_CHANNEL Routing_Error = 6
	// The packet was too big for sending (exceeds interface MTU after encoding)
	Routing_TOO_LARGE Routing_Error = 7
	// The request had want_response set, the request reached the destination node, but no service on that node wants to send a response
	// (possibly due to bad channel permissions)
	Routing_NO_RESPONSE Routing_Error = 8
	// Cannot send currently because duty cycle regulations will be violated.
	Routing_DUTY_CYCLE_LIMIT Routing_Error = 9
	// The application layer service on the remote node received your request, but considered your request somehow invalid
	Routing_BAD_REQUEST Routing_Error = 32
	// The application layer service on the remote node received your request, but considered your request not authorized
	// (i.e you did not send the request on the required bound channel)
	Routing_NOT_AUTHORIZED Routing_Error = 33
	// The client specified a PKI transport, but the node was unable to send the packet using PKI (and did not send the message at all)
	Routing_PKI_FAILED Routing_Error = 34
	// The receiving node does not have a Public Key to decode with
	Routing_PKI_UNKNOWN_PUBKEY Routing_Error = 35
	// Admin packet otherwise checks out, but uses a bogus or expired session key
	Routing_ADMIN_BAD_SESSION_KEY Routing_Error = 36
	// Admin packet sent using PKC, but not from a public key on the admin key list
	Routing_ADMIN_PUBLIC_KEY_UNAUTHORIZED Routing_Error = 37
)

// Enum value maps for Routing_Error.
var (
	Routing_Error_name = map[int32]string{
		0:  "NONE",
		1:  "NO_ROUTE",
		2:  "GOT_NAK",
		3:  "TIMEOUT",
		4:  "NO_INTERFACE",
		5:  "MAX_RETRANSMIT",
		6:  "NO_CHANNEL",
		7:  "TOO_LARGE",
		8:  "NO_RESPONSE",
		9:  "DUTY_CYCLE_LIMIT",
		32: "BAD_REQUEST",
		33: "NOT_AUTHORIZED",
		34: "PKI_FAILED",
		35: "PKI_UNKNOWN_PUBKEY",
		36: "ADMIN_BAD_SESSION_KEY",
		37: "ADMIN_PUBLIC_KEY_UNAUTHORIZED",
	}
	Routing_Error_value = map[string]int32{
		"NONE":                          0,
		"NO_ROUTE":                      1,
		"GOT_NAK":                       2,
		"TIMEOUT":                       3,
		"NO_INTERFACE":                  4,
		"MAX_RETRANSMIT":                5,
		"NO_CHANNEL":                    6,
		"TOO_LARGE":                     7,
		"NO_RESPONSE":                   8,
		"DUTY_CYCLE_LIMIT":              9,
		"BAD_REQUEST":                   32,
		"NOT_AUTHORIZED":                33,
		"PKI_FAILED":                    34,
		"PKI_UNKNOWN_PUBKEY":            35,
		"ADMIN_BAD_SESSION_KEY":         36,
		"ADMIN_PUBLIC_KEY_UNAUTHORIZED": 37,
	}
)

func (x Routing_Error) Enum() *Routing_Error {
	p := new(Routing_Error)
	*p = x
	return p
}

func (x Routing_Error) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Routing_Error) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[5].Descriptor()
}

func (Routing_Error) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[5]
}

func (x Routing_Error) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Routing_Error.Descriptor instead.
func (Routing_Error) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{3, 0}
}

// The priority of this message for sending.
// Higher priorities are sent first (when managing the transmit queue).
// This field is never sent over the air, it is only used internally inside of a local device node.
// API clients (either on the local node or connected directly to the node)
// can set this parameter if necessary.
// (values must be <= 127 to keep protobuf field to one byte in size.
// Detailed background on this field:
// I noticed a funny side effect of lora being so slow: Usually when making
// a protocol there isn’t much need to use message priority to change the order
// of transmission (because interfaces are fairly fast).
// But for lora where packets can take a few seconds each, it is very important
// to make sure that critical packets are sent ASAP.
// In the case of meshtastic that means we want to send protocol acks as soon as possible
// (to prevent unneeded retransmissions), we want routing messages to be sent next,
// then messages marked as reliable and finally 'background' packets like periodic position updates.
// So I bit the bullet and implemented a new (internal - not sent over the air)
// field in MeshPacket called 'priority'.
// And the transmission queue in the router object is now a priority queue.
type MeshPacket_Priority int32

const (
	// Treated as Priority.DEFAULT
	MeshPacket_UNSET MeshPacket_Priority = 0
	// TODO: REPLACE
	MeshPacket_MIN MeshPacket_Priority = 1
	// Background position updates are sent with very low priority -
	// if the link is super congested they might not go out at all
	MeshPacket_BACKGROUND MeshPacket_Priority = 10
	// This priority is used for most messages that don't have a priority set
	MeshPacket_DEFAULT MeshPacket_Priority = 64
	// If priority is unset but the message is marked as want_ack,
	// assume it is important and use a slightly higher priority
	MeshPacket_RELIABLE MeshPacket_Priority = 70
	// If priority is unset but the packet is a response to a request, we want it to get there relatively quickly.
	// Furthermore, responses stop relaying packets directed to a node early.
	MeshPacket_RESPONSE MeshPacket_Priority = 80
	// Higher priority for specific message types (portnums) to distinguish between other reliable packets.
	MeshPacket_HIGH MeshPacket_Priority = 100
	// Ack/naks are sent with very high priority to ensure that retransmission
	// stops as soon as possible
	MeshPacket_ACK MeshPacket_Priority = 120
	// TODO: REPLACE
	MeshPacket_MAX MeshPacket_Priority = 127
)

// Enum value maps for MeshPacket_Priority.
var (
	MeshPacket_Priority_name = map[int32]string{
		0:   "UNSET",
		1:   "MIN",
		10:  "BACKGROUND",
		64:  "DEFAULT",
		70:  "RELIABLE",
		80:  "RESPONSE",
		100: "HIGH",
		120: "ACK",
		127: "MAX",
	}
	MeshPacket_Priority_value = map[string]int32{
		"UNSET":      0,
		"MIN":        1,
		"BACKGROUND": 10,
		"DEFAULT":    64,
		"RELIABLE":   70,
		"RESPONSE":   80,
		"HIGH":       100,
		"ACK":        120,
		"MAX":        127,
	}
)

func (x MeshPacket_Priority) Enum() *MeshPacket_Priority {
	p := new(MeshPacket_Priority)
	*p = x
	return p
}

func (x MeshPacket_Priority) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MeshPacket_Priority) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[6].Descriptor()
}

func (MeshPacket_Priority) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[6]
}

func (x MeshPacket_Priority) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MeshPacket_Priority.Descriptor instead.
func (MeshPacket_Priority) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{7, 0}
}

// Identify if this is a delayed packet
type MeshPacket_Delayed int32

const (
	// If unset, the message is being sent in real time.
	MeshPacket_NO_DELAY MeshPacket_Delayed = 0
	// The message is delayed and was originally a broadcast
	MeshPacket_DELAYED_BROADCAST MeshPacket_Delayed = 1
	// The message is delayed and was originally a direct message
	MeshPacket_DELAYED_DIRECT MeshPacket_Delayed = 2
)

// Enum value maps for MeshPacket_Delayed.
var (
	MeshPacket_Delayed_name = map[int32]string{
		0: "NO_DELAY",
		1: "DELAYED_BROADCAST",
		2: "DELAYED_DIRECT",
	}
	MeshPacket_Delayed_value = map[string]int32{
		"NO_DELAY":          0,
		"DELAYED_BROADCAST": 1,
		"DELAYED_DIRECT":    2,
	}
)

func (x MeshPacket_Delayed) Enum() *MeshPacket_Delayed {
	p := new(MeshPacket_Delayed)
	*p = x
	return p
}

func (x MeshPacket_Delayed) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MeshPacket_Delayed) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[7].Descriptor()
}

func (MeshPacket_Delayed) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[7]
}

func (x MeshPacket_Delayed) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MeshPacket_Delayed.Descriptor instead.
func (MeshPacket_Delayed) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{7, 1}
}

// Log levels, chosen to match python logging conventions.
type LogRecord_Level int32

const (
	// Log levels, chosen to match python logging conventions.
	LogRecord_UNSET LogRecord_Level = 0
	// Log levels, chosen to match python logging conventions.
	LogRecord_CRITICAL LogRecord_Level = 50
	// Log levels, chosen to match python logging conventions.
	LogRecord_ERROR LogRecord_Level = 40
	// Log levels, chosen to match python logging conventions.
	LogRecord_WARNING LogRecord_Level = 30
	// Log levels, chosen to match python logging conventions.
	LogRecord_INFO LogRecord_Level = 20
	// Log levels, chosen to match python logging conventions.
	LogRecord_DEBUG LogRecord_Level = 10
	// Log levels, chosen to match python logging conventions.
	LogRecord_TRACE LogRecord_Level = 5
)

// Enum value maps for LogRecord_Level.
var (
	LogRecord_Level_name = map[int32]string{
		0:  "UNSET",
		50: "CRITICAL",
		40: "ERROR",
		30: "WARNING",
		20: "INFO",
		10: "DEBUG",
		5:  "TRACE",
	}
	LogRecord_Level_value = map[string]int32{
		"UNSET":    0,
		"CRITICAL": 50,
		"ERROR":    40,
		"WARNING":  30,
		"INFO":     20,
		"DEBUG":    10,
		"TRACE":    5,
	}
)

func (x LogRecord_Level) Enum() *LogRecord_Level {
	p := new(LogRecord_Level)
	*p = x
	return p
}

func (x LogRecord_Level) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LogRecord_Level) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[8].Descriptor()
}

func (LogRecord_Level) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[8]
}

func (x LogRecord_Level) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LogRecord_Level.Descriptor instead.
func (LogRecord_Level) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{10, 0}
}

// a gps position
type Position struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The new preferred location encoding, multiply by 1e-7 to get degrees
	// in floating point
	LatitudeI *int32 `protobuf:"fixed32,1,opt,name=latitude_i,json=latitudeI,proto3,oneof" json:"latitude_i,omitempty"`
	// TODO: REPLACE
	LongitudeI *int32 `protobuf:"fixed32,2,opt,name=longitude_i,json=longitudeI,proto3,oneof" json:"longitude_i,omitempty"`
	// In meters above MSL (but see issue #359)
	Altitude *int32 `protobuf:"varint,3,opt,name=altitude,proto3,oneof" json:"altitude,omitempty"`
	// This is usually not sent over the mesh (to save space), but it is sent
	// from the phone so that the local device can set its time if it is sent over
	// the mesh (because there are devices on the mesh without GPS or RTC).
	// seconds since 1970
	Time uint32 `protobuf:"fixed32,4,opt,name=time,proto3" json:"time,omitempty"`
	// TODO: REPLACE
	LocationSource Position_LocSource `protobuf:"varint,5,opt,name=location_source,json=locationSource,proto3,enum=meshtastic.Position_LocSource" json:"location_source,omitempty"`
	// TODO: REPLACE
	AltitudeSource Position_AltSource `protobuf:"varint,6,opt,name=altitude_source,json=altitudeSource,proto3,enum=meshtastic.Position_AltSource" json:"altitude_source,omitempty"`
	// Positional timestamp (actual timestamp of GPS solution) in integer epoch seconds
	Timestamp uint32 `protobuf:"fixed32,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Pos. timestamp milliseconds adjustment (rarely available or required)
	TimestampMillisAdjust int32 `protobuf:"varint,8,opt,name=timestamp_millis_adjust,json=timestampMillisAdjust,proto3" json:"timestamp_millis_adjust,omitempty"`
	// HAE altitude in meters - can be used instead of MSL altitude
	AltitudeHae *int32 `protobuf:"zigzag32,9,opt,name=altitude_hae,json=altitudeHae,proto3,oneof" json:"altitude_hae,omitempty"`
	// Geoidal separation in meters
	AltitudeGeoidalSeparation *int32 `protobuf:"zigzag32,10,opt,name=altitude_geoidal_separation,json=altitudeGeoidalSeparation,proto3,oneof" json:"altitude_geoidal_separation,omitempty"`
	// Horizontal, Vertical and Position Dilution of Precision, in 1/100 units
	//   - PDOP is sufficient for most cases
	//   - for higher precision scenarios, HDOP and VDOP can be used instead,
	//     in which case PDOP becomes redundant (PDOP=sqrt(HDOP^2 + VDOP^2))
	//
	// TODO: REMOVE/INTEGRATE
	PDOP uint32 `protobuf:"varint,11,opt,name=PDOP,proto3" json:"PDOP,omitempty"`
	// TODO: REPLACE
	HDOP uint32 `protobuf:"varint,12,opt,name=HDOP,proto3" json:"HDOP,omitempty"`
	// TODO: REPLACE
	VDOP uint32 `protobuf:"varint,13,opt,name=VDOP,proto3" json:"VDOP,omitempty"`
	// GPS accuracy (a hardware specific constant) in mm
	//
	//	multiplied with DOP to calculate positional accuracy
	//
	// Default: "'bout three meters-ish" :)
	GpsAccuracy uint32 `protobuf:"varint,14,opt,name=gps_accuracy,json=gpsAccuracy,proto3" json:"gps_accuracy,omitempty"`
	// Ground speed in m/s and True North TRACK in 1/100 degrees
	// Clarification of terms:
	// - "track" is the direction of motion (measured in horizontal plane)
	// - "heading" is where the fuselage points (measured in horizontal plane)
	// - "yaw" indicates a relative rotation about the vertical axis
	// TODO: REMOVE/INTEGRATE
	GroundSpeed *uint32 `protobuf:"varint,15,opt,name=ground_speed,json=groundSpeed,proto3,oneof" json:"ground_speed,omitempty"`
	// TODO: REPLACE
	GroundTrack *uint32 `protobuf:"varint,16,opt,name=ground_track,json=groundTrack,proto3,oneof" json:"ground_track,omitempty"`
	// GPS fix quality (from NMEA GxGGA statement or similar)
	FixQuality uint32 `protobuf:"varint,17,opt,name=fix_quality,json=fixQuality,proto3" json:"fix_quality,omitempty"`
	// GPS fix type 2D/3D (from NMEA GxGSA statement)
	FixType uint32 `protobuf:"varint,18,opt,name=fix_type,json=fixType,proto3" json:"fix_type,omitempty"`
	// GPS "Satellites in View" number
	SatsInView uint32 `protobuf:"varint,19,opt,name=sats_in_view,json=satsInView,proto3" json:"sats_in_view,omitempty"`
	// Sensor ID - in case multiple positioning sensors are being used
	SensorId uint32 `protobuf:"varint,20,opt,name=sensor_id,json=sensorId,proto3" json:"sensor_id,omitempty"`
	// Estimated/expected time (in seconds) until next update:
	//   - if we update at fixed intervals of X seconds, use X
	//   - if we update at dynamic intervals (based on relative movement etc),
	//     but "AT LEAST every Y seconds", use Y
	NextUpdate uint32 `protobuf:"varint,21,opt,name=next_update,json=nextUpdate,proto3" json:"next_update,omitempty"`
	// A sequence number, incremented with each Position message to help
	//
	//	detect lost updates if needed
	SeqNumber uint32 `protobuf:"varint,22,opt,name=seq_number,json=seqNumber,proto3" json:"seq_number,omitempty"`
	// Indicates the bits of precision set by the sending node
	PrecisionBits uint32 `protobuf:"varint,23,opt,name=precision_bits,json=precisionBits,proto3" json:"precision_bits,omitempty"`
}

func (x *Position) Reset() {
	*x = Position{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Position) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Position) ProtoMessage() {}

func (x *Position) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Position.ProtoReflect.Descriptor instead.
func (*Position) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{0}
}

func (x *Position) GetLatitudeI() int32 {
	if x != nil && x.LatitudeI != nil {
		return *x.LatitudeI
	}
	return 0
}

func (x *Position) GetLongitudeI() int32 {
	if x != nil && x.LongitudeI != nil {
		return *x.LongitudeI
	}
	return 0
}

func (x *Position) GetAltitude() int32 {
	if x != nil && x.Altitude != nil {
		return *x.Altitude
	}
	return 0
}

func (x *Position) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *Position) GetLocationSource() Position_LocSource {
	if x != nil {
		return x.LocationSource
	}
	return Position_LOC_UNSET
}

func (x *Position) GetAltitudeSource() Position_AltSource {
	if x != nil {
		return x.AltitudeSource
	}
	return Position_ALT_UNSET
}

func (x *Position) GetTimestamp() uint32 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *Position) GetTimestampMillisAdjust() int32 {
	if x != nil {
		return x.TimestampMillisAdjust
	}
	return 0
}

func (x *Position) GetAltitudeHae() int32 {
	if x != nil && x.AltitudeHae != nil {
		return *x.AltitudeHae
	}
	return 0
}

func (x *Position) GetAltitudeGeoidalSeparation() int32 {
	if x != nil && x.AltitudeGeoidalSeparation != nil {
		return *x.AltitudeGeoidalSeparation
	}
	return 0
}

func (x *Position) GetPDOP() uint32 {
	if x != nil {
		return x.PDOP
	}
	return 0
}

func (x *Position) GetHDOP() uint32 {
	if x != nil {
		return x.HDOP
	}
	return 0
}

func (x *Position) GetVDOP() uint32 {
	if x != nil {
		return x.VDOP
	}
	return 0
}

func (x *Position) GetGpsAccuracy() uint32 {
	if x != nil {
		return x.GpsAccuracy
	}
	return 0
}

func (x *Position) GetGroundSpeed() uint32 {
	if x != nil && x.GroundSpeed != nil {
		return *x.GroundSpeed
	}
	return 0
}

func (x *Position) GetGroundTrack() uint32 {
	if x != nil && x.GroundTrack != nil {
		return *x.GroundTrack
	}
	return 0
}

func (x *Position) GetFixQuality() uint32 {
	if x != nil {
		return x.FixQuality
	}
	return 0
}

func (x *Position) GetFixType() uint32 {
	if x != nil {
		return x.FixType
	}
	return 0
}

func (x *Position) GetSatsInView() uint32 {
	if x != nil {
		return x.SatsInView
	}
	return 0
}

func (x *Position) GetSensorId() uint32 {
	if x != nil {
		return x.SensorId
	}
	return 0
}

func (x *Position) GetNextUpdate() uint32 {
	if x != nil {
		return x.NextUpdate
	}
	return 0
}

func (x *Position) GetSeqNumber() uint32 {
	if x != nil {
		return x.SeqNumber
	}
	return 0
}

func (x *Position) GetPrecisionBits() uint32 {
	if x != nil {
		return x.PrecisionBits
	}
	return 0
}

// Broadcast when a newly powered mesh node wants to find a node num it can use
// Sent from the phone over bluetooth to set the user id for the owner of this node.
// Also sent from nodes to each other when a new node signs on (so all clients can have this info)
// The algorithm is as follows:
// when a node starts up, it broadcasts their user and the normal flow is for all
// other nodes to reply with their User as well (so the new node can build its nodedb)
// If a node ever receives a User (not just the first broadcast) message where
// the sender node number equals our node number, that indicates a collision has
// occurred and the following steps should happen:
// If the receiving node (that was already in the mesh)'s macaddr is LOWER than the
// new User who just tried to sign in: it gets to keep its nodenum.
// We send a broadcast message of OUR User (we use a broadcast so that the other node can
// receive our message, considering we have the same id - it also serves to let
// observers correct their nodedb) - this case is rare so it should be okay.
// If any node receives a User where the macaddr is GTE than their local macaddr,
// they have been vetoed and should pick a new random nodenum (filtering against
// whatever it knows about the nodedb) and rebroadcast their User.
// A few nodenums are reserved and will never be requested:
// 0xff - broadcast
// 0 through 3 - for future use
type User struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A globally unique ID string for this user.
	// In the case of Signal that would mean +16504442323, for the default macaddr derived id it would be !<8 hexidecimal bytes>.
	// Note: app developers are encouraged to also use the following standard
	// node IDs "^all" (for broadcast), "^local" (for the locally connected node)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// A full name for this user, i.e. "Kevin Hester"
	LongName string `protobuf:"bytes,2,opt,name=long_name,json=longName,proto3" json:"long_name,omitempty"`
	// A VERY short name, ideally two characters.
	// Suitable for a tiny OLED screen
	ShortName string `protobuf:"bytes,3,opt,name=short_name,json=shortName,proto3" json:"short_name,omitempty"`
	// Deprecated in Meshtastic 2.1.x
	// This is the addr of the radio.
	// Not populated by the phone, but added by the esp32 when broadcasting
	//
	// Deprecated: Marked as deprecated in meshtastic/mesh.proto.
	Macaddr []byte `protobuf:"bytes,4,opt,name=macaddr,proto3" json:"macaddr,omitempty"`
	// TBEAM, HELTEC, etc...
	// Starting in 1.2.11 moved to hw_model enum in the NodeInfo object.
	// Apps will still need the string here for older builds
	// (so OTA update can find the right image), but if the enum is available it will be used instead.
	HwModel HardwareModel `protobuf:"varint,5,opt,name=hw_model,json=hwModel,proto3,enum=meshtastic.HardwareModel" json:"hw_model,omitempty"`
	// In some regions Ham radio operators have different bandwidth limitations than others.
	// If this user is a licensed operator, set this flag.
	// Also, "long_name" should be their licence number.
	IsLicensed bool `protobuf:"varint,6,opt,name=is_licensed,json=isLicensed,proto3" json:"is_licensed,omitempty"`
	// Indicates that the user's role in the mesh
	Role Config_DeviceConfig_Role `protobuf:"varint,7,opt,name=role,proto3,enum=meshtastic.Config_DeviceConfig_Role" json:"role,omitempty"`
	// The public key of the user's device.
	// This is sent out to other nodes on the mesh to allow them to compute a shared secret key.
	PublicKey []byte `protobuf:"bytes,8,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
}

func (x *User) Reset() {
	*x = User{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *User) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*User) ProtoMessage() {}

func (x *User) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{1}
}

func (x *User) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *User) GetLongName() string {
	if x != nil {
		return x.LongName
	}
	return ""
}

func (x *User) GetShortName() string {
	if x != nil {
		return x.ShortName
	}
	return ""
}

// Deprecated: Marked as deprecated in meshtastic/mesh.proto.
func (x *User) GetMacaddr() []byte {
	if x != nil {
		return x.Macaddr
	}
	return nil
}

func (x *User) GetHwModel() HardwareModel {
	if x != nil {
		return x.HwModel
	}
	return HardwareModel_UNSET
}

func (x *User) GetIsLicensed() bool {
	if x != nil {
		return x.IsLicensed
	}
	return false
}

func (x *User) GetRole() Config_DeviceConfig_Role {
	if x != nil {
		return x.Role
	}
	return Config_DeviceConfig_CLIENT
}

func (x *User) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

// A message used in a traceroute
type RouteDiscovery struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The list of nodenums this packet has visited so far to the destination.
	Route []uint32 `protobuf:"fixed32,1,rep,packed,name=route,proto3" json:"route,omitempty"`
	// The list of SNRs (in dB, scaled by 4) in the route towards the destination.
	SnrTowards []int32 `protobuf:"varint,2,rep,packed,name=snr_towards,json=snrTowards,proto3" json:"snr_towards,omitempty"`
	// The list of nodenums the packet has visited on the way back from the destination.
	RouteBack []uint32 `protobuf:"fixed32,3,rep,packed,name=route_back,json=routeBack,proto3" json:"route_back,omitempty"`
	// The list of SNRs (in dB, scaled by 4) in the route back from the destination.
	SnrBack []int32 `protobuf:"varint,4,rep,packed,name=snr_back,json=snrBack,proto3" json:"snr_back,omitempty"`
}

func (x *RouteDiscovery) Reset() {
	*x = RouteDiscovery{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteDiscovery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteDiscovery) ProtoMessage() {}

func (x *RouteDiscovery) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteDiscovery.ProtoReflect.Descriptor instead.
func (*RouteDiscovery) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{2}
}

func (x *RouteDiscovery) GetRoute() []uint32 {
	if x != nil {
		return x.Route
	}
	return nil
}

func (x *RouteDiscovery) GetSnrTowards() []int32 {
	if x != nil {
		return x.SnrTowards
	}
	return nil
}

func (x *RouteDiscovery) GetRouteBack() []uint32 {
	if x != nil {
		return x.RouteBack
	}
	return nil
}

func (x *RouteDiscovery) GetSnrBack() []int32 {
	if x != nil {
		return x.SnrBack
	}
	return nil
}

// A Routing control Data packet handled by the routing module
type Routing struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Variant:
	//
	//	*Routing_RouteRequest
	//	*Routing_RouteReply
	//	*Routing_ErrorReason
	Variant isRouting_Variant `protobuf_oneof:"variant"`
}

func (x *Routing) Reset() {
	*x = Routing{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Routing) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Routing) ProtoMessage() {}

func (x *Routing) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Routing.ProtoReflect.Descriptor instead.
func (*Routing) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{3}
}

func (m *Routing) GetVariant() isRouting_Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

func (x *Routing) GetRouteRequest() *RouteDiscovery {
	if x, ok := x.GetVariant().(*Routing_RouteRequest); ok {
		return x.RouteRequest
	}
	return nil
}

func (x *Routing) GetRouteReply() *RouteDiscovery {
	if x, ok := x.GetVariant().(*Routing_RouteReply); ok {
		return x.RouteReply
	}
	return nil
}

func (x *Routing) GetErrorReason() Routing_Error {
	if x, ok := x.GetVariant().(*Routing_ErrorReason); ok {
		return x.ErrorReason
	}
	return Routing_NONE
}

type isRouting_Variant interface {
	isRouting_Variant()
}

type Routing_RouteRequest struct {
	// A route request going from the requester
	RouteRequest *RouteDiscovery `protobuf:"bytes,1,opt,name=route_request,json=routeRequest,proto3,oneof"`
}

type Routing_RouteReply struct {
	// A route reply
	RouteReply *RouteDiscovery `protobuf:"bytes,2,opt,name=route_reply,json=routeReply,proto3,oneof"`
}

type Routing_ErrorReason struct {
	// A failure in delivering a message (usually used for routing control messages, but might be provided
	// in addition to ack.fail_id to provide details on the type of failure).
	ErrorReason Routing_Error `protobuf:"varint,3,opt,name=error_reason,json=errorReason,proto3,enum=meshtastic.Routing_Error,oneof"`
}

func (*Routing_RouteRequest) isRouting_Variant() {}

func (*Routing_RouteReply) isRouting_Variant() {}

func (*Routing_ErrorReason) isRouting_Variant() {}

// (Formerly called SubPacket)
// The payload portion fo a packet, this is the actual bytes that are sent
// inside a radio packet (because from/to are broken out by the comms library)
type Data struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Formerly named typ and of type Type
	Portnum PortNum `protobuf:"varint,1,opt,name=portnum,proto3,enum=meshtastic.PortNum" json:"portnum,omitempty"`
	// TODO: REPLACE
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	// Not normally used, but for testing a sender can request that recipient
	// responds in kind (i.e. if it received a position, it should unicast back it's position).
	// Note: that if you set this on a broadcast you will receive many replies.
	WantResponse bool `protobuf:"varint,3,opt,name=want_response,json=wantResponse,proto3" json:"want_response,omitempty"`
	// The address of the destination node.
	// This field is is filled in by the mesh radio device software, application
	// layer software should never need it.
	// RouteDiscovery messages _must_ populate this.
	// Other message types might need to if they are doing multihop routing.
	Dest uint32 `protobuf:"fixed32,4,opt,name=dest,proto3" json:"dest,omitempty"`
	// The address of the original sender for this message.
	// This field should _only_ be populated for reliable multihop packets (to keep
	// packets small).
	Source uint32 `protobuf:"fixed32,5,opt,name=source,proto3" json:"source,omitempty"`
	// Only used in routing or response messages.
	// Indicates the original message ID that this message is reporting failure on. (formerly called original_id)
	RequestId uint32 `protobuf:"fixed32,6,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// If set, this message is intened to be a reply to a previously sent message with the defined id.
	ReplyId uint32 `protobuf:"fixed32,7,opt,name=reply_id,json=replyId,proto3" json:"reply_id,omitempty"`
	// Defaults to false. If true, then what is in the payload should be treated as an emoji like giving
	// a message a heart or poop emoji.
	Emoji uint32 `protobuf:"fixed32,8,opt,name=emoji,proto3" json:"emoji,omitempty"`
	// Bitfield for extra flags. First use is to indicate that user approves the packet being uploaded to MQTT.
	Bitfield *uint32 `protobuf:"varint,9,opt,name=bitfield,proto3,oneof" json:"bitfield,omitempty"`
}

func (x *Data) Reset() {
	*x = Data{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Data) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Data) ProtoMessage() {}

func (x *Data) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Data.ProtoReflect.Descriptor instead.
func (*Data) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{4}
}

func (x *Data) GetPortnum() PortNum {
	if x != nil {
		return x.Portnum
	}
	return PortNum_UNKNOWN_APP
}

func (x *Data) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *Data) GetWantResponse() bool {
	if x != nil {
		return x.WantResponse
	}
	return false
}

func (x *Data) GetDest() uint32 {
	if x != nil {
		return x.Dest
	}
	return 0
}

func (x *Data) GetSource() uint32 {
	if x != nil {
		return x.Source
	}
	return 0
}

func (x *Data) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *Data) GetReplyId() uint32 {
	if x != nil {
		return x.ReplyId
	}
	return 0
}

func (x *Data) GetEmoji() uint32 {
	if x != nil {
		return x.Emoji
	}
	return 0
}

func (x *Data) GetBitfield() uint32 {
	if x != nil && x.Bitfield != nil {
		return *x.Bitfield
	}
	return 0
}

// Waypoint message, used to share arbitrary locations across the mesh
type Waypoint struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Id of the waypoint
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// latitude_i
	LatitudeI *int32 `protobuf:"fixed32,2,opt,name=latitude_i,json=latitudeI,proto3,oneof" json:"latitude_i,omitempty"`
	// longitude_i
	LongitudeI *int32 `protobuf:"fixed32,3,opt,name=longitude_i,json=longitudeI,proto3,oneof" json:"longitude_i,omitempty"`
	// Time the waypoint is to expire (epoch)
	Expire uint32 `protobuf:"varint,4,opt,name=expire,proto3" json:"expire,omitempty"`
	// If greater than zero, treat the value as a nodenum only allowing them to update the waypoint.
	// If zero, the waypoint is open to be edited by any member of the mesh.
	LockedTo uint32 `protobuf:"varint,5,opt,name=locked_to,json=lockedTo,proto3" json:"locked_to,omitempty"`
	// Name of the waypoint - max 30 chars
	Name string `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the waypoint - max 100 chars
	Description string `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	// Designator icon for the waypoint in the form of a unicode emoji
	Icon uint32 `protobuf:"fixed32,8,opt,name=icon,proto3" json:"icon,omitempty"`
}

func (x *Waypoint) Reset() {
	*x = Waypoint{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Waypoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Waypoint) ProtoMessage() {}

func (x *Waypoint) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Waypoint.ProtoReflect.Descriptor instead.
func (*Waypoint) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{5}
}

func (x *Waypoint) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Waypoint) GetLatitudeI() int32 {
	if x != nil && x.LatitudeI != nil {
		return *x.LatitudeI
	}
	return 0
}

func (x *Waypoint) GetLongitudeI() int32 {
	if x != nil && x.LongitudeI != nil {
		return *x.LongitudeI
	}
	return 0
}

func (x *Waypoint) GetExpire() uint32 {
	if x != nil {
		return x.Expire
	}
	return 0
}

func (x *Waypoint) GetLockedTo() uint32 {
	if x != nil {
		return x.LockedTo
	}
	return 0
}

func (x *Waypoint) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Waypoint) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Waypoint) GetIcon() uint32 {
	if x != nil {
		return x.Icon
	}
	return 0
}

// This message will be proxied over the PhoneAPI for the client to deliver to the MQTT server
type MqttClientProxyMessage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The MQTT topic this message will be sent /received on
	Topic string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	// The actual service envelope payload or text for mqtt pub / sub
	//
	// Types that are assignable to PayloadVariant:
	//
	//	*MqttClientProxyMessage_Data
	//	*MqttClientProxyMessage_Text
	PayloadVariant isMqttClientProxyMessage_PayloadVariant `protobuf_oneof:"payload_variant"`
	// Whether the message should be retained (or not)
	Retained bool `protobuf:"varint,4,opt,name=retained,proto3" json:"retained,omitempty"`
}

func (x *MqttClientProxyMessage) Reset() {
	*x = MqttClientProxyMessage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MqttClientProxyMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MqttClientProxyMessage) ProtoMessage() {}

func (x *MqttClientProxyMessage) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MqttClientProxyMessage.ProtoReflect.Descriptor instead.
func (*MqttClientProxyMessage) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{6}
}

func (x *MqttClientProxyMessage) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (m *MqttClientProxyMessage) GetPayloadVariant() isMqttClientProxyMessage_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *MqttClientProxyMessage) GetData() []byte {
	if x, ok := x.GetPayloadVariant().(*MqttClientProxyMessage_Data); ok {
		return x.Data
	}
	return nil
}

func (x *MqttClientProxyMessage) GetText() string {
	if x, ok := x.GetPayloadVariant().(*MqttClientProxyMessage_Text); ok {
		return x.Text
	}
	return ""
}

func (x *MqttClientProxyMessage) GetRetained() bool {
	if x != nil {
		return x.Retained
	}
	return false
}

type isMqttClientProxyMessage_PayloadVariant interface {
	isMqttClientProxyMessage_PayloadVariant()
}

type MqttClientProxyMessage_Data struct {
	// Bytes
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

type MqttClientProxyMessage_Text struct {
	// Text
	Text string `protobuf:"bytes,3,opt,name=text,proto3,oneof"`
}

func (*MqttClientProxyMessage_Data) isMqttClientProxyMessage_PayloadVariant() {}

func (*MqttClientProxyMessage_Text) isMqttClientProxyMessage_PayloadVariant() {}

// A packet envelope sent/received over the mesh
// only payload_variant is sent in the payload portion of the LORA packet.
// The other fields are either not sent at all, or sent in the special 16 byte LORA header.
type MeshPacket struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The sending node number.
	// Note: Our crypto implementation uses this field as well.
	// See [crypto](/docs/overview/encryption) for details.
	From uint32 `protobuf:"fixed32,1,opt,name=from,proto3" json:"from,omitempty"`
	// The (immediate) destination for this packet
	To uint32 `protobuf:"fixed32,2,opt,name=to,proto3" json:"to,omitempty"`
	// (Usually) If set, this indicates the index in the secondary_channels table that this packet was sent/received on.
	// If unset, packet was on the primary channel.
	// A particular node might know only a subset of channels in use on the mesh.
	// Therefore channel_index is inherently a local concept and meaningless to send between nodes.
	// Very briefly, while sending and receiving deep inside the device Router code, this field instead
	// contains the 'channel hash' instead of the index.
	// This 'trick' is only used while the payload_variant is an 'encrypted'.
	Channel uint32 `protobuf:"varint,3,opt,name=channel,proto3" json:"channel,omitempty"`
	// Types that are assignable to PayloadVariant:
	//
	//	*MeshPacket_Decoded
	//	*MeshPacket_Encrypted
	PayloadVariant isMeshPacket_PayloadVariant `protobuf_oneof:"payload_variant"`
	// A unique ID for this packet.
	// Always 0 for no-ack packets or non broadcast packets (and therefore take zero bytes of space).
	// Otherwise a unique ID for this packet, useful for flooding algorithms.
	// ID only needs to be unique on a _per sender_ basis, and it only
	// needs to be unique for a few minutes (long enough to last for the length of
	// any ACK or the completion of a mesh broadcast flood).
	// Note: Our crypto implementation uses this id as well.
	// See [crypto](/docs/overview/encryption) for details.
	Id uint32 `protobuf:"fixed32,6,opt,name=id,proto3" json:"id,omitempty"`
	// The time this message was received by the esp32 (secs since 1970).
	// Note: this field is _never_ sent on the radio link itself (to save space) Times
	// are typically not sent over the mesh, but they will be added to any Packet
	// (chain of SubPacket) sent to the phone (so the phone can know exact time of reception)
	RxTime uint32 `protobuf:"fixed32,7,opt,name=rx_time,json=rxTime,proto3" json:"rx_time,omitempty"`
	// *Never* sent over the radio links.
	// Set during reception to indicate the SNR of this packet.
	// Used to collect statistics on current link quality.
	RxSnr float32 `protobuf:"fixed32,8,opt,name=rx_snr,json=rxSnr,proto3" json:"rx_snr,omitempty"`
	// If unset treated as zero (no forwarding, send to adjacent nodes only)
	// if 1, allow hopping through one node, etc...
	// For our usecase real world topologies probably have a max of about 3.
	// This field is normally placed into a few of bits in the header.
	HopLimit uint32 `protobuf:"varint,9,opt,name=hop_limit,json=hopLimit,proto3" json:"hop_limit,omitempty"`
	// This packet is being sent as a reliable message, we would prefer it to arrive at the destination.
	// We would like to receive a ack packet in response.
	// Broadcasts messages treat this flag specially: Since acks for broadcasts would
	// rapidly flood the channel, the normal ack behavior is suppressed.
	// Instead, the original sender listens to see if at least one node is rebroadcasting this packet (because naive flooding algorithm).
	// If it hears that the odds (given typical LoRa topologies) the odds are very high that every node should eventually receive the message.
	// So FloodingRouter.cpp generates an implicit ack which is delivered to the original sender.
	// If after some time we don't hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
	// Note: This flag is normally sent in a flag bit in the header when sent over the wire
	WantAck bool `protobuf:"varint,10,opt,name=want_ack,json=wantAck,proto3" json:"want_ack,omitempty"`
	// The priority of this message for sending.
	// See MeshPacket.Priority description for more details.
	Priority MeshPacket_Priority `protobuf:"varint,11,opt,name=priority,proto3,enum=meshtastic.MeshPacket_Priority" json:"priority,omitempty"`
	// rssi of received packet. Only sent to phone for dispay purposes.
	RxRssi int32 `protobuf:"varint,12,opt,name=rx_rssi,json=rxRssi,proto3" json:"rx_rssi,omitempty"`
	// Describe if this message is delayed
	//
	// Deprecated: Marked as deprecated in meshtastic/mesh.proto.
	Delayed MeshPacket_Delayed `protobuf:"varint,13,opt,name=delayed,proto3,enum=meshtastic.MeshPacket_Delayed" json:"delayed,omitempty"`
	// Describes whether this packet passed via MQTT somewhere along the path it currently took.
	ViaMqtt bool `protobuf:"varint,14,opt,name=via_mqtt,json=viaMqtt,proto3" json:"via_mqtt,omitempty"`
	// Hop limit with which the original packet started. Sent via LoRa using three bits in the unencrypted header.
	// When receiving a packet, the difference between hop_start and hop_limit gives how many hops it traveled.
	HopStart uint32 `protobuf:"varint,15,opt,name=hop_start,json=hopStart,proto3" json:"hop_start,omitempty"`
	// Records the public key the packet was encrypted with, if applicable.
	PublicKey []byte `protobuf:"bytes,16,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Indicates whether the packet was en/decrypted using PKI
	PkiEncrypted bool `protobuf:"varint,17,opt,name=pki_encrypted,json=pkiEncrypted,proto3" json:"pki_encrypted,omitempty"`
}

func (x *MeshPacket) Reset() {
	*x = MeshPacket{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MeshPacket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MeshPacket) ProtoMessage() {}

func (x *MeshPacket) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MeshPacket.ProtoReflect.Descriptor instead.
func (*MeshPacket) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{7}
}

func (x *MeshPacket) GetFrom() uint32 {
	if x != nil {
		return x.From
	}
	return 0
}

func (x *MeshPacket) GetTo() uint32 {
	if x != nil {
		return x.To
	}
	return 0
}

func (x *MeshPacket) GetChannel() uint32 {
	if x != nil {
		return x.Channel
	}
	return 0
}

func (m *MeshPacket) GetPayloadVariant() isMeshPacket_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *MeshPacket) GetDecoded() *Data {
	if x, ok := x.GetPayloadVariant().(*MeshPacket_Decoded); ok {
		return x.Decoded
	}
	return nil
}

func (x *MeshPacket) GetEncrypted() []byte {
	if x, ok := x.GetPayloadVariant().(*MeshPacket_Encrypted); ok {
		return x.Encrypted
	}
	return nil
}

func (x *MeshPacket) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *MeshPacket) GetRxTime() uint32 {
	if x != nil {
		return x.RxTime
	}
	return 0
}

func (x *MeshPacket) GetRxSnr() float32 {
	if x != nil {
		return x.RxSnr
	}
	return 0
}

func (x *MeshPacket) GetHopLimit() uint32 {
	if x != nil {
		return x.HopLimit
	}
	return 0
}

func (x *MeshPacket) GetWantAck() bool {
	if x != nil {
		return x.WantAck
	}
	return false
}

func (x *MeshPacket) GetPriority() MeshPacket_Priority {
	if x != nil {
		return x.Priority
	}
	return MeshPacket_UNSET
}

func (x *MeshPacket) GetRxRssi() int32 {
	if x != nil {
		return x.RxRssi
	}
	return 0
}

// Deprecated: Marked as deprecated in meshtastic/mesh.proto.
func (x *MeshPacket) GetDelayed() MeshPacket_Delayed {
	if x != nil {
		return x.Delayed
	}
	return MeshPacket_NO_DELAY
}

func (x *MeshPacket) GetViaMqtt() bool {
	if x != nil {
		return x.ViaMqtt
	}
	return false
}

func (x *MeshPacket) GetHopStart() uint32 {
	if x != nil {
		return x.HopStart
	}
	return 0
}

func (x *MeshPacket) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *MeshPacket) GetPkiEncrypted() bool {
	if x != nil {
		return x.PkiEncrypted
	}
	return false
}

type isMeshPacket_PayloadVariant interface {
	isMeshPacket_PayloadVariant()
}

type MeshPacket_Decoded struct {
	// TODO: REPLACE
	Decoded *Data `protobuf:"bytes,4,opt,name=decoded,proto3,oneof"`
}

type MeshPacket_Encrypted struct {
	// TODO: REPLACE
	Encrypted []byte `protobuf:"bytes,5,opt,name=encrypted,proto3,oneof"`
}

func (*MeshPacket_Decoded) isMeshPacket_PayloadVariant() {}

func (*MeshPacket_Encrypted) isMeshPacket_PayloadVariant() {}

// The bluetooth to device link:
// Old BTLE protocol docs from TODO, merge in above and make real docs...
// use protocol buffers, and NanoPB
// messages from device to phone:
// POSITION_UPDATE (..., time)
// TEXT_RECEIVED(from, text, time)
// OPAQUE_RECEIVED(from, payload, time) (for signal messages or other applications)
// messages from phone to device:
// SET_MYID(id, human readable long, human readable short) (send down the unique ID
// string used for this node, a human readable string shown for that id, and a very
// short human readable string suitable for oled screen) SEND_OPAQUE(dest, payload)
// (for signal messages or other applications) SEND_TEXT(dest, text) Get all
// nodes() (returns list of nodes, with full info, last time seen, loc, battery
// level etc) SET_CONFIG (switches device to a new set of radio params and
// preshared key, drops all existing nodes, force our node to rejoin this new group)
// Full information about a node on the mesh
type NodeInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The node number
	Num uint32 `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"`
	// The user info for this node
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// This position data. Note: before 1.2.14 we would also store the last time we've heard from this node in position.time, that is no longer true.
	// Position.time now indicates the last time we received a POSITION from that node.
	Position *Position `protobuf:"bytes,3,opt,name=position,proto3" json:"position,omitempty"`
	// Returns the Signal-to-noise ratio (SNR) of the last received message,
	// as measured by the receiver. Return SNR of the last received message in dB
	Snr float32 `protobuf:"fixed32,4,opt,name=snr,proto3" json:"snr,omitempty"`
	// Set to indicate the last time we received a packet from this node
	LastHeard uint32 `protobuf:"fixed32,5,opt,name=last_heard,json=lastHeard,proto3" json:"last_heard,omitempty"`
	// The latest device metrics for the node.
	DeviceMetrics *DeviceMetrics `protobuf:"bytes,6,opt,name=device_metrics,json=deviceMetrics,proto3" json:"device_metrics,omitempty"`
	// local channel index we heard that node on. Only populated if its not the default channel.
	Channel uint32 `protobuf:"varint,7,opt,name=channel,proto3" json:"channel,omitempty"`
	// True if we witnessed the node over MQTT instead of LoRA transport
	ViaMqtt bool `protobuf:"varint,8,opt,name=via_mqtt,json=viaMqtt,proto3" json:"via_mqtt,omitempty"`
	// Number of hops away from us this node is (0 if adjacent)
	HopsAway *uint32 `protobuf:"varint,9,opt,name=hops_away,json=hopsAway,proto3,oneof" json:"hops_away,omitempty"`
	// True if node is in our favorites list
	// Persists between NodeDB internal clean ups
	IsFavorite bool `protobuf:"varint,10,opt,name=is_favorite,json=isFavorite,proto3" json:"is_favorite,omitempty"`
}

func (x *NodeInfo) Reset() {
	*x = NodeInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeInfo) ProtoMessage() {}

func (x *NodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeInfo.ProtoReflect.Descriptor instead.
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{8}
}

func (x *NodeInfo) GetNum() uint32 {
	if x != nil {
		return x.Num
	}
	return 0
}

func (x *NodeInfo) GetUser() *User {
	if x != nil {
		return x.User
	}
	return nil
}

func (x *NodeInfo) GetPosition() *Position {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *NodeInfo) GetSnr() float32 {
	if x != nil {
		return x.Snr
	}
	return 0
}

func (x *NodeInfo) GetLastHeard() uint32 {
	if x != nil {
		return x.LastHeard
	}
	return 0
}

func (x *NodeInfo) GetDeviceMetrics() *DeviceMetrics {
	if x != nil {
		return x.DeviceMetrics
	}
	return nil
}

func (x *NodeInfo) GetChannel() uint32 {
	if x != nil {
		return x.Channel
	}
	return 0
}

func (x *NodeInfo) GetViaMqtt() bool {
	if x != nil {
		return x.ViaMqtt
	}
	return false
}

func (x *NodeInfo) GetHopsAway() uint32 {
	if x != nil && x.HopsAway != nil {
		return *x.HopsAway
	}
	return 0
}

func (x *NodeInfo) GetIsFavorite() bool {
	if x != nil {
		return x.IsFavorite
	}
	return false
}

// Unique local debugging info for this node
// Note: we don't include position or the user info, because that will come in the
// Sent to the phone in response to WantNodes.
type MyNodeInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Tells the phone what our node number is, default starting value is
	// lowbyte of macaddr, but it will be fixed if that is already in use
	MyNodeNum uint32 `protobuf:"varint,1,opt,name=my_node_num,json=myNodeNum,proto3" json:"my_node_num,omitempty"`
	// The total number of reboots this node has ever encountered
	// (well - since the last time we discarded preferences)
	RebootCount uint32 `protobuf:"varint,8,opt,name=reboot_count,json=rebootCount,proto3" json:"reboot_count,omitempty"`
	// The minimum app version that can talk to this device.
	// Phone/PC apps should compare this to their build number and if too low tell the user they must update their app
	MinAppVersion uint32 `protobuf:"varint,11,opt,name=min_app_version,json=minAppVersion,proto3" json:"min_app_version,omitempty"`
}

func (x *MyNodeInfo) Reset() {
	*x = MyNodeInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MyNodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MyNodeInfo) ProtoMessage() {}

func (x *MyNodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MyNodeInfo.ProtoReflect.Descriptor instead.
func (*MyNodeInfo) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{9}
}

func (x *MyNodeInfo) GetMyNodeNum() uint32 {
	if x != nil {
		return x.MyNodeNum
	}
	return 0
}

func (x *MyNodeInfo) GetRebootCount() uint32 {
	if x != nil {
		return x.RebootCount
	}
	return 0
}

func (x *MyNodeInfo) GetMinAppVersion() uint32 {
	if x != nil {
		return x.MinAppVersion
	}
	return 0
}

// Debug output from the device.
// To minimize the size of records inside the device code, if a time/source/level is not set
// on the message it is assumed to be a continuation of the previously sent message.
// This allows the device code to use fixed maxlen 64 byte strings for messages,
// and then extend as needed by emitting multiple records.
type LogRecord struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Log levels, chosen to match python logging conventions.
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	// Seconds since 1970 - or 0 for unknown/unset
	Time uint32 `protobuf:"fixed32,2,opt,name=time,proto3" json:"time,omitempty"`
	// Usually based on thread name - if known
	Source string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	// Not yet set
	Level LogRecord_Level `protobuf:"varint,4,opt,name=level,proto3,enum=meshtastic.LogRecord_Level" json:"level,omitempty"`
}

func (x *LogRecord) Reset() {
	*x = LogRecord{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LogRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogRecord) ProtoMessage() {}

func (x *LogRecord) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogRecord.ProtoReflect.Descriptor instead.
func (*LogRecord) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{10}
}

func (x *LogRecord) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *LogRecord) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *LogRecord) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *LogRecord) GetLevel() LogRecord_Level {
	if x != nil {
		return x.Level
	}
	return LogRecord_UNSET
}

type QueueStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Last attempt to queue status, ErrorCode
	Res int32 `protobuf:"varint,1,opt,name=res,proto3" json:"res,omitempty"`
	// Free entries in the outgoing queue
	Free uint32 `protobuf:"varint,2,opt,name=free,proto3" json:"free,omitempty"`
	// Maximum entries in the outgoing queue
	Maxlen uint32 `protobuf:"varint,3,opt,name=maxlen,proto3" json:"maxlen,omitempty"`
	// What was mesh packet id that generated this response?
	MeshPacketId uint32 `protobuf:"varint,4,opt,name=mesh_packet_id,json=meshPacketId,proto3" json:"mesh_packet_id,omitempty"`
}

func (x *QueueStatus) Reset() {
	*x = QueueStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QueueStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueueStatus) ProtoMessage() {}

func (x *QueueStatus) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueueStatus.ProtoReflect.Descriptor instead.
func (*QueueStatus) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{11}
}

func (x *QueueStatus) GetRes() int32 {
	if x != nil {
		return x.Res
	}
	return 0
}

func (x *QueueStatus) GetFree() uint32 {
	if x != nil {
		return x.Free
	}
	return 0
}

func (x *QueueStatus) GetMaxlen() uint32 {
	if x != nil {
		return x.Maxlen
	}
	return 0
}

func (x *QueueStatus) GetMeshPacketId() uint32 {
	if x != nil {
		return x.MeshPacketId
	}
	return 0
}

// Packets from the radio to the phone will appear on the fromRadio characteristic.
// It will support READ and NOTIFY. When a new packet arrives the device will BLE notify?
// It will sit in that descriptor until consumed by the phone,
// at which point the next item in the FIFO will be populated.
type FromRadio struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The packet id, used to allow the phone to request missing read packets from the FIFO,
	// see our bluetooth docs
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Log levels, chosen to match python logging conventions.
	//
	// Types that are assignable to PayloadVariant:
	//
	//	*FromRadio_Packet
	//	*FromRadio_MyInfo
	//	*FromRadio_NodeInfo
	//	*FromRadio_Config
	//	*FromRadio_LogRecord
	//	*FromRadio_ConfigCompleteId
	//	*FromRadio_Rebooted
	//	*FromRadio_ModuleConfig
	//	*FromRadio_Channel
	//	*FromRadio_QueueStatus
	//	*FromRadio_XmodemPacket
	//	*FromRadio_Metadata
	//	*FromRadio_MqttClientProxyMessage
	//	*FromRadio_FileInfo
	//	*FromRadio_ClientNotification
	PayloadVariant isFromRadio_PayloadVariant `protobuf_oneof:"payload_variant"`
}

func (x *FromRadio) Reset() {
	*x = FromRadio{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FromRadio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FromRadio) ProtoMessage() {}

func (x *FromRadio) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FromRadio.ProtoReflect.Descriptor instead.
func (*FromRadio) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{12}
}

func (x *FromRadio) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (m *FromRadio) GetPayloadVariant() isFromRadio_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *FromRadio) GetPacket() *MeshPacket {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Packet); ok {
		return x.Packet
	}
	return nil
}

func (x *FromRadio) GetMyInfo() *MyNodeInfo {
	if x, ok := x.GetPayloadVariant().(*FromRadio_MyInfo); ok {
		return x.MyInfo
	}
	return nil
}

func (x *FromRadio) GetNodeInfo() *NodeInfo {
	if x, ok := x.GetPayloadVariant().(*FromRadio_NodeInfo); ok {
		return x.NodeInfo
	}
	return nil
}

func (x *FromRadio) GetConfig() *Config {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Config); ok {
		return x.Config
	}
	return nil
}

func (x *FromRadio) GetLogRecord() *LogRecord {
	if x, ok := x.GetPayloadVariant().(*FromRadio_LogRecord); ok {
		return x.LogRecord
	}
	return nil
}

func (x *FromRadio) GetConfigCompleteId() uint32 {
	if x, ok := x.GetPayloadVariant().(*FromRadio_ConfigCompleteId); ok {
		return x.ConfigCompleteId
	}
	return 0
}

func (x *FromRadio) GetRebooted() bool {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Rebooted); ok {
		return x.Rebooted
	}
	return false
}

func (x *FromRadio) GetModuleConfig() *ModuleConfig {
	if x, ok := x.GetPayloadVariant().(*FromRadio_ModuleConfig); ok {
		return x.ModuleConfig
	}
	return nil
}

func (x *FromRadio) GetChannel() *Channel {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Channel); ok {
		return x.Channel
	}
	return nil
}

func (x *FromRadio) GetQueueStatus() *QueueStatus {
	if x, ok := x.GetPayloadVariant().(*FromRadio_QueueStatus); ok {
		return x.QueueStatus
	}
	return nil
}

func (x *FromRadio) GetXmodemPacket() *XModem {
	if x, ok := x.GetPayloadVariant().(*FromRadio_XmodemPacket); ok {
		return x.XmodemPacket
	}
	return nil
}

func (x *FromRadio) GetMetadata() *DeviceMetadata {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Metadata); ok {
		return x.Metadata
	}
	return nil
}

func (x *FromRadio) GetMqttClientProxyMessage() *MqttClientProxyMessage {
	if x, ok := x.GetPayloadVariant().(*FromRadio_MqttClientProxyMessage); ok {
		return x.MqttClientProxyMessage
	}
	return nil
}

func (x *FromRadio) GetFileInfo() *FileInfo {
	if x, ok := x.GetPayloadVariant().(*FromRadio_FileInfo); ok {
		return x.FileInfo
	}
	return nil
}

func (x *FromRadio) GetClientNotification() *ClientNotification {
	if x, ok := x.GetPayloadVariant().(*FromRadio_ClientNotification); ok {
		return x.ClientNotification
	}
	return nil
}

type isFromRadio_PayloadVariant interface {
	isFromRadio_PayloadVariant()
}

type FromRadio_Packet struct {
	// Log levels, chosen to match python logging conventions.
	Packet *MeshPacket `protobuf:"bytes,2,opt,name=packet,proto3,oneof"`
}

type FromRadio_MyInfo struct {
	// Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
	// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
	MyInfo *MyNodeInfo `protobuf:"bytes,3,opt,name=my_info,json=myInfo,proto3,oneof"`
}

type FromRadio_NodeInfo struct {
	// One packet is sent for each node in the on radio DB
	// starts over with the first node in our DB
	NodeInfo *NodeInfo `protobuf:"bytes,4,opt,name=node_info,json=nodeInfo,proto3,oneof"`
}

type FromRadio_Config struct {
	// Include a part of the config (was: RadioConfig radio)
	Config *Config `protobuf:"bytes,5,opt,name=config,proto3,oneof"`
}

type FromRadio_LogRecord struct {
	// Set to send debug console output over our protobuf stream
	LogRecord *LogRecord `protobuf:"bytes,6,opt,name=log_record,json=logRecord,proto3,oneof"`
}

type FromRadio_ConfigCompleteId struct {
	// Sent as true once the device has finished sending all of the responses to want_config
	// recipient should check if this ID matches our original request nonce, if
	// not, it means your config responses haven't started yet.
	// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
	ConfigCompleteId uint32 `protobuf:"varint,7,opt,name=config_complete_id,json=configCompleteId,proto3,oneof"`
}

type FromRadio_Rebooted struct {
	// Sent to tell clients the radio has just rebooted.
	// Set to true if present.
	// Not used on all transports, currently just used for the serial console.
	// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
	Rebooted bool `protobuf:"varint,8,opt,name=rebooted,proto3,oneof"`
}

type FromRadio_ModuleConfig struct {
	// Include module config
	ModuleConfig *ModuleConfig `protobuf:"bytes,9,opt,name=moduleConfig,proto3,oneof"`
}

type FromRadio_Channel struct {
	// One packet is sent for each channel
	Channel *Channel `protobuf:"bytes,10,opt,name=channel,proto3,oneof"`
}

type FromRadio_QueueStatus struct {
	// Queue status info
	QueueStatus *QueueStatus `protobuf:"bytes,11,opt,name=queueStatus,proto3,oneof"`
}

type FromRadio_XmodemPacket struct {
	// File Transfer Chunk
	XmodemPacket *XModem `protobuf:"bytes,12,opt,name=xmodemPacket,proto3,oneof"`
}

type FromRadio_Metadata struct {
	// Device metadata message
	Metadata *DeviceMetadata `protobuf:"bytes,13,opt,name=metadata,proto3,oneof"`
}

type FromRadio_MqttClientProxyMessage struct {
	// MQTT Client Proxy Message (device sending to client / phone for publishing to MQTT)
	MqttClientProxyMessage *MqttClientProxyMessage `protobuf:"bytes,14,opt,name=mqttClientProxyMessage,proto3,oneof"`
}

type FromRadio_FileInfo struct {
	// File system manifest messages
	FileInfo *FileInfo `protobuf:"bytes,15,opt,name=fileInfo,proto3,oneof"`
}

type FromRadio_ClientNotification struct {
	// Notification message to the client
	ClientNotification *ClientNotification `protobuf:"bytes,16,opt,name=clientNotification,proto3,oneof"`
}

func (*FromRadio_Packet) isFromRadio_PayloadVariant() {}

func (*FromRadio_MyInfo) isFromRadio_PayloadVariant() {}

func (*FromRadio_NodeInfo) isFromRadio_PayloadVariant() {}

func (*FromRadio_Config) isFromRadio_PayloadVariant() {}

func (*FromRadio_LogRecord) isFromRadio_PayloadVariant() {}

func (*FromRadio_ConfigCompleteId) isFromRadio_PayloadVariant() {}

func (*FromRadio_Rebooted) isFromRadio_PayloadVariant() {}

func (*FromRadio_ModuleConfig) isFromRadio_PayloadVariant() {}

func (*FromRadio_Channel) isFromRadio_PayloadVariant() {}

func (*FromRadio_QueueStatus) isFromRadio_PayloadVariant() {}

func (*FromRadio_XmodemPacket) isFromRadio_PayloadVariant() {}

func (*FromRadio_Metadata) isFromRadio_PayloadVariant() {}

func (*FromRadio_MqttClientProxyMessage) isFromRadio_PayloadVariant() {}

func (*FromRadio_FileInfo) isFromRadio_PayloadVariant() {}

func (*FromRadio_ClientNotification) isFromRadio_PayloadVariant() {}

// A notification message from the device to the client
// To be used for important messages that should to be displayed to the user
// in the form of push notifications or validation messages when saving
// invalid configuration.
type ClientNotification struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The id of the packet we're notifying in response to
	ReplyId *uint32 `protobuf:"varint,1,opt,name=reply_id,json=replyId,proto3,oneof" json:"reply_id,omitempty"`
	// Seconds since 1970 - or 0 for unknown/unset
	Time uint32 `protobuf:"fixed32,2,opt,name=time,proto3" json:"time,omitempty"`
	// The level type of notification
	Level LogRecord_Level `protobuf:"varint,3,opt,name=level,proto3,enum=meshtastic.LogRecord_Level" json:"level,omitempty"`
	// The message body of the notification
	Message string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *ClientNotification) Reset() {
	*x = ClientNotification{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ClientNotification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientNotification) ProtoMessage() {}

func (x *ClientNotification) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientNotification.ProtoReflect.Descriptor instead.
func (*ClientNotification) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{13}
}

func (x *ClientNotification) GetReplyId() uint32 {
	if x != nil && x.ReplyId != nil {
		return *x.ReplyId
	}
	return 0
}

func (x *ClientNotification) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *ClientNotification) GetLevel() LogRecord_Level {
	if x != nil {
		return x.Level
	}
	return LogRecord_UNSET
}

func (x *ClientNotification) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// Individual File info for the device
type FileInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The fully qualified path of the file
	FileName string `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	// The size of the file in bytes
	SizeBytes uint32 `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
}

func (x *FileInfo) Reset() {
	*x = FileInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FileInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileInfo) ProtoMessage() {}

func (x *FileInfo) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileInfo.ProtoReflect.Descriptor instead.
func (*FileInfo) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{14}
}

func (x *FileInfo) GetFileName() string {
	if x != nil {
		return x.FileName
	}
	return ""
}

func (x *FileInfo) GetSizeBytes() uint32 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

// Packets/commands to the radio will be written (reliably) to the toRadio characteristic.
// Once the write completes the phone can assume it is handled.
type ToRadio struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Log levels, chosen to match python logging conventions.
	//
	// Types that are assignable to PayloadVariant:
	//
	//	*ToRadio_Packet
	//	*ToRadio_WantConfigId
	//	*ToRadio_Disconnect
	//	*ToRadio_XmodemPacket
	//	*ToRadio_MqttClientProxyMessage
	//	*ToRadio_Heartbeat
	PayloadVariant isToRadio_PayloadVariant `protobuf_oneof:"payload_variant"`
}

func (x *ToRadio) Reset() {
	*x = ToRadio{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ToRadio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToRadio) ProtoMessage() {}

func (x *ToRadio) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToRadio.ProtoReflect.Descriptor instead.
func (*ToRadio) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{15}
}

func (m *ToRadio) GetPayloadVariant() isToRadio_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *ToRadio) GetPacket() *MeshPacket {
	if x, ok := x.GetPayloadVariant().(*ToRadio_Packet); ok {
		return x.Packet
	}
	return nil
}

func (x *ToRadio) GetWantConfigId() uint32 {
	if x, ok := x.GetPayloadVariant().(*ToRadio_WantConfigId); ok {
		return x.WantConfigId
	}
	return 0
}

func (x *ToRadio) GetDisconnect() bool {
	if x, ok := x.GetPayloadVariant().(*ToRadio_Disconnect); ok {
		return x.Disconnect
	}
	return false
}

func (x *ToRadio) GetXmodemPacket() *XModem {
	if x, ok := x.GetPayloadVariant().(*ToRadio_XmodemPacket); ok {
		return x.XmodemPacket
	}
	return nil
}

func (x *ToRadio) GetMqttClientProxyMessage() *MqttClientProxyMessage {
	if x, ok := x.GetPayloadVariant().(*ToRadio_MqttClientProxyMessage); ok {
		return x.MqttClientProxyMessage
	}
	return nil
}

func (x *ToRadio) GetHeartbeat() *Heartbeat {
	if x, ok := x.GetPayloadVariant().(*ToRadio_Heartbeat); ok {
		return x.Heartbeat
	}
	return nil
}

type isToRadio_PayloadVariant interface {
	isToRadio_PayloadVariant()
}

type ToRadio_Packet struct {
	// Send this packet on the mesh
	Packet *MeshPacket `protobuf:"bytes,1,opt,name=packet,proto3,oneof"`
}

type ToRadio_WantConfigId struct {
	// Phone wants radio to send full node db to the phone, This is
	// typically the first packet sent to the radio when the phone gets a
	// bluetooth connection. The radio will respond by sending back a
	// MyNodeInfo, a owner, a radio config and a series of
	// FromRadio.node_infos, and config_complete
	// the integer you write into this field will be reported back in the
	// config_complete_id response this allows clients to never be confused by
	// a stale old partially sent config.
	WantConfigId uint32 `protobuf:"varint,3,opt,name=want_config_id,json=wantConfigId,proto3,oneof"`
}

type ToRadio_Disconnect struct {
	// Tell API server we are disconnecting now.
	// This is useful for serial links where there is no hardware/protocol based notification that the client has dropped the link.
	// (Sending this message is optional for clients)
	Disconnect bool `protobuf:"varint,4,opt,name=disconnect,proto3,oneof"`
}

type ToRadio_XmodemPacket struct {
	XmodemPacket *XModem `protobuf:"bytes,5,opt,name=xmodemPacket,proto3,oneof"`
}

type ToRadio_MqttClientProxyMessage struct {
	// MQTT Client Proxy Message (for client / phone subscribed to MQTT sending to device)
	MqttClientProxyMessage *MqttClientProxyMessage `protobuf:"bytes,6,opt,name=mqttClientProxyMessage,proto3,oneof"`
}

type ToRadio_Heartbeat struct {
	// Heartbeat message (used to keep the device connection awake on serial)
	Heartbeat *Heartbeat `protobuf:"bytes,7,opt,name=heartbeat,proto3,oneof"`
}

func (*ToRadio_Packet) isToRadio_PayloadVariant() {}

func (*ToRadio_WantConfigId) isToRadio_PayloadVariant() {}

func (*ToRadio_Disconnect) isToRadio_PayloadVariant() {}

func (*ToRadio_XmodemPacket) isToRadio_PayloadVariant() {}

func (*ToRadio_MqttClientProxyMessage) isToRadio_PayloadVariant() {}

func (*ToRadio_Heartbeat) isToRadio_PayloadVariant() {}

// Compressed message payload
type Compressed struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// PortNum to determine the how to handle the compressed payload.
	Portnum PortNum `protobuf:"varint,1,opt,name=portnum,proto3,enum=meshtastic.PortNum" json:"portnum,omitempty"`
	// Compressed data.
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (x *Compressed) Reset() {
	*x = Compressed{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Compressed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Compressed) ProtoMessage() {}

func (x *Compressed) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Compressed.ProtoReflect.Descriptor instead.
func (*Compressed) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{16}
}

func (x *Compressed) GetPortnum() PortNum {
	if x != nil {
		return x.Portnum
	}
	return PortNum_UNKNOWN_APP
}

func (x *Compressed) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

// Full info on edges for a single node
type NeighborInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The node ID of the node sending info on its neighbors
	NodeId uint32 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Field to pass neighbor info for the next sending cycle
	LastSentById uint32 `protobuf:"varint,2,opt,name=last_sent_by_id,json=lastSentById,proto3" json:"last_sent_by_id,omitempty"`
	// Broadcast interval of the represented node (in seconds)
	NodeBroadcastIntervalSecs uint32 `protobuf:"varint,3,opt,name=node_broadcast_interval_secs,json=nodeBroadcastIntervalSecs,proto3" json:"node_broadcast_interval_secs,omitempty"`
	// The list of out edges from this node
	Neighbors []*Neighbor `protobuf:"bytes,4,rep,name=neighbors,proto3" json:"neighbors,omitempty"`
}

func (x *NeighborInfo) Reset() {
	*x = NeighborInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NeighborInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NeighborInfo) ProtoMessage() {}

func (x *NeighborInfo) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NeighborInfo.ProtoReflect.Descriptor instead.
func (*NeighborInfo) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{17}
}

func (x *NeighborInfo) GetNodeId() uint32 {
	if x != nil {
		return x.NodeId
	}
	return 0
}

func (x *NeighborInfo) GetLastSentById() uint32 {
	if x != nil {
		return x.LastSentById
	}
	return 0
}

func (x *NeighborInfo) GetNodeBroadcastIntervalSecs() uint32 {
	if x != nil {
		return x.NodeBroadcastIntervalSecs
	}
	return 0
}

func (x *NeighborInfo) GetNeighbors() []*Neighbor {
	if x != nil {
		return x.Neighbors
	}
	return nil
}

// A single edge in the mesh
type Neighbor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Node ID of neighbor
	NodeId uint32 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// SNR of last heard message
	Snr float32 `protobuf:"fixed32,2,opt,name=snr,proto3" json:"snr,omitempty"`
	// Reception time (in secs since 1970) of last message that was last sent by this ID.
	// Note: this is for local storage only and will not be sent out over the mesh.
	LastRxTime uint32 `protobuf:"fixed32,3,opt,name=last_rx_time,json=lastRxTime,proto3" json:"last_rx_time,omitempty"`
	// Broadcast interval of this neighbor (in seconds).
	// Note: this is for local storage only and will not be sent out over the mesh.
	NodeBroadcastIntervalSecs uint32 `protobuf:"varint,4,opt,name=node_broadcast_interval_secs,json=nodeBroadcastIntervalSecs,proto3" json:"node_broadcast_interval_secs,omitempty"`
}

func (x *Neighbor) Reset() {
	*x = Neighbor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Neighbor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Neighbor) ProtoMessage() {}

func (x *Neighbor) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Neighbor.ProtoReflect.Descriptor instead.
func (*Neighbor) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{18}
}

func (x *Neighbor) GetNodeId() uint32 {
	if x != nil {
		return x.NodeId
	}
	return 0
}

func (x *Neighbor) GetSnr() float32 {
	if x != nil {
		return x.Snr
	}
	return 0
}

func (x *Neighbor) GetLastRxTime() uint32 {
	if x != nil {
		return x.LastRxTime
	}
	return 0
}

func (x *Neighbor) GetNodeBroadcastIntervalSecs() uint32 {
	if x != nil {
		return x.NodeBroadcastIntervalSecs
	}
	return 0
}

// Device metadata response
type DeviceMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Device firmware version string
	FirmwareVersion string `protobuf:"bytes,1,opt,name=firmware_version,json=firmwareVersion,proto3" json:"firmware_version,omitempty"`
	// Device state version
	DeviceStateVersion uint32 `protobuf:"varint,2,opt,name=device_state_version,json=deviceStateVersion,proto3" json:"device_state_version,omitempty"`
	// Indicates whether the device can shutdown CPU natively or via power management chip
	CanShutdown bool `protobuf:"varint,3,opt,name=canShutdown,proto3" json:"canShutdown,omitempty"`
	// Indicates that the device has native wifi capability
	HasWifi bool `protobuf:"varint,4,opt,name=hasWifi,proto3" json:"hasWifi,omitempty"`
	// Indicates that the device has native bluetooth capability
	HasBluetooth bool `protobuf:"varint,5,opt,name=hasBluetooth,proto3" json:"hasBluetooth,omitempty"`
	// Indicates that the device has an ethernet peripheral
	HasEthernet bool `protobuf:"varint,6,opt,name=hasEthernet,proto3" json:"hasEthernet,omitempty"`
	// Indicates that the device's role in the mesh
	Role Config_DeviceConfig_Role `protobuf:"varint,7,opt,name=role,proto3,enum=meshtastic.Config_DeviceConfig_Role" json:"role,omitempty"`
	// Indicates the device's current enabled position flags
	PositionFlags uint32 `protobuf:"varint,8,opt,name=position_flags,json=positionFlags,proto3" json:"position_flags,omitempty"`
	// Device hardware model
	HwModel HardwareModel `protobuf:"varint,9,opt,name=hw_model,json=hwModel,proto3,enum=meshtastic.HardwareModel" json:"hw_model,omitempty"`
	// Has Remote Hardware enabled
	HasRemoteHardware bool `protobuf:"varint,10,opt,name=hasRemoteHardware,proto3" json:"hasRemoteHardware,omitempty"`
	// Has PKC capabilities
	HasPKC bool `protobuf:"varint,11,opt,name=hasPKC,proto3" json:"hasPKC,omitempty"`
}

func (x *DeviceMetadata) Reset() {
	*x = DeviceMetadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DeviceMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeviceMetadata) ProtoMessage() {}

func (x *DeviceMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeviceMetadata.ProtoReflect.Descriptor instead.
func (*DeviceMetadata) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{19}
}

func (x *DeviceMetadata) GetFirmwareVersion() string {
	if x != nil {
		return x.FirmwareVersion
	}
	return ""
}

func (x *DeviceMetadata) GetDeviceStateVersion() uint32 {
	if x != nil {
		return x.DeviceStateVersion
	}
	return 0
}

func (x *DeviceMetadata) GetCanShutdown() bool {
	if x != nil {
		return x.CanShutdown
	}
	return false
}

func (x *DeviceMetadata) GetHasWifi() bool {
	if x != nil {
		return x.HasWifi
	}
	return false
}

func (x *DeviceMetadata) GetHasBluetooth() bool {
	if x != nil {
		return x.HasBluetooth
	}
	return false
}

func (x *DeviceMetadata) GetHasEthernet() bool {
	if x != nil {
		return x.HasEthernet
	}
	return false
}

func (x *DeviceMetadata) GetRole() Config_DeviceConfig_Role {
	if x != nil {
		return x.Role
	}
	return Config_DeviceConfig_CLIENT
}

func (x *DeviceMetadata) GetPositionFlags() uint32 {
	if x != nil {
		return x.PositionFlags
	}
	return 0
}

func (x *DeviceMetadata) GetHwModel() HardwareModel {
	if x != nil {
		return x.HwModel
	}
	return HardwareModel_UNSET
}

func (x *DeviceMetadata) GetHasRemoteHardware() bool {
	if x != nil {
		return x.HasRemoteHardware
	}
	return false
}

func (x *DeviceMetadata) GetHasPKC() bool {
	if x != nil {
		return x.HasPKC
	}
	return false
}

// A heartbeat message is sent to the node from the client to keep the connection alive.
// This is currently only needed to keep serial connections alive, but can be used by any PhoneAPI.
type Heartbeat struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *Heartbeat) Reset() {
	*x = Heartbeat{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Heartbeat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Heartbeat) ProtoMessage() {}

func (x *Heartbeat) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Heartbeat.ProtoReflect.Descriptor instead.
func (*Heartbeat) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{20}
}

// RemoteHardwarePins associated with a node
type NodeRemoteHardwarePin struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The node_num exposing the available gpio pin
	NodeNum uint32 `protobuf:"varint,1,opt,name=node_num,json=nodeNum,proto3" json:"node_num,omitempty"`
	// The the available gpio pin for usage with RemoteHardware module
	Pin *RemoteHardwarePin `protobuf:"bytes,2,opt,name=pin,proto3" json:"pin,omitempty"`
}

func (x *NodeRemoteHardwarePin) Reset() {
	*x = NodeRemoteHardwarePin{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NodeRemoteHardwarePin) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeRemoteHardwarePin) ProtoMessage() {}

func (x *NodeRemoteHardwarePin) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeRemoteHardwarePin.ProtoReflect.Descriptor instead.
func (*NodeRemoteHardwarePin) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{21}
}

func (x *NodeRemoteHardwarePin) GetNodeNum() uint32 {
	if x != nil {
		return x.NodeNum
	}
	return 0
}

func (x *NodeRemoteHardwarePin) GetPin() *RemoteHardwarePin {
	if x != nil {
		return x.Pin
	}
	return nil
}

type ChunkedPayload struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The ID of the entire payload
	PayloadId uint32 `protobuf:"varint,1,opt,name=payload_id,json=payloadId,proto3" json:"payload_id,omitempty"`
	// The total number of chunks in the payload
	ChunkCount uint32 `protobuf:"varint,2,opt,name=chunk_count,json=chunkCount,proto3" json:"chunk_count,omitempty"`
	// The current chunk index in the total
	ChunkIndex uint32 `protobuf:"varint,3,opt,name=chunk_index,json=chunkIndex,proto3" json:"chunk_index,omitempty"`
	// The binary data of the current chunk
	PayloadChunk []byte `protobuf:"bytes,4,opt,name=payload_chunk,json=payloadChunk,proto3" json:"payload_chunk,omitempty"`
}

func (x *ChunkedPayload) Reset() {
	*x = ChunkedPayload{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ChunkedPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChunkedPayload) ProtoMessage() {}

func (x *ChunkedPayload) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChunkedPayload.ProtoReflect.Descriptor instead.
func (*ChunkedPayload) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{22}
}

func (x *ChunkedPayload) GetPayloadId() uint32 {
	if x != nil {
		return x.PayloadId
	}
	return 0
}

func (x *ChunkedPayload) GetChunkCount() uint32 {
	if x != nil {
		return x.ChunkCount
	}
	return 0
}

func (x *ChunkedPayload) GetChunkIndex() uint32 {
	if x != nil {
		return x.ChunkIndex
	}
	return 0
}

func (x *ChunkedPayload) GetPayloadChunk() []byte {
	if x != nil {
		return x.PayloadChunk
	}
	return nil
}

// Wrapper message for broken repeated oneof support
type ResendChunks struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Chunks []uint32 `protobuf:"varint,1,rep,packed,name=chunks,proto3" json:"chunks,omitempty"`
}

func (x *ResendChunks) Reset() {
	*x = ResendChunks{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ResendChunks) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResendChunks) ProtoMessage() {}

func (x *ResendChunks) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResendChunks.ProtoReflect.Descriptor instead.
func (*ResendChunks) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{23}
}

func (x *ResendChunks) GetChunks() []uint32 {
	if x != nil {
		return x.Chunks
	}
	return nil
}

// Responses to a ChunkedPayload request
type ChunkedPayloadResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The ID of the entire payload
	PayloadId uint32 `protobuf:"varint,1,opt,name=payload_id,json=payloadId,proto3" json:"payload_id,omitempty"`
	// Types that are assignable to PayloadVariant:
	//
	//	*ChunkedPayloadResponse_RequestTransfer
	//	*ChunkedPayloadResponse_AcceptTransfer
	//	*ChunkedPayloadResponse_ResendChunks
	PayloadVariant isChunkedPayloadResponse_PayloadVariant `protobuf_oneof:"payload_variant"`
}

func (x *ChunkedPayloadResponse) Reset() {
	*x = ChunkedPayloadResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_meshtastic_mesh_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ChunkedPayloadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChunkedPayloadResponse) ProtoMessage() {}

func (x *ChunkedPayloadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChunkedPayloadResponse.ProtoReflect.Descriptor instead.
func (*ChunkedPayloadResponse) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{24}
}

func (x *ChunkedPayloadResponse) GetPayloadId() uint32 {
	if x != nil {
		return x.PayloadId
	}
	return 0
}

func (m *ChunkedPayloadResponse) GetPayloadVariant() isChunkedPayloadResponse_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *ChunkedPayloadResponse) GetRequestTransfer() bool {
	if x, ok := x.GetPayloadVariant().(*ChunkedPayloadResponse_RequestTransfer); ok {
		return x.RequestTransfer
	}
	return false
}

func (x *ChunkedPayloadResponse) GetAcceptTransfer() bool {
	if x, ok := x.GetPayloadVariant().(*ChunkedPayloadResponse_AcceptTransfer); ok {
		return x.AcceptTransfer
	}
	return false
}

func (x *ChunkedPayloadResponse) GetResendChunks() *ResendChunks {
	if x, ok := x.GetPayloadVariant().(*ChunkedPayloadResponse_ResendChunks); ok {
		return x.ResendChunks
	}
	return nil
}

type isChunkedPayloadResponse_PayloadVariant interface {
	isChunkedPayloadResponse_PayloadVariant()
}

type ChunkedPayloadResponse_RequestTransfer struct {
	// Request to transfer chunked payload
	RequestTransfer bool `protobuf:"varint,2,opt,name=request_transfer,json=requestTransfer,proto3,oneof"`
}

type ChunkedPayloadResponse_AcceptTransfer struct {
	// Accept the transfer chunked payload
	AcceptTransfer bool `protobuf:"varint,3,opt,name=accept_transfer,json=acceptTransfer,proto3,oneof"`
}

type ChunkedPayloadResponse_ResendChunks struct {
	// Request missing indexes in the chunked payload
	ResendChunks *ResendChunks `protobuf:"bytes,4,opt,name=resend_chunks,json=resendChunks,proto3,oneof"`
}

func (*ChunkedPayloadResponse_RequestTransfer) isChunkedPayloadResponse_PayloadVariant() {}

func (*ChunkedPayloadResponse_AcceptTransfer) isChunkedPayloadResponse_PayloadVariant() {}

func (*ChunkedPayloadResponse_ResendChunks) isChunkedPayloadResponse_PayloadVariant() {}

var File_meshtastic_mesh_proto protoreflect.FileDescriptor

var file_meshtastic_mesh_proto_rawDesc = []byte{
	0x0a, 0x15, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2f, 0x6d, 0x65, 0x73,
	0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73,
	0x74, 0x69, 0x63, 0x1a, 0x18, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2f,
	0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x6d,
	0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74,
	0x69, 0x63, 0x2f, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74,
	0x69, 0x63, 0x2f, 0x70, 0x6f, 0x72, 0x74, 0x6e, 0x75, 0x6d, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x1a, 0x1a, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2f, 0x74, 0x65,
	0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x6d,
	0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2f, 0x78, 0x6d, 0x6f, 0x64, 0x65, 0x6d,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xa2, 0x09, 0x0a, 0x08, 0x50, 0x6f, 0x73, 0x69, 0x74,
	0x69, 0x6f, 0x6e, 0x12, 0x22, 0x0a, 0x0a, 0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f,
	0x69, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0f, 0x48, 0x00, 0x52, 0x09, 0x6c, 0x61, 0x74, 0x69, 0x74,
	0x75, 0x64, 0x65, 0x49, 0x88, 0x01, 0x01, 0x12, 0x24, 0x0a, 0x0b, 0x6c, 0x6f, 0x6e, 0x67, 0x69,
	0x74, 0x75, 0x64, 0x65, 0x5f, 0x69, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0f, 0x48, 0x01, 0x52, 0x0a,
	0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x49, 0x88, 0x01, 0x01, 0x12, 0x1f, 0x0a,
	0x08, 0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x48,
	0x02, 0x52, 0x08, 0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x88, 0x01, 0x01, 0x12, 0x12,
	0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x07, 0x52, 0x04, 0x74, 0x69,
	0x6d, 0x65, 0x12, 0x47, 0x0a, 0x0f, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1e, 0x2e, 0x6d, 0x65,
	0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f,
	0x6e, 0x2e, 0x4c, 0x6f, 0x63, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x0e, 0x6c, 0x6f, 0x63,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x47, 0x0a, 0x0f, 0x61,
	0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x1e, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69,
	0x63, 0x2e, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x41, 0x6c, 0x74, 0x53, 0x6f,
	0x75, 0x72, 0x63, 0x65, 0x52, 0x0e, 0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x53, 0x6f,
	0x75, 0x72, 0x63, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	0x70, 0x18, 0x07, 0x20, 0x01, 0x28, 0x07, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
	0x6d, 0x70, 0x12, 0x36, 0x0a, 0x17, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x5f,
	0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x73, 0x5f, 0x61, 0x64, 0x6a, 0x75, 0x73, 0x74, 0x18, 0x08, 0x20,
	0x01, 0x28, 0x05, 0x52, 0x15, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x4d, 0x69,
	0x6c, 0x6c, 0x69, 0x73, 0x41, 0x64, 0x6a, 0x75, 0x73, 0x74, 0x12, 0x26, 0x0a, 0x0c, 0x61, 0x6c,
	0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x68, 0x61, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x11,
	0x48, 0x03, 0x52, 0x0b, 0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x48, 0x61, 0x65, 0x88,
	0x01, 0x01, 0x12, 0x43, 0x0a, 0x1b, 0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x67,
	0x65, 0x6f, 0x69, 0x64, 0x61, 0x6c, 0x5f, 0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x11, 0x48, 0x04, 0x52, 0x19, 0x61, 0x6c, 0x74, 0x69, 0x74,
	0x75, 0x64, 0x65, 0x47, 0x65, 0x6f, 0x69, 0x64, 0x61, 0x6c, 0x53, 0x65, 0x70, 0x61, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x88, 0x01, 0x01, 0x12, 0x12, 0x0a, 0x04, 0x50, 0x44, 0x4f, 0x50, 0x18,
	0x0b, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x50, 0x44, 0x4f, 0x50, 0x12, 0x12, 0x0a, 0x04, 0x48,
	0x44, 0x4f, 0x50, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x48, 0x44, 0x4f, 0x50, 0x12,
	0x12, 0x0a, 0x04, 0x56, 0x44, 0x4f, 0x50, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x56,
	0x44, 0x4f, 0x50, 0x12, 0x21, 0x0a, 0x0c, 0x67, 0x70, 0x73, 0x5f, 0x61, 0x63, 0x63, 0x75, 0x72,
	0x61, 0x63, 0x79, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x67, 0x70, 0x73, 0x41, 0x63,
	0x63, 0x75, 0x72, 0x61, 0x63, 0x79, 0x12, 0x26, 0x0a, 0x0c, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64,
	0x5f, 0x73, 0x70, 0x65, 0x65, 0x64, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x05, 0x52, 0x0b,
	0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x53, 0x70, 0x65, 0x65, 0x64, 0x88, 0x01, 0x01, 0x12, 0x26,
	0x0a, 0x0c, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x5f, 0x74, 0x72, 0x61, 0x63, 0x6b, 0x18, 0x10,
	0x20, 0x01, 0x28, 0x0d, 0x48, 0x06, 0x52, 0x0b, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x54, 0x72,
	0x61, 0x63, 0x6b, 0x88, 0x01, 0x01, 0x12, 0x1f, 0x0a, 0x0b, 0x66, 0x69, 0x78, 0x5f, 0x71, 0x75,
	0x61, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x66, 0x69, 0x78,
	0x51, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x19, 0x0a, 0x08, 0x66, 0x69, 0x78, 0x5f, 0x74,
	0x79, 0x70, 0x65, 0x18, 0x12, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x66, 0x69, 0x78, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x20, 0x0a, 0x0c, 0x73, 0x61, 0x74, 0x73, 0x5f, 0x69, 0x6e, 0x5f, 0x76, 0x69,
	0x65, 0x77, 0x18, 0x13, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x73, 0x61, 0x74, 0x73, 0x49, 0x6e,
	0x56, 0x69, 0x65, 0x77, 0x12, 0x1b, 0x0a, 0x09, 0x73, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x5f, 0x69,
	0x64, 0x18, 0x14, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x73, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x49,
	0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
	0x18, 0x15, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x6e, 0x65, 0x78, 0x74, 0x55, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x65, 0x71, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72,
	0x18, 0x16, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x73, 0x65, 0x71, 0x4e, 0x75, 0x6d, 0x62, 0x65,
	0x72, 0x12, 0x25, 0x0a, 0x0e, 0x70, 0x72, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x62,
	0x69, 0x74, 0x73, 0x18, 0x17, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0d, 0x70, 0x72, 0x65, 0x63, 0x69,
	0x73, 0x69, 0x6f, 0x6e, 0x42, 0x69, 0x74, 0x73, 0x22, 0x4e, 0x0a, 0x09, 0x4c, 0x6f, 0x63, 0x53,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x0d, 0x0a, 0x09, 0x4c, 0x4f, 0x43, 0x5f, 0x55, 0x4e, 0x53,
	0x45, 0x54, 0x10, 0x00, 0x12, 0x0e, 0x0a, 0x0a, 0x4c, 0x4f, 0x43, 0x5f, 0x4d, 0x41, 0x4e, 0x55,
	0x41, 0x4c, 0x10, 0x01, 0x12, 0x10, 0x0a, 0x0c, 0x4c, 0x4f, 0x43, 0x5f, 0x49, 0x4e, 0x54, 0x45,
	0x52, 0x4e, 0x41, 0x4c, 0x10, 0x02, 0x12, 0x10, 0x0a, 0x0c, 0x4c, 0x4f, 0x43, 0x5f, 0x45, 0x58,
	0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c, 0x10, 0x03, 0x22, 0x62, 0x0a, 0x09, 0x41, 0x6c, 0x74, 0x53,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x0d, 0x0a, 0x09, 0x41, 0x4c, 0x54, 0x5f, 0x55, 0x4e, 0x53,
	0x45, 0x54, 0x10, 0x00, 0x12, 0x0e, 0x0a, 0x0a, 0x41, 0x4c, 0x54, 0x5f, 0x4d, 0x41, 0x4e, 0x55,
	0x41, 0x4c, 0x10, 0x01, 0x12, 0x10, 0x0a, 0x0c, 0x41, 0x4c, 0x54, 0x5f, 0x49, 0x4e, 0x54, 0x45,
	0x52, 0x4e, 0x41, 0x4c, 0x10, 0x02, 0x12, 0x10, 0x0a, 0x0c, 0x41, 0x4c, 0x54, 0x5f, 0x45, 0x58,
	0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c, 0x10, 0x03, 0x12, 0x12, 0x0a, 0x0e, 0x41, 0x4c, 0x54, 0x5f,
	0x42, 0x41, 0x52, 0x4f, 0x4d, 0x45, 0x54, 0x52, 0x49, 0x43, 0x10, 0x04, 0x42, 0x0d, 0x0a, 0x0b,
	0x5f, 0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x69, 0x42, 0x0e, 0x0a, 0x0c, 0x5f,
	0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x69, 0x42, 0x0b, 0x0a, 0x09, 0x5f,
	0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x42, 0x0f, 0x0a, 0x0d, 0x5f, 0x61, 0x6c, 0x74,
	0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x68, 0x61, 0x65, 0x42, 0x1e, 0x0a, 0x1c, 0x5f, 0x61, 0x6c,
	0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x67, 0x65, 0x6f, 0x69, 0x64, 0x61, 0x6c, 0x5f, 0x73,
	0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x0f, 0x0a, 0x0d, 0x5f, 0x67, 0x72,
	0x6f, 0x75, 0x6e, 0x64, 0x5f, 0x73, 0x70, 0x65, 0x65, 0x64, 0x42, 0x0f, 0x0a, 0x0d, 0x5f, 0x67,
	0x72, 0x6f, 0x75, 0x6e, 0x64, 0x5f, 0x74, 0x72, 0x61, 0x63, 0x6b, 0x22, 0xa0, 0x02, 0x0a, 0x04,
	0x55, 0x73, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x02, 0x69, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x6f, 0x6e, 0x67, 0x5f, 0x6e, 0x61, 0x6d,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x6f, 0x6e, 0x67, 0x4e, 0x61, 0x6d,
	0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x4e, 0x61, 0x6d, 0x65,
	0x12, 0x1c, 0x0a, 0x07, 0x6d, 0x61, 0x63, 0x61, 0x64, 0x64, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0c, 0x42, 0x02, 0x18, 0x01, 0x52, 0x07, 0x6d, 0x61, 0x63, 0x61, 0x64, 0x64, 0x72, 0x12, 0x34,
	0x0a, 0x08, 0x68, 0x77, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x19, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x48, 0x61,
	0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x52, 0x07, 0x68, 0x77, 0x4d,
	0x6f, 0x64, 0x65, 0x6c, 0x12, 0x1f, 0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x6c, 0x69, 0x63, 0x65, 0x6e,
	0x73, 0x65, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x69, 0x73, 0x4c, 0x69, 0x63,
	0x65, 0x6e, 0x73, 0x65, 0x64, 0x12, 0x38, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18, 0x07, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x24, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63,
	0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x43, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x2e, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x12,
	0x1d, 0x0a, 0x0a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x08, 0x20,
	0x01, 0x28, 0x0c, 0x52, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79, 0x22, 0x81,
	0x01, 0x0a, 0x0e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72,
	0x79, 0x12, 0x14, 0x0a, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x18, 0x01, 0x20, 0x03, 0x28, 0x07,
	0x52, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x6e, 0x72, 0x5f, 0x74,
	0x6f, 0x77, 0x61, 0x72, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0a, 0x73, 0x6e,
	0x72, 0x54, 0x6f, 0x77, 0x61, 0x72, 0x64, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x72, 0x6f, 0x75, 0x74,
	0x65, 0x5f, 0x62, 0x61, 0x63, 0x6b, 0x18, 0x03, 0x20, 0x03, 0x28, 0x07, 0x52, 0x09, 0x72, 0x6f,
	0x75, 0x74, 0x65, 0x42, 0x61, 0x63, 0x6b, 0x12, 0x19, 0x0a, 0x08, 0x73, 0x6e, 0x72, 0x5f, 0x62,
	0x61, 0x63, 0x6b, 0x18, 0x04, 0x20, 0x03, 0x28, 0x05, 0x52, 0x07, 0x73, 0x6e, 0x72, 0x42, 0x61,
	0x63, 0x6b, 0x22, 0x89, 0x04, 0x0a, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x12, 0x41,
	0x0a, 0x0d, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74,
	0x69, 0x63, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72,
	0x79, 0x48, 0x00, 0x52, 0x0c, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x3d, 0x0a, 0x0b, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x72, 0x65, 0x70, 0x6c, 0x79,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73,
	0x74, 0x69, 0x63, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65,
	0x72, 0x79, 0x48, 0x00, 0x52, 0x0a, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x70, 0x6c, 0x79,
	0x12, 0x3e, 0x0a, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x19, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73,
	0x74, 0x69, 0x63, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x2e, 0x45, 0x72, 0x72, 0x6f,
	0x72, 0x48, 0x00, 0x52, 0x0b, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e,
	0x22, 0xb0, 0x02, 0x0a, 0x05, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x4f,
	0x4e, 0x45, 0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x4e, 0x4f, 0x5f, 0x52, 0x4f, 0x55, 0x54, 0x45,
	0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x47, 0x4f, 0x54, 0x5f, 0x4e, 0x41, 0x4b, 0x10, 0x02, 0x12,
	0x0b, 0x0a, 0x07, 0x54, 0x49, 0x4d, 0x45, 0x4f, 0x55, 0x54, 0x10, 0x03, 0x12, 0x10, 0x0a, 0x0c,
	0x4e, 0x4f, 0x5f, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x46, 0x41, 0x43, 0x45, 0x10, 0x04, 0x12, 0x12,
	0x0a, 0x0e, 0x4d, 0x41, 0x58, 0x5f, 0x52, 0x45, 0x54, 0x52, 0x41, 0x4e, 0x53, 0x4d, 0x49, 0x54,
	0x10, 0x05, 0x12, 0x0e, 0x0a, 0x0a, 0x4e, 0x4f, 0x5f, 0x43, 0x48, 0x41, 0x4e, 0x4e, 0x45, 0x4c,
	0x10, 0x06, 0x12, 0x0d, 0x0a, 0x09, 0x54, 0x4f, 0x4f, 0x5f, 0x4c, 0x41, 0x52, 0x47, 0x45, 0x10,
	0x07, 0x12, 0x0f, 0x0a, 0x0b, 0x4e, 0x4f, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53, 0x45,
	0x10, 0x08, 0x12, 0x14, 0x0a, 0x10, 0x44, 0x55, 0x54, 0x59, 0x5f, 0x43, 0x59, 0x43, 0x4c, 0x45,
	0x5f, 0x4c, 0x49, 0x4d, 0x49, 0x54, 0x10, 0x09, 0x12, 0x0f, 0x0a, 0x0b, 0x42, 0x41, 0x44, 0x5f,
	0x52, 0x45, 0x51, 0x55, 0x45, 0x53, 0x54, 0x10, 0x20, 0x12, 0x12, 0x0a, 0x0e, 0x4e, 0x4f, 0x54,
	0x5f, 0x41, 0x55, 0x54, 0x48, 0x4f, 0x52, 0x49, 0x5a, 0x45, 0x44, 0x10, 0x21, 0x12, 0x0e, 0x0a,
	0x0a, 0x50, 0x4b, 0x49, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x22, 0x12, 0x16, 0x0a,
	0x12, 0x50, 0x4b, 0x49, 0x5f, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x5f, 0x50, 0x55, 0x42,
	0x4b, 0x45, 0x59, 0x10, 0x23, 0x12, 0x19, 0x0a, 0x15, 0x41, 0x44, 0x4d, 0x49, 0x4e, 0x5f, 0x42,
	0x41, 0x44, 0x5f, 0x53, 0x45, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x4b, 0x45, 0x59, 0x10, 0x24,
	0x12, 0x21, 0x0a, 0x1d, 0x41, 0x44, 0x4d, 0x49, 0x4e, 0x5f, 0x50, 0x55, 0x42, 0x4c, 0x49, 0x43,
	0x5f, 0x4b, 0x45, 0x59, 0x5f, 0x55, 0x4e, 0x41, 0x55, 0x54, 0x48, 0x4f, 0x52, 0x49, 0x5a, 0x45,
	0x44, 0x10, 0x25, 0x42, 0x09, 0x0a, 0x07, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x22, 0x9e,
	0x02, 0x0a, 0x04, 0x44, 0x61, 0x74, 0x61, 0x12, 0x2d, 0x0a, 0x07, 0x70, 0x6f, 0x72, 0x74, 0x6e,
	0x75, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74,
	0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x4e, 0x75, 0x6d, 0x52, 0x07, 0x70,
	0x6f, 0x72, 0x74, 0x6e, 0x75, 0x6d, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64,
	0x12, 0x23, 0x0a, 0x0d, 0x77, 0x61, 0x6e, 0x74, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x77, 0x61, 0x6e, 0x74, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x65, 0x73, 0x74, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x07, 0x52, 0x04, 0x64, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x6f, 0x75,
	0x72, 0x63, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x07, 0x52, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63,
	0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x69, 0x64, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x07, 0x52, 0x09, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64,
	0x12, 0x19, 0x0a, 0x08, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x5f, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01,
	0x28, 0x07, 0x52, 0x07, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x65,
	0x6d, 0x6f, 0x6a, 0x69, 0x18, 0x08, 0x20, 0x01, 0x28, 0x07, 0x52, 0x05, 0x65, 0x6d, 0x6f, 0x6a,
	0x69, 0x12, 0x1f, 0x0a, 0x08, 0x62, 0x69, 0x74, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x18, 0x09, 0x20,
	0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x08, 0x62, 0x69, 0x74, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x88,
	0x01, 0x01, 0x42, 0x0b, 0x0a, 0x09, 0x5f, 0x62, 0x69, 0x74, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x22,
	0x82, 0x02, 0x0a, 0x08, 0x57, 0x61, 0x79, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x0e, 0x0a, 0x02,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x12, 0x22, 0x0a, 0x0a,
	0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x69, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0f,
	0x48, 0x00, 0x52, 0x09, 0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x49, 0x88, 0x01, 0x01,
	0x12, 0x24, 0x0a, 0x0b, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x69, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0f, 0x48, 0x01, 0x52, 0x0a, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75,
	0x64, 0x65, 0x49, 0x88, 0x01, 0x01, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x12, 0x1b,
	0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x5f, 0x74, 0x6f, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x08, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x54, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x6e,
	0x61, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12,
	0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x07,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x12, 0x0a, 0x04, 0x69, 0x63, 0x6f, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x07, 0x52,
	0x04, 0x69, 0x63, 0x6f, 0x6e, 0x42, 0x0d, 0x0a, 0x0b, 0x5f, 0x6c, 0x61, 0x74, 0x69, 0x74, 0x75,
	0x64, 0x65, 0x5f, 0x69, 0x42, 0x0e, 0x0a, 0x0c, 0x5f, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75,
	0x64, 0x65, 0x5f, 0x69, 0x22, 0x89, 0x01, 0x0a, 0x16, 0x4d, 0x71, 0x74, 0x74, 0x43, 0x6c, 0x69,
	0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12,
	0x14, 0x0a, 0x05, 0x74, 0x6f, 0x70, 0x69, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
	0x74, 0x6f, 0x70, 0x69, 0x63, 0x12, 0x14, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x12, 0x14, 0x0a, 0x04, 0x74,
	0x65, 0x78, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x04, 0x74, 0x65, 0x78,
	0x74, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x64, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x64, 0x42, 0x11, 0x0a,
	0x0f, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74,
	0x22, 0xec, 0x05, 0x0a, 0x0a, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12,
	0x12, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x07, 0x52, 0x04, 0x66,
	0x72, 0x6f, 0x6d, 0x12, 0x0e, 0x0a, 0x02, 0x74, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x07, 0x52,
	0x02, 0x74, 0x6f, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x2c, 0x0a,
	0x07, 0x64, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10,
	0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x44, 0x61, 0x74, 0x61,
	0x48, 0x00, 0x52, 0x07, 0x64, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x12, 0x1e, 0x0a, 0x09, 0x65,
	0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00,
	0x52, 0x09, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x12, 0x0e, 0x0a, 0x02, 0x69,
	0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x07, 0x52, 0x02, 0x69, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x72,
	0x78, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x07, 0x52, 0x06, 0x72, 0x78,
	0x54, 0x69, 0x6d, 0x65, 0x12, 0x15, 0x0a, 0x06, 0x72, 0x78, 0x5f, 0x73, 0x6e, 0x72, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x02, 0x52, 0x05, 0x72, 0x78, 0x53, 0x6e, 0x72, 0x12, 0x1b, 0x0a, 0x09, 0x68,
	0x6f, 0x70, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08,
	0x68, 0x6f, 0x70, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x77, 0x61, 0x6e, 0x74,
	0x5f, 0x61, 0x63, 0x6b, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x77, 0x61, 0x6e, 0x74,
	0x41, 0x63, 0x6b, 0x12, 0x3b, 0x0a, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x18,
	0x0b, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74,
	0x69, 0x63, 0x2e, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x2e, 0x50, 0x72,
	0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x52, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79,
	0x12, 0x17, 0x0a, 0x07, 0x72, 0x78, 0x5f, 0x72, 0x73, 0x73, 0x69, 0x18, 0x0c, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x06, 0x72, 0x78, 0x52, 0x73, 0x73, 0x69, 0x12, 0x3c, 0x0a, 0x07, 0x64, 0x65, 0x6c,
	0x61, 0x79, 0x65, 0x64, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1e, 0x2e, 0x6d, 0x65, 0x73,
	0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b,
	0x65, 0x74, 0x2e, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x42, 0x02, 0x18, 0x01, 0x52, 0x07,
	0x64, 0x65, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x76, 0x69, 0x61, 0x5f, 0x6d,
	0x71, 0x74, 0x74, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x76, 0x69, 0x61, 0x4d, 0x71,
	0x74, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x68, 0x6f, 0x70, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18,
	0x0f, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x68, 0x6f, 0x70, 0x53, 0x74, 0x61, 0x72, 0x74, 0x12,
	0x1d, 0x0a, 0x0a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x10, 0x20,
	0x01, 0x28, 0x0c, 0x52, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79, 0x12, 0x23,
	0x0a, 0x0d, 0x70, 0x6b, 0x69, 0x5f, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x18,
	0x11, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x70, 0x6b, 0x69, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70,
	0x74, 0x65, 0x64, 0x22, 0x73, 0x0a, 0x08, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x12,
	0x09, 0x0a, 0x05, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x4d, 0x49,
	0x4e, 0x10, 0x01, 0x12, 0x0e, 0x0a, 0x0a, 0x42, 0x41, 0x43, 0x4b, 0x47, 0x52, 0x4f, 0x55, 0x4e,
	0x44, 0x10, 0x0a, 0x12, 0x0b, 0x0a, 0x07, 0x44, 0x45, 0x46, 0x41, 0x55, 0x4c, 0x54, 0x10, 0x40,
	0x12, 0x0c, 0x0a, 0x08, 0x52, 0x45, 0x4c, 0x49, 0x41, 0x42, 0x4c, 0x45, 0x10, 0x46, 0x12, 0x0c,
	0x0a, 0x08, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53, 0x45, 0x10, 0x50, 0x12, 0x08, 0x0a, 0x04,
	0x48, 0x49, 0x47, 0x48, 0x10, 0x64, 0x12, 0x07, 0x0a, 0x03, 0x41, 0x43, 0x4b, 0x10, 0x78, 0x12,
	0x07, 0x0a, 0x03, 0x4d, 0x41, 0x58, 0x10, 0x7f, 0x22, 0x42, 0x0a, 0x07, 0x44, 0x65, 0x6c, 0x61,
	0x79, 0x65, 0x64, 0x12, 0x0c, 0x0a, 0x08, 0x4e, 0x4f, 0x5f, 0x44, 0x45, 0x4c, 0x41, 0x59, 0x10,
	0x00, 0x12, 0x15, 0x0a, 0x11, 0x44, 0x45, 0x4c, 0x41, 0x59, 0x45, 0x44, 0x5f, 0x42, 0x52, 0x4f,
	0x41, 0x44, 0x43, 0x41, 0x53, 0x54, 0x10, 0x01, 0x12, 0x12, 0x0a, 0x0e, 0x44, 0x45, 0x4c, 0x41,
	0x59, 0x45, 0x44, 0x5f, 0x44, 0x49, 0x52, 0x45, 0x43, 0x54, 0x10, 0x02, 0x42, 0x11, 0x0a, 0x0f,
	0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x22,
	0xed, 0x02, 0x0a, 0x08, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x10, 0x0a, 0x03,
	0x6e, 0x75, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x6e, 0x75, 0x6d, 0x12, 0x24,
	0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d,
	0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04,
	0x75, 0x73, 0x65, 0x72, 0x12, 0x30, 0x0a, 0x08, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73,
	0x74, 0x69, 0x63, 0x2e, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x70, 0x6f,
	0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x10, 0x0a, 0x03, 0x73, 0x6e, 0x72, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x02, 0x52, 0x03, 0x73, 0x6e, 0x72, 0x12, 0x1d, 0x0a, 0x0a, 0x6c, 0x61, 0x73, 0x74,
	0x5f, 0x68, 0x65, 0x61, 0x72, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x07, 0x52, 0x09, 0x6c, 0x61,
	0x73, 0x74, 0x48, 0x65, 0x61, 0x72, 0x64, 0x12, 0x40, 0x0a, 0x0e, 0x64, 0x65, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x19, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x44, 0x65, 0x76,
	0x69, 0x63, 0x65, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x52, 0x0d, 0x64, 0x65, 0x76, 0x69,
	0x63, 0x65, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x68, 0x61,
	0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x63, 0x68, 0x61, 0x6e,
	0x6e, 0x65, 0x6c, 0x12, 0x19, 0x0a, 0x08, 0x76, 0x69, 0x61, 0x5f, 0x6d, 0x71, 0x74, 0x74, 0x18,
	0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x76, 0x69, 0x61, 0x4d, 0x71, 0x74, 0x74, 0x12, 0x20,
	0x0a, 0x09, 0x68, 0x6f, 0x70, 0x73, 0x5f, 0x61, 0x77, 0x61, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x0d, 0x48, 0x00, 0x52, 0x08, 0x68, 0x6f, 0x70, 0x73, 0x41, 0x77, 0x61, 0x79, 0x88, 0x01, 0x01,
	0x12, 0x1f, 0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x66, 0x61, 0x76, 0x6f, 0x72, 0x69, 0x74, 0x65, 0x18,
	0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x69, 0x73, 0x46, 0x61, 0x76, 0x6f, 0x72, 0x69, 0x74,
	0x65, 0x42, 0x0c, 0x0a, 0x0a, 0x5f, 0x68, 0x6f, 0x70, 0x73, 0x5f, 0x61, 0x77, 0x61, 0x79, 0x22,
	0x77, 0x0a, 0x0a, 0x4d, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1e, 0x0a,
	0x0b, 0x6d, 0x79, 0x5f, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x09, 0x6d, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x4e, 0x75, 0x6d, 0x12, 0x21, 0x0a,
	0x0c, 0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x08, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x0b, 0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74,
	0x12, 0x26, 0x0a, 0x0f, 0x6d, 0x69, 0x6e, 0x5f, 0x61, 0x70, 0x70, 0x5f, 0x76, 0x65, 0x72, 0x73,
	0x69, 0x6f, 0x6e, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0d, 0x6d, 0x69, 0x6e, 0x41, 0x70,
	0x70, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0xde, 0x01, 0x0a, 0x09, 0x4c, 0x6f, 0x67,
	0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
	0x12, 0x12, 0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x07, 0x52, 0x04,
	0x74, 0x69, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x31, 0x0a, 0x05,
	0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x6d, 0x65,
	0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4c, 0x6f, 0x67, 0x52, 0x65, 0x63, 0x6f,
	0x72, 0x64, 0x2e, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52, 0x05, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x22,
	0x58, 0x0a, 0x05, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x09, 0x0a, 0x05, 0x55, 0x4e, 0x53, 0x45,
	0x54, 0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x43, 0x52, 0x49, 0x54, 0x49, 0x43, 0x41, 0x4c, 0x10,
	0x32, 0x12, 0x09, 0x0a, 0x05, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x28, 0x12, 0x0b, 0x0a, 0x07,
	0x57, 0x41, 0x52, 0x4e, 0x49, 0x4e, 0x47, 0x10, 0x1e, 0x12, 0x08, 0x0a, 0x04, 0x49, 0x4e, 0x46,
	0x4f, 0x10, 0x14, 0x12, 0x09, 0x0a, 0x05, 0x44, 0x45, 0x42, 0x55, 0x47, 0x10, 0x0a, 0x12, 0x09,
	0x0a, 0x05, 0x54, 0x52, 0x41, 0x43, 0x45, 0x10, 0x05, 0x22, 0x71, 0x0a, 0x0b, 0x51, 0x75, 0x65,
	0x75, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x10, 0x0a, 0x03, 0x72, 0x65, 0x73, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x72, 0x65, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x72,
	0x65, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x66, 0x72, 0x65, 0x65, 0x12, 0x16,
	0x0a, 0x06, 0x6d, 0x61, 0x78, 0x6c, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06,
	0x6d, 0x61, 0x78, 0x6c, 0x65, 0x6e, 0x12, 0x24, 0x0a, 0x0e, 0x6d, 0x65, 0x73, 0x68, 0x5f, 0x70,
	0x61, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c,
	0x6d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x49, 0x64, 0x22, 0x82, 0x07, 0x0a,
	0x09, 0x46, 0x72, 0x6f, 0x6d, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x12, 0x30, 0x0a, 0x06, 0x70, 0x61,
	0x63, 0x6b, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x73,
	0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b,
	0x65, 0x74, 0x48, 0x00, 0x52, 0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x31, 0x0a, 0x07,
	0x6d, 0x79, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,
	0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4d, 0x79, 0x4e, 0x6f, 0x64,
	0x65, 0x49, 0x6e, 0x66, 0x6f, 0x48, 0x00, 0x52, 0x06, 0x6d, 0x79, 0x49, 0x6e, 0x66, 0x6f, 0x12,
	0x33, 0x0a, 0x09, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e,
	0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x48, 0x00, 0x52, 0x08, 0x6e, 0x6f, 0x64, 0x65,
	0x49, 0x6e, 0x66, 0x6f, 0x12, 0x2c, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69,
	0x63, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x48, 0x00, 0x52, 0x06, 0x63, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x12, 0x36, 0x0a, 0x0a, 0x6c, 0x6f, 0x67, 0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73,
	0x74, 0x69, 0x63, 0x2e, 0x4c, 0x6f, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x48, 0x00, 0x52,
	0x09, 0x6c, 0x6f, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x2e, 0x0a, 0x12, 0x63, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x5f, 0x69, 0x64,
	0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x10, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x49, 0x64, 0x12, 0x1c, 0x0a, 0x08, 0x72, 0x65,
	0x62, 0x6f, 0x6f, 0x74, 0x65, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x08,
	0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74, 0x65, 0x64, 0x12, 0x3e, 0x0a, 0x0c, 0x6d, 0x6f, 0x64, 0x75,
	0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18,
	0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4d, 0x6f, 0x64, 0x75,
	0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x48, 0x00, 0x52, 0x0c, 0x6d, 0x6f, 0x64, 0x75,
	0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x2f, 0x0a, 0x07, 0x63, 0x68, 0x61, 0x6e,
	0x6e, 0x65, 0x6c, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x68,
	0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x48, 0x00,
	0x52, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x3b, 0x0a, 0x0b, 0x71, 0x75, 0x65,
	0x75, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17,
	0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x51, 0x75, 0x65, 0x75,
	0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x48, 0x00, 0x52, 0x0b, 0x71, 0x75, 0x65, 0x75, 0x65,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x38, 0x0a, 0x0c, 0x78, 0x6d, 0x6f, 0x64, 0x65, 0x6d,
	0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d,
	0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x58, 0x4d, 0x6f, 0x64, 0x65, 0x6d,
	0x48, 0x00, 0x52, 0x0c, 0x78, 0x6d, 0x6f, 0x64, 0x65, 0x6d, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74,
	0x12, 0x38, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x0d, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e,
	0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x48, 0x00,
	0x52, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x5c, 0x0a, 0x16, 0x6d, 0x71,
	0x74, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x4d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x6d, 0x65, 0x73,
	0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4d, 0x71, 0x74, 0x74, 0x43, 0x6c, 0x69, 0x65,
	0x6e, 0x74, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x48, 0x00,
	0x52, 0x16, 0x6d, 0x71, 0x74, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x78,
	0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x32, 0x0a, 0x08, 0x66, 0x69, 0x6c, 0x65,
	0x49, 0x6e, 0x66, 0x6f, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73,
	0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f,
	0x48, 0x00, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x50, 0x0a, 0x12,
	0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x18, 0x10, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74,
	0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4e, 0x6f, 0x74, 0x69,
	0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x12, 0x63, 0x6c, 0x69, 0x65,
	0x6e, 0x74, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x11,
	0x0a, 0x0f, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e,
	0x74, 0x22, 0xa2, 0x01, 0x0a, 0x12, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4e, 0x6f, 0x74, 0x69,
	0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1e, 0x0a, 0x08, 0x72, 0x65, 0x70, 0x6c,
	0x79, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x07, 0x72, 0x65,
	0x70, 0x6c, 0x79, 0x49, 0x64, 0x88, 0x01, 0x01, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x07, 0x52, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x31, 0x0a, 0x05,
	0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x6d, 0x65,
	0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4c, 0x6f, 0x67, 0x52, 0x65, 0x63, 0x6f,
	0x72, 0x64, 0x2e, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52, 0x05, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x12,
	0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x0b, 0x0a, 0x09, 0x5f, 0x72, 0x65,
	0x70, 0x6c, 0x79, 0x5f, 0x69, 0x64, 0x22, 0x46, 0x0a, 0x08, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x6e,
	0x66, 0x6f, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12,
	0x1d, 0x0a, 0x0a, 0x73, 0x69, 0x7a, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x09, 0x73, 0x69, 0x7a, 0x65, 0x42, 0x79, 0x74, 0x65, 0x73, 0x22, 0xe7,
	0x02, 0x0a, 0x07, 0x54, 0x6f, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x12, 0x30, 0x0a, 0x06, 0x70, 0x61,
	0x63, 0x6b, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x73,
	0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b,
	0x65, 0x74, 0x48, 0x00, 0x52, 0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x26, 0x0a, 0x0e,
	0x77, 0x61, 0x6e, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x69, 0x64, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x0c, 0x77, 0x61, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x49, 0x64, 0x12, 0x20, 0x0a, 0x0a, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65,
	0x63, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x0a, 0x64, 0x69, 0x73, 0x63,
	0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x12, 0x38, 0x0a, 0x0c, 0x78, 0x6d, 0x6f, 0x64, 0x65, 0x6d,
	0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d,
	0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x58, 0x4d, 0x6f, 0x64, 0x65, 0x6d,
	0x48, 0x00, 0x52, 0x0c, 0x78, 0x6d, 0x6f, 0x64, 0x65, 0x6d, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74,
	0x12, 0x5c, 0x0a, 0x16, 0x6d, 0x71, 0x74, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x72,
	0x6f, 0x78, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x22, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4d, 0x71,
	0x74, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x4d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x48, 0x00, 0x52, 0x16, 0x6d, 0x71, 0x74, 0x74, 0x43, 0x6c, 0x69, 0x65,
	0x6e, 0x74, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x35,
	0x0a, 0x09, 0x68, 0x65, 0x61, 0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x48,
	0x65, 0x61, 0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x48, 0x00, 0x52, 0x09, 0x68, 0x65, 0x61, 0x72,
	0x74, 0x62, 0x65, 0x61, 0x74, 0x42, 0x11, 0x0a, 0x0f, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64,
	0x5f, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x22, 0x4f, 0x0a, 0x0a, 0x43, 0x6f, 0x6d, 0x70,
	0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x12, 0x2d, 0x0a, 0x07, 0x70, 0x6f, 0x72, 0x74, 0x6e, 0x75,
	0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61,
	0x73, 0x74, 0x69, 0x63, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x4e, 0x75, 0x6d, 0x52, 0x07, 0x70, 0x6f,
	0x72, 0x74, 0x6e, 0x75, 0x6d, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0c, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x22, 0xc3, 0x01, 0x0a, 0x0c, 0x4e, 0x65,
	0x69, 0x67, 0x68, 0x62, 0x6f, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x6f,
	0x64, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x6e, 0x6f, 0x64,
	0x65, 0x49, 0x64, 0x12, 0x25, 0x0a, 0x0f, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x73, 0x65, 0x6e, 0x74,
	0x5f, 0x62, 0x79, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x6c, 0x61,
	0x73, 0x74, 0x53, 0x65, 0x6e, 0x74, 0x42, 0x79, 0x49, 0x64, 0x12, 0x3f, 0x0a, 0x1c, 0x6e, 0x6f,
	0x64, 0x65, 0x5f, 0x62, 0x72, 0x6f, 0x61, 0x64, 0x63, 0x61, 0x73, 0x74, 0x5f, 0x69, 0x6e, 0x74,
	0x65, 0x72, 0x76, 0x61, 0x6c, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x19, 0x6e, 0x6f, 0x64, 0x65, 0x42, 0x72, 0x6f, 0x61, 0x64, 0x63, 0x61, 0x73, 0x74, 0x49,
	0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x53, 0x65, 0x63, 0x73, 0x12, 0x32, 0x0a, 0x09, 0x6e,
	0x65, 0x69, 0x67, 0x68, 0x62, 0x6f, 0x72, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14,
	0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x4e, 0x65, 0x69, 0x67,
	0x68, 0x62, 0x6f, 0x72, 0x52, 0x09, 0x6e, 0x65, 0x69, 0x67, 0x68, 0x62, 0x6f, 0x72, 0x73, 0x22,
	0x98, 0x01, 0x0a, 0x08, 0x4e, 0x65, 0x69, 0x67, 0x68, 0x62, 0x6f, 0x72, 0x12, 0x17, 0x0a, 0x07,
	0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x6e,
	0x6f, 0x64, 0x65, 0x49, 0x64, 0x12, 0x10, 0x0a, 0x03, 0x73, 0x6e, 0x72, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x02, 0x52, 0x03, 0x73, 0x6e, 0x72, 0x12, 0x20, 0x0a, 0x0c, 0x6c, 0x61, 0x73, 0x74, 0x5f,
	0x72, 0x78, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x07, 0x52, 0x0a, 0x6c,
	0x61, 0x73, 0x74, 0x52, 0x78, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x3f, 0x0a, 0x1c, 0x6e, 0x6f, 0x64,
	0x65, 0x5f, 0x62, 0x72, 0x6f, 0x61, 0x64, 0x63, 0x61, 0x73, 0x74, 0x5f, 0x69, 0x6e, 0x74, 0x65,
	0x72, 0x76, 0x61, 0x6c, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x19, 0x6e, 0x6f, 0x64, 0x65, 0x42, 0x72, 0x6f, 0x61, 0x64, 0x63, 0x61, 0x73, 0x74, 0x49, 0x6e,
	0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x53, 0x65, 0x63, 0x73, 0x22, 0xcc, 0x03, 0x0a, 0x0e, 0x44,
	0x65, 0x76, 0x69, 0x63, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x29, 0x0a,
	0x10, 0x66, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
	0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x66, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72,
	0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x30, 0x0a, 0x14, 0x64, 0x65, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x53, 0x74,
	0x61, 0x74, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x20, 0x0a, 0x0b, 0x63, 0x61,
	0x6e, 0x53, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x0b, 0x63, 0x61, 0x6e, 0x53, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x12, 0x18, 0x0a, 0x07,
	0x68, 0x61, 0x73, 0x57, 0x69, 0x66, 0x69, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x68,
	0x61, 0x73, 0x57, 0x69, 0x66, 0x69, 0x12, 0x22, 0x0a, 0x0c, 0x68, 0x61, 0x73, 0x42, 0x6c, 0x75,
	0x65, 0x74, 0x6f, 0x6f, 0x74, 0x68, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x68, 0x61,
	0x73, 0x42, 0x6c, 0x75, 0x65, 0x74, 0x6f, 0x6f, 0x74, 0x68, 0x12, 0x20, 0x0a, 0x0b, 0x68, 0x61,
	0x73, 0x45, 0x74, 0x68, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x0b, 0x68, 0x61, 0x73, 0x45, 0x74, 0x68, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x12, 0x38, 0x0a, 0x04,
	0x72, 0x6f, 0x6c, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x24, 0x2e, 0x6d, 0x65, 0x73,
	0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x44,
	0x65, 0x76, 0x69, 0x63, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x52, 0x6f, 0x6c, 0x65,
	0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0d,
	0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x12, 0x34, 0x0a,
	0x08, 0x68, 0x77, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x19, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x48, 0x61, 0x72,
	0x64, 0x77, 0x61, 0x72, 0x65, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x52, 0x07, 0x68, 0x77, 0x4d, 0x6f,
	0x64, 0x65, 0x6c, 0x12, 0x2c, 0x0a, 0x11, 0x68, 0x61, 0x73, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65,
	0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x11,
	0x68, 0x61, 0x73, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72,
	0x65, 0x12, 0x16, 0x0a, 0x06, 0x68, 0x61, 0x73, 0x50, 0x4b, 0x43, 0x18, 0x0b, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x06, 0x68, 0x61, 0x73, 0x50, 0x4b, 0x43, 0x22, 0x0b, 0x0a, 0x09, 0x48, 0x65, 0x61,
	0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x22, 0x63, 0x0a, 0x15, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65,
	0x6d, 0x6f, 0x74, 0x65, 0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x50, 0x69, 0x6e, 0x12,
	0x19, 0x0a, 0x08, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x07, 0x6e, 0x6f, 0x64, 0x65, 0x4e, 0x75, 0x6d, 0x12, 0x2f, 0x0a, 0x03, 0x70, 0x69,
	0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61,
	0x73, 0x74, 0x69, 0x63, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x48, 0x61, 0x72, 0x64, 0x77,
	0x61, 0x72, 0x65, 0x50, 0x69, 0x6e, 0x52, 0x03, 0x70, 0x69, 0x6e, 0x22, 0x96, 0x01, 0x0a, 0x0e,
	0x43, 0x68, 0x75, 0x6e, 0x6b, 0x65, 0x64, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x1d,
	0x0a, 0x0a, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x09, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x49, 0x64, 0x12, 0x1f, 0x0a,
	0x0b, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x0a, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1f,
	0x0a, 0x0b, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x0a, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12,
	0x23, 0x0a, 0x0d, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x63, 0x68, 0x75, 0x6e, 0x6b,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0c, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x43,
	0x68, 0x75, 0x6e, 0x6b, 0x22, 0x27, 0x0a, 0x0d, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x64, 0x5f, 0x63,
	0x68, 0x75, 0x6e, 0x6b, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x06, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x73, 0x22, 0xe4, 0x01,
	0x0a, 0x16, 0x43, 0x68, 0x75, 0x6e, 0x6b, 0x65, 0x64, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x70, 0x61, 0x79, 0x6c,
	0x6f, 0x61, 0x64, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x70, 0x61,
	0x79, 0x6c, 0x6f, 0x61, 0x64, 0x49, 0x64, 0x12, 0x2b, 0x0a, 0x10, 0x72, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x08, 0x48, 0x00, 0x52, 0x0f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x72, 0x61, 0x6e,
	0x73, 0x66, 0x65, 0x72, 0x12, 0x29, 0x0a, 0x0f, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x5f, 0x74,
	0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52,
	0x0e, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x12,
	0x40, 0x0a, 0x0d, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x64, 0x5f, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x73,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73,
	0x74, 0x69, 0x63, 0x2e, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x64, 0x5f, 0x63, 0x68, 0x75, 0x6e, 0x6b,
	0x73, 0x48, 0x00, 0x52, 0x0c, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x68, 0x75, 0x6e, 0x6b,
	0x73, 0x42, 0x11, 0x0a, 0x0f, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x76, 0x61, 0x72,
	0x69, 0x61, 0x6e, 0x74, 0x2a, 0xcb, 0x0c, 0x0a, 0x0d, 0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72,
	0x65, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x12, 0x09, 0x0a, 0x05, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10,
	0x00, 0x12, 0x0c, 0x0a, 0x08, 0x54, 0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x56, 0x32, 0x10, 0x01, 0x12,
	0x0c, 0x0a, 0x08, 0x54, 0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x56, 0x31, 0x10, 0x02, 0x12, 0x12, 0x0a,
	0x0e, 0x54, 0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x56, 0x32, 0x5f, 0x31, 0x5f, 0x31, 0x50, 0x36, 0x10,
	0x03, 0x12, 0x09, 0x0a, 0x05, 0x54, 0x42, 0x45, 0x41, 0x4d, 0x10, 0x04, 0x12, 0x0f, 0x0a, 0x0b,
	0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x56, 0x32, 0x5f, 0x30, 0x10, 0x05, 0x12, 0x0e, 0x0a,
	0x0a, 0x54, 0x42, 0x45, 0x41, 0x4d, 0x5f, 0x56, 0x30, 0x50, 0x37, 0x10, 0x06, 0x12, 0x0a, 0x0a,
	0x06, 0x54, 0x5f, 0x45, 0x43, 0x48, 0x4f, 0x10, 0x07, 0x12, 0x10, 0x0a, 0x0c, 0x54, 0x4c, 0x4f,
	0x52, 0x41, 0x5f, 0x56, 0x31, 0x5f, 0x31, 0x50, 0x33, 0x10, 0x08, 0x12, 0x0b, 0x0a, 0x07, 0x52,
	0x41, 0x4b, 0x34, 0x36, 0x33, 0x31, 0x10, 0x09, 0x12, 0x0f, 0x0a, 0x0b, 0x48, 0x45, 0x4c, 0x54,
	0x45, 0x43, 0x5f, 0x56, 0x32, 0x5f, 0x31, 0x10, 0x0a, 0x12, 0x0d, 0x0a, 0x09, 0x48, 0x45, 0x4c,
	0x54, 0x45, 0x43, 0x5f, 0x56, 0x31, 0x10, 0x0b, 0x12, 0x18, 0x0a, 0x14, 0x4c, 0x49, 0x4c, 0x59,
	0x47, 0x4f, 0x5f, 0x54, 0x42, 0x45, 0x41, 0x4d, 0x5f, 0x53, 0x33, 0x5f, 0x43, 0x4f, 0x52, 0x45,
	0x10, 0x0c, 0x12, 0x0c, 0x0a, 0x08, 0x52, 0x41, 0x4b, 0x31, 0x31, 0x32, 0x30, 0x30, 0x10, 0x0d,
	0x12, 0x0b, 0x0a, 0x07, 0x4e, 0x41, 0x4e, 0x4f, 0x5f, 0x47, 0x31, 0x10, 0x0e, 0x12, 0x12, 0x0a,
	0x0e, 0x54, 0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x56, 0x32, 0x5f, 0x31, 0x5f, 0x31, 0x50, 0x38, 0x10,
	0x0f, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x54, 0x33, 0x5f, 0x53, 0x33,
	0x10, 0x10, 0x12, 0x14, 0x0a, 0x10, 0x4e, 0x41, 0x4e, 0x4f, 0x5f, 0x47, 0x31, 0x5f, 0x45, 0x58,
	0x50, 0x4c, 0x4f, 0x52, 0x45, 0x52, 0x10, 0x11, 0x12, 0x11, 0x0a, 0x0d, 0x4e, 0x41, 0x4e, 0x4f,
	0x5f, 0x47, 0x32, 0x5f, 0x55, 0x4c, 0x54, 0x52, 0x41, 0x10, 0x12, 0x12, 0x0d, 0x0a, 0x09, 0x4c,
	0x4f, 0x52, 0x41, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x10, 0x13, 0x12, 0x0b, 0x0a, 0x07, 0x57, 0x49,
	0x50, 0x48, 0x4f, 0x4e, 0x45, 0x10, 0x14, 0x12, 0x0e, 0x0a, 0x0a, 0x57, 0x49, 0x4f, 0x5f, 0x57,
	0x4d, 0x31, 0x31, 0x31, 0x30, 0x10, 0x15, 0x12, 0x0b, 0x0a, 0x07, 0x52, 0x41, 0x4b, 0x32, 0x35,
	0x36, 0x30, 0x10, 0x16, 0x12, 0x13, 0x0a, 0x0f, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x48,
	0x52, 0x55, 0x5f, 0x33, 0x36, 0x30, 0x31, 0x10, 0x17, 0x12, 0x1a, 0x0a, 0x16, 0x48, 0x45, 0x4c,
	0x54, 0x45, 0x43, 0x5f, 0x57, 0x49, 0x52, 0x45, 0x4c, 0x45, 0x53, 0x53, 0x5f, 0x42, 0x52, 0x49,
	0x44, 0x47, 0x45, 0x10, 0x18, 0x12, 0x0e, 0x0a, 0x0a, 0x53, 0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e,
	0x5f, 0x47, 0x31, 0x10, 0x19, 0x12, 0x0c, 0x0a, 0x08, 0x52, 0x41, 0x4b, 0x31, 0x31, 0x33, 0x31,
	0x30, 0x10, 0x1a, 0x12, 0x14, 0x0a, 0x10, 0x53, 0x45, 0x4e, 0x53, 0x45, 0x4c, 0x4f, 0x52, 0x41,
	0x5f, 0x52, 0x50, 0x32, 0x30, 0x34, 0x30, 0x10, 0x1b, 0x12, 0x10, 0x0a, 0x0c, 0x53, 0x45, 0x4e,
	0x53, 0x45, 0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x53, 0x33, 0x10, 0x1c, 0x12, 0x0d, 0x0a, 0x09, 0x43,
	0x41, 0x4e, 0x41, 0x52, 0x59, 0x4f, 0x4e, 0x45, 0x10, 0x1d, 0x12, 0x0f, 0x0a, 0x0b, 0x52, 0x50,
	0x32, 0x30, 0x34, 0x30, 0x5f, 0x4c, 0x4f, 0x52, 0x41, 0x10, 0x1e, 0x12, 0x0e, 0x0a, 0x0a, 0x53,
	0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x47, 0x32, 0x10, 0x1f, 0x12, 0x11, 0x0a, 0x0d, 0x4c,
	0x4f, 0x52, 0x41, 0x5f, 0x52, 0x45, 0x4c, 0x41, 0x59, 0x5f, 0x56, 0x31, 0x10, 0x20, 0x12, 0x0e,
	0x0a, 0x0a, 0x4e, 0x52, 0x46, 0x35, 0x32, 0x38, 0x34, 0x30, 0x44, 0x4b, 0x10, 0x21, 0x12, 0x07,
	0x0a, 0x03, 0x50, 0x50, 0x52, 0x10, 0x22, 0x12, 0x0f, 0x0a, 0x0b, 0x47, 0x45, 0x4e, 0x49, 0x45,
	0x42, 0x4c, 0x4f, 0x43, 0x4b, 0x53, 0x10, 0x23, 0x12, 0x11, 0x0a, 0x0d, 0x4e, 0x52, 0x46, 0x35,
	0x32, 0x5f, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x24, 0x12, 0x0d, 0x0a, 0x09, 0x50,
	0x4f, 0x52, 0x54, 0x44, 0x55, 0x49, 0x4e, 0x4f, 0x10, 0x25, 0x12, 0x0f, 0x0a, 0x0b, 0x41, 0x4e,
	0x44, 0x52, 0x4f, 0x49, 0x44, 0x5f, 0x53, 0x49, 0x4d, 0x10, 0x26, 0x12, 0x0a, 0x0a, 0x06, 0x44,
	0x49, 0x59, 0x5f, 0x56, 0x31, 0x10, 0x27, 0x12, 0x15, 0x0a, 0x11, 0x4e, 0x52, 0x46, 0x35, 0x32,
	0x38, 0x34, 0x30, 0x5f, 0x50, 0x43, 0x41, 0x31, 0x30, 0x30, 0x35, 0x39, 0x10, 0x28, 0x12, 0x0a,
	0x0a, 0x06, 0x44, 0x52, 0x5f, 0x44, 0x45, 0x56, 0x10, 0x29, 0x12, 0x0b, 0x0a, 0x07, 0x4d, 0x35,
	0x53, 0x54, 0x41, 0x43, 0x4b, 0x10, 0x2a, 0x12, 0x0d, 0x0a, 0x09, 0x48, 0x45, 0x4c, 0x54, 0x45,
	0x43, 0x5f, 0x56, 0x33, 0x10, 0x2b, 0x12, 0x11, 0x0a, 0x0d, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43,
	0x5f, 0x57, 0x53, 0x4c, 0x5f, 0x56, 0x33, 0x10, 0x2c, 0x12, 0x13, 0x0a, 0x0f, 0x42, 0x45, 0x54,
	0x41, 0x46, 0x50, 0x56, 0x5f, 0x32, 0x34, 0x30, 0x30, 0x5f, 0x54, 0x58, 0x10, 0x2d, 0x12, 0x17,
	0x0a, 0x13, 0x42, 0x45, 0x54, 0x41, 0x46, 0x50, 0x56, 0x5f, 0x39, 0x30, 0x30, 0x5f, 0x4e, 0x41,
	0x4e, 0x4f, 0x5f, 0x54, 0x58, 0x10, 0x2e, 0x12, 0x0c, 0x0a, 0x08, 0x52, 0x50, 0x49, 0x5f, 0x50,
	0x49, 0x43, 0x4f, 0x10, 0x2f, 0x12, 0x1b, 0x0a, 0x17, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f,
	0x57, 0x49, 0x52, 0x45, 0x4c, 0x45, 0x53, 0x53, 0x5f, 0x54, 0x52, 0x41, 0x43, 0x4b, 0x45, 0x52,
	0x10, 0x30, 0x12, 0x19, 0x0a, 0x15, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x57, 0x49, 0x52,
	0x45, 0x4c, 0x45, 0x53, 0x53, 0x5f, 0x50, 0x41, 0x50, 0x45, 0x52, 0x10, 0x31, 0x12, 0x0a, 0x0a,
	0x06, 0x54, 0x5f, 0x44, 0x45, 0x43, 0x4b, 0x10, 0x32, 0x12, 0x0e, 0x0a, 0x0a, 0x54, 0x5f, 0x57,
	0x41, 0x54, 0x43, 0x48, 0x5f, 0x53, 0x33, 0x10, 0x33, 0x12, 0x11, 0x0a, 0x0d, 0x50, 0x49, 0x43,
	0x4f, 0x4d, 0x50, 0x55, 0x54, 0x45, 0x52, 0x5f, 0x53, 0x33, 0x10, 0x34, 0x12, 0x0f, 0x0a, 0x0b,
	0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x48, 0x54, 0x36, 0x32, 0x10, 0x35, 0x12, 0x12, 0x0a,
	0x0e, 0x45, 0x42, 0x59, 0x54, 0x45, 0x5f, 0x45, 0x53, 0x50, 0x33, 0x32, 0x5f, 0x53, 0x33, 0x10,
	0x36, 0x12, 0x11, 0x0a, 0x0d, 0x45, 0x53, 0x50, 0x33, 0x32, 0x5f, 0x53, 0x33, 0x5f, 0x50, 0x49,
	0x43, 0x4f, 0x10, 0x37, 0x12, 0x0d, 0x0a, 0x09, 0x43, 0x48, 0x41, 0x54, 0x54, 0x45, 0x52, 0x5f,
	0x32, 0x10, 0x38, 0x12, 0x1e, 0x0a, 0x1a, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x57, 0x49,
	0x52, 0x45, 0x4c, 0x45, 0x53, 0x53, 0x5f, 0x50, 0x41, 0x50, 0x45, 0x52, 0x5f, 0x56, 0x31, 0x5f,
	0x30, 0x10, 0x39, 0x12, 0x20, 0x0a, 0x1c, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x57, 0x49,
	0x52, 0x45, 0x4c, 0x45, 0x53, 0x53, 0x5f, 0x54, 0x52, 0x41, 0x43, 0x4b, 0x45, 0x52, 0x5f, 0x56,
	0x31, 0x5f, 0x30, 0x10, 0x3a, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x50, 0x48, 0x4f, 0x4e, 0x45,
	0x10, 0x3b, 0x12, 0x0c, 0x0a, 0x08, 0x54, 0x44, 0x5f, 0x4c, 0x4f, 0x52, 0x41, 0x43, 0x10, 0x3c,
	0x12, 0x13, 0x0a, 0x0f, 0x43, 0x44, 0x45, 0x42, 0x59, 0x54, 0x45, 0x5f, 0x45, 0x4f, 0x52, 0x41,
	0x5f, 0x53, 0x33, 0x10, 0x3d, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x57, 0x43, 0x5f, 0x4d, 0x45, 0x53,
	0x48, 0x5f, 0x56, 0x34, 0x10, 0x3e, 0x12, 0x16, 0x0a, 0x12, 0x4e, 0x52, 0x46, 0x35, 0x32, 0x5f,
	0x50, 0x52, 0x4f, 0x4d, 0x49, 0x43, 0x52, 0x4f, 0x5f, 0x44, 0x49, 0x59, 0x10, 0x3f, 0x12, 0x1f,
	0x0a, 0x1b, 0x52, 0x41, 0x44, 0x49, 0x4f, 0x4d, 0x41, 0x53, 0x54, 0x45, 0x52, 0x5f, 0x39, 0x30,
	0x30, 0x5f, 0x42, 0x41, 0x4e, 0x44, 0x49, 0x54, 0x5f, 0x4e, 0x41, 0x4e, 0x4f, 0x10, 0x40, 0x12,
	0x1c, 0x0a, 0x18, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x43, 0x41, 0x50, 0x53, 0x55, 0x4c,
	0x45, 0x5f, 0x53, 0x45, 0x4e, 0x53, 0x4f, 0x52, 0x5f, 0x56, 0x33, 0x10, 0x41, 0x12, 0x1d, 0x0a,
	0x19, 0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x56, 0x49, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x4d,
	0x41, 0x53, 0x54, 0x45, 0x52, 0x5f, 0x54, 0x31, 0x39, 0x30, 0x10, 0x42, 0x12, 0x1d, 0x0a, 0x19,
	0x48, 0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x56, 0x49, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x4d, 0x41,
	0x53, 0x54, 0x45, 0x52, 0x5f, 0x45, 0x32, 0x31, 0x33, 0x10, 0x43, 0x12, 0x1d, 0x0a, 0x19, 0x48,
	0x45, 0x4c, 0x54, 0x45, 0x43, 0x5f, 0x56, 0x49, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x4d, 0x41, 0x53,
	0x54, 0x45, 0x52, 0x5f, 0x45, 0x32, 0x39, 0x30, 0x10, 0x44, 0x12, 0x19, 0x0a, 0x15, 0x48, 0x45,
	0x4c, 0x54, 0x45, 0x43, 0x5f, 0x4d, 0x45, 0x53, 0x48, 0x5f, 0x4e, 0x4f, 0x44, 0x45, 0x5f, 0x54,
	0x31, 0x31, 0x34, 0x10, 0x45, 0x12, 0x16, 0x0a, 0x12, 0x53, 0x45, 0x4e, 0x53, 0x45, 0x43, 0x41,
	0x50, 0x5f, 0x49, 0x4e, 0x44, 0x49, 0x43, 0x41, 0x54, 0x4f, 0x52, 0x10, 0x46, 0x12, 0x13, 0x0a,
	0x0f, 0x54, 0x52, 0x41, 0x43, 0x4b, 0x45, 0x52, 0x5f, 0x54, 0x31, 0x30, 0x30, 0x30, 0x5f, 0x45,
	0x10, 0x47, 0x12, 0x0b, 0x0a, 0x07, 0x52, 0x41, 0x4b, 0x33, 0x31, 0x37, 0x32, 0x10, 0x48, 0x12,
	0x0a, 0x0a, 0x06, 0x57, 0x49, 0x4f, 0x5f, 0x45, 0x35, 0x10, 0x49, 0x12, 0x1a, 0x0a, 0x16, 0x52,
	0x41, 0x44, 0x49, 0x4f, 0x4d, 0x41, 0x53, 0x54, 0x45, 0x52, 0x5f, 0x39, 0x30, 0x30, 0x5f, 0x42,
	0x41, 0x4e, 0x44, 0x49, 0x54, 0x10, 0x4a, 0x12, 0x13, 0x0a, 0x0f, 0x4d, 0x45, 0x32, 0x35, 0x4c,
	0x53, 0x30, 0x31, 0x5f, 0x34, 0x59, 0x31, 0x30, 0x54, 0x44, 0x10, 0x4b, 0x12, 0x18, 0x0a, 0x14,
	0x52, 0x50, 0x32, 0x30, 0x34, 0x30, 0x5f, 0x46, 0x45, 0x41, 0x54, 0x48, 0x45, 0x52, 0x5f, 0x52,
	0x46, 0x4d, 0x39, 0x35, 0x10, 0x4c, 0x12, 0x15, 0x0a, 0x11, 0x4d, 0x35, 0x53, 0x54, 0x41, 0x43,
	0x4b, 0x5f, 0x43, 0x4f, 0x52, 0x45, 0x42, 0x41, 0x53, 0x49, 0x43, 0x10, 0x4d, 0x12, 0x11, 0x0a,
	0x0d, 0x4d, 0x35, 0x53, 0x54, 0x41, 0x43, 0x4b, 0x5f, 0x43, 0x4f, 0x52, 0x45, 0x32, 0x10, 0x4e,
	0x12, 0x0d, 0x0a, 0x09, 0x52, 0x50, 0x49, 0x5f, 0x50, 0x49, 0x43, 0x4f, 0x32, 0x10, 0x4f, 0x12,
	0x12, 0x0a, 0x0e, 0x4d, 0x35, 0x53, 0x54, 0x41, 0x43, 0x4b, 0x5f, 0x43, 0x4f, 0x52, 0x45, 0x53,
	0x33, 0x10, 0x50, 0x12, 0x11, 0x0a, 0x0d, 0x53, 0x45, 0x45, 0x45, 0x44, 0x5f, 0x58, 0x49, 0x41,
	0x4f, 0x5f, 0x53, 0x33, 0x10, 0x51, 0x12, 0x0b, 0x0a, 0x07, 0x4d, 0x53, 0x32, 0x34, 0x53, 0x46,
	0x31, 0x10, 0x52, 0x12, 0x0c, 0x0a, 0x08, 0x54, 0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x43, 0x36, 0x10,
	0x53, 0x12, 0x0f, 0x0a, 0x0a, 0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x5f, 0x48, 0x57, 0x10,
	0xff, 0x01, 0x2a, 0x2c, 0x0a, 0x09, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x73, 0x12,
	0x08, 0x0a, 0x04, 0x5a, 0x45, 0x52, 0x4f, 0x10, 0x00, 0x12, 0x15, 0x0a, 0x10, 0x44, 0x41, 0x54,
	0x41, 0x5f, 0x50, 0x41, 0x59, 0x4c, 0x4f, 0x41, 0x44, 0x5f, 0x4c, 0x45, 0x4e, 0x10, 0xed, 0x01,
	0x2a, 0xb4, 0x02, 0x0a, 0x11, 0x43, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x45, 0x72, 0x72,
	0x6f, 0x72, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x4f, 0x4e, 0x45, 0x10, 0x00,
	0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x58, 0x5f, 0x57, 0x41, 0x54, 0x43, 0x48, 0x44, 0x4f, 0x47, 0x10,
	0x01, 0x12, 0x14, 0x0a, 0x10, 0x53, 0x4c, 0x45, 0x45, 0x50, 0x5f, 0x45, 0x4e, 0x54, 0x45, 0x52,
	0x5f, 0x57, 0x41, 0x49, 0x54, 0x10, 0x02, 0x12, 0x0c, 0x0a, 0x08, 0x4e, 0x4f, 0x5f, 0x52, 0x41,
	0x44, 0x49, 0x4f, 0x10, 0x03, 0x12, 0x0f, 0x0a, 0x0b, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49,
	0x46, 0x49, 0x45, 0x44, 0x10, 0x04, 0x12, 0x15, 0x0a, 0x11, 0x55, 0x42, 0x4c, 0x4f, 0x58, 0x5f,
	0x55, 0x4e, 0x49, 0x54, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x05, 0x12, 0x0d, 0x0a,
	0x09, 0x4e, 0x4f, 0x5f, 0x41, 0x58, 0x50, 0x31, 0x39, 0x32, 0x10, 0x06, 0x12, 0x19, 0x0a, 0x15,
	0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x5f, 0x52, 0x41, 0x44, 0x49, 0x4f, 0x5f, 0x53, 0x45,
	0x54, 0x54, 0x49, 0x4e, 0x47, 0x10, 0x07, 0x12, 0x13, 0x0a, 0x0f, 0x54, 0x52, 0x41, 0x4e, 0x53,
	0x4d, 0x49, 0x54, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x08, 0x12, 0x0c, 0x0a, 0x08,
	0x42, 0x52, 0x4f, 0x57, 0x4e, 0x4f, 0x55, 0x54, 0x10, 0x09, 0x12, 0x12, 0x0a, 0x0e, 0x53, 0x58,
	0x31, 0x32, 0x36, 0x32, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x55, 0x52, 0x45, 0x10, 0x0a, 0x12, 0x11,
	0x0a, 0x0d, 0x52, 0x41, 0x44, 0x49, 0x4f, 0x5f, 0x53, 0x50, 0x49, 0x5f, 0x42, 0x55, 0x47, 0x10,
	0x0b, 0x12, 0x20, 0x0a, 0x1c, 0x46, 0x4c, 0x41, 0x53, 0x48, 0x5f, 0x43, 0x4f, 0x52, 0x52, 0x55,
	0x50, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x52, 0x45, 0x43, 0x4f, 0x56, 0x45, 0x52, 0x41, 0x42, 0x4c,
	0x45, 0x10, 0x0c, 0x12, 0x22, 0x0a, 0x1e, 0x46, 0x4c, 0x41, 0x53, 0x48, 0x5f, 0x43, 0x4f, 0x52,
	0x52, 0x55, 0x50, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x55, 0x4e, 0x52, 0x45, 0x43, 0x4f, 0x56, 0x45,
	0x52, 0x41, 0x42, 0x4c, 0x45, 0x10, 0x0d, 0x42, 0x5f, 0x0a, 0x13, 0x63, 0x6f, 0x6d, 0x2e, 0x67,
	0x65, 0x65, 0x6b, 0x73, 0x76, 0x69, 0x6c, 0x6c, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x42, 0x0a,
	0x4d, 0x65, 0x73, 0x68, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x5a, 0x22, 0x67, 0x69, 0x74, 0x68,
	0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69,
	0x63, 0x2f, 0x67, 0x6f, 0x2f, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0xaa, 0x02,
	0x14, 0x4d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2e, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x73, 0xba, 0x02, 0x00, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_meshtastic_mesh_proto_rawDescOnce sync.Once
	file_meshtastic_mesh_proto_rawDescData = file_meshtastic_mesh_proto_rawDesc
)

func file_meshtastic_mesh_proto_rawDescGZIP() []byte {
	file_meshtastic_mesh_proto_rawDescOnce.Do(func() {
		file_meshtastic_mesh_proto_rawDescData = protoimpl.X.CompressGZIP(file_meshtastic_mesh_proto_rawDescData)
	})
	return file_meshtastic_mesh_proto_rawDescData
}

var file_meshtastic_mesh_proto_enumTypes = make([]protoimpl.EnumInfo, 9)
var file_meshtastic_mesh_proto_msgTypes = make([]protoimpl.MessageInfo, 25)
var file_meshtastic_mesh_proto_goTypes = []interface{}{
	(HardwareModel)(0),             // 0: meshtastic.HardwareModel
	(Constants)(0),                 // 1: meshtastic.Constants
	(CriticalErrorCode)(0),         // 2: meshtastic.CriticalErrorCode
	(Position_LocSource)(0),        // 3: meshtastic.Position.LocSource
	(Position_AltSource)(0),        // 4: meshtastic.Position.AltSource
	(Routing_Error)(0),             // 5: meshtastic.Routing.Error
	(MeshPacket_Priority)(0),       // 6: meshtastic.MeshPacket.Priority
	(MeshPacket_Delayed)(0),        // 7: meshtastic.MeshPacket.Delayed
	(LogRecord_Level)(0),           // 8: meshtastic.LogRecord.Level
	(*Position)(nil),               // 9: meshtastic.Position
	(*User)(nil),                   // 10: meshtastic.User
	(*RouteDiscovery)(nil),         // 11: meshtastic.RouteDiscovery
	(*Routing)(nil),                // 12: meshtastic.Routing
	(*Data)(nil),                   // 13: meshtastic.Data
	(*Waypoint)(nil),               // 14: meshtastic.Waypoint
	(*MqttClientProxyMessage)(nil), // 15: meshtastic.MqttClientProxyMessage
	(*MeshPacket)(nil),             // 16: meshtastic.MeshPacket
	(*NodeInfo)(nil),               // 17: meshtastic.NodeInfo
	(*MyNodeInfo)(nil),             // 18: meshtastic.MyNodeInfo
	(*LogRecord)(nil),              // 19: meshtastic.LogRecord
	(*QueueStatus)(nil),            // 20: meshtastic.QueueStatus
	(*FromRadio)(nil),              // 21: meshtastic.FromRadio
	(*ClientNotification)(nil),     // 22: meshtastic.ClientNotification
	(*FileInfo)(nil),               // 23: meshtastic.FileInfo
	(*ToRadio)(nil),                // 24: meshtastic.ToRadio
	(*Compressed)(nil),             // 25: meshtastic.Compressed
	(*NeighborInfo)(nil),           // 26: meshtastic.NeighborInfo
	(*Neighbor)(nil),               // 27: meshtastic.Neighbor
	(*DeviceMetadata)(nil),         // 28: meshtastic.DeviceMetadata
	(*Heartbeat)(nil),              // 29: meshtastic.Heartbeat
	(*NodeRemoteHardwarePin)(nil),  // 30: meshtastic.NodeRemoteHardwarePin
	(*ChunkedPayload)(nil),         // 31: meshtastic.ChunkedPayload
	(*ResendChunks)(nil),           // 32: meshtastic.resend_chunks
	(*ChunkedPayloadResponse)(nil), // 33: meshtastic.ChunkedPayloadResponse
	(Config_DeviceConfig_Role)(0),  // 34: meshtastic.Config.DeviceConfig.Role
	(PortNum)(0),                   // 35: meshtastic.PortNum
	(*DeviceMetrics)(nil),          // 36: meshtastic.DeviceMetrics
	(*Config)(nil),                 // 37: meshtastic.Config
	(*ModuleConfig)(nil),           // 38: meshtastic.ModuleConfig
	(*Channel)(nil),                // 39: meshtastic.Channel
	(*XModem)(nil),                 // 40: meshtastic.XModem
	(*RemoteHardwarePin)(nil),      // 41: meshtastic.RemoteHardwarePin
}
var file_meshtastic_mesh_proto_depIdxs = []int32{
	3,  // 0: meshtastic.Position.location_source:type_name -> meshtastic.Position.LocSource
	4,  // 1: meshtastic.Position.altitude_source:type_name -> meshtastic.Position.AltSource
	0,  // 2: meshtastic.User.hw_model:type_name -> meshtastic.HardwareModel
	34, // 3: meshtastic.User.role:type_name -> meshtastic.Config.DeviceConfig.Role
	11, // 4: meshtastic.Routing.route_request:type_name -> meshtastic.RouteDiscovery
	11, // 5: meshtastic.Routing.route_reply:type_name -> meshtastic.RouteDiscovery
	5,  // 6: meshtastic.Routing.error_reason:type_name -> meshtastic.Routing.Error
	35, // 7: meshtastic.Data.portnum:type_name -> meshtastic.PortNum
	13, // 8: meshtastic.MeshPacket.decoded:type_name -> meshtastic.Data
	6,  // 9: meshtastic.MeshPacket.priority:type_name -> meshtastic.MeshPacket.Priority
	7,  // 10: meshtastic.MeshPacket.delayed:type_name -> meshtastic.MeshPacket.Delayed
	10, // 11: meshtastic.NodeInfo.user:type_name -> meshtastic.User
	9,  // 12: meshtastic.NodeInfo.position:type_name -> meshtastic.Position
	36, // 13: meshtastic.NodeInfo.device_metrics:type_name -> meshtastic.DeviceMetrics
	8,  // 14: meshtastic.LogRecord.level:type_name -> meshtastic.LogRecord.Level
	16, // 15: meshtastic.FromRadio.packet:type_name -> meshtastic.MeshPacket
	18, // 16: meshtastic.FromRadio.my_info:type_name -> meshtastic.MyNodeInfo
	17, // 17: meshtastic.FromRadio.node_info:type_name -> meshtastic.NodeInfo
	37, // 18: meshtastic.FromRadio.config:type_name -> meshtastic.Config
	19, // 19: meshtastic.FromRadio.log_record:type_name -> meshtastic.LogRecord
	38, // 20: meshtastic.FromRadio.moduleConfig:type_name -> meshtastic.ModuleConfig
	39, // 21: meshtastic.FromRadio.channel:type_name -> meshtastic.Channel
	20, // 22: meshtastic.FromRadio.queueStatus:type_name -> meshtastic.QueueStatus
	40, // 23: meshtastic.FromRadio.xmodemPacket:type_name -> meshtastic.XModem
	28, // 24: meshtastic.FromRadio.metadata:type_name -> meshtastic.DeviceMetadata
	15, // 25: meshtastic.FromRadio.mqttClientProxyMessage:type_name -> meshtastic.MqttClientProxyMessage
	23, // 26: meshtastic.FromRadio.fileInfo:type_name -> meshtastic.FileInfo
	22, // 27: meshtastic.FromRadio.clientNotification:type_name -> meshtastic.ClientNotification
	8,  // 28: meshtastic.ClientNotification.level:type_name -> meshtastic.LogRecord.Level
	16, // 29: meshtastic.ToRadio.packet:type_name -> meshtastic.MeshPacket
	40, // 30: meshtastic.ToRadio.xmodemPacket:type_name -> meshtastic.XModem
	15, // 31: meshtastic.ToRadio.mqttClientProxyMessage:type_name -> meshtastic.MqttClientProxyMessage
	29, // 32: meshtastic.ToRadio.heartbeat:type_name -> meshtastic.Heartbeat
	35, // 33: meshtastic.Compressed.portnum:type_name -> meshtastic.PortNum
	27, // 34: meshtastic.NeighborInfo.neighbors:type_name -> meshtastic.Neighbor
	34, // 35: meshtastic.DeviceMetadata.role:type_name -> meshtastic.Config.DeviceConfig.Role
	0,  // 36: meshtastic.DeviceMetadata.hw_model:type_name -> meshtastic.HardwareModel
	41, // 37: meshtastic.NodeRemoteHardwarePin.pin:type_name -> meshtastic.RemoteHardwarePin
	32, // 38: meshtastic.ChunkedPayloadResponse.resend_chunks:type_name -> meshtastic.resend_chunks
	39, // [39:39] is the sub-list for method output_type
	39, // [39:39] is the sub-list for method input_type
	39, // [39:39] is the sub-list for extension type_name
	39, // [39:39] is the sub-list for extension extendee
	0,  // [0:39] is the sub-list for field type_name
}

func init() { file_meshtastic_mesh_proto_init() }
func file_meshtastic_mesh_proto_init() {
	if File_meshtastic_mesh_proto != nil {
		return
	}
	file_meshtastic_channel_proto_init()
	file_meshtastic_config_proto_init()
	file_meshtastic_module_config_proto_init()
	file_meshtastic_portnums_proto_init()
	file_meshtastic_telemetry_proto_init()
	file_meshtastic_xmodem_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_meshtastic_mesh_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Position); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*User); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteDiscovery); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Routing); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Data); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Waypoint); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MqttClientProxyMessage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MeshPacket); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NodeInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MyNodeInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LogRecord); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QueueStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FromRadio); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ClientNotification); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FileInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ToRadio); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Compressed); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NeighborInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Neighbor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DeviceMetadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Heartbeat); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NodeRemoteHardwarePin); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ChunkedPayload); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ResendChunks); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_meshtastic_mesh_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ChunkedPayloadResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_meshtastic_mesh_proto_msgTypes[0].OneofWrappers = []interface{}{}
	file_meshtastic_mesh_proto_msgTypes[3].OneofWrappers = []interface{}{
		(*Routing_RouteRequest)(nil),
		(*Routing_RouteReply)(nil),
		(*Routing_ErrorReason)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[4].OneofWrappers = []interface{}{}
	file_meshtastic_mesh_proto_msgTypes[5].OneofWrappers = []interface{}{}
	file_meshtastic_mesh_proto_msgTypes[6].OneofWrappers = []interface{}{
		(*MqttClientProxyMessage_Data)(nil),
		(*MqttClientProxyMessage_Text)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[7].OneofWrappers = []interface{}{
		(*MeshPacket_Decoded)(nil),
		(*MeshPacket_Encrypted)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[8].OneofWrappers = []interface{}{}
	file_meshtastic_mesh_proto_msgTypes[12].OneofWrappers = []interface{}{
		(*FromRadio_Packet)(nil),
		(*FromRadio_MyInfo)(nil),
		(*FromRadio_NodeInfo)(nil),
		(*FromRadio_Config)(nil),
		(*FromRadio_LogRecord)(nil),
		(*FromRadio_ConfigCompleteId)(nil),
		(*FromRadio_Rebooted)(nil),
		(*FromRadio_ModuleConfig)(nil),
		(*FromRadio_Channel)(nil),
		(*FromRadio_QueueStatus)(nil),
		(*FromRadio_XmodemPacket)(nil),
		(*FromRadio_Metadata)(nil),
		(*FromRadio_MqttClientProxyMessage)(nil),
		(*FromRadio_FileInfo)(nil),
		(*FromRadio_ClientNotification)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[13].OneofWrappers = []interface{}{}
	file_meshtastic_mesh_proto_msgTypes[15].OneofWrappers = []interface{}{
		(*ToRadio_Packet)(nil),
		(*ToRadio_WantConfigId)(nil),
		(*ToRadio_Disconnect)(nil),
		(*ToRadio_XmodemPacket)(nil),
		(*ToRadio_MqttClientProxyMessage)(nil),
		(*ToRadio_Heartbeat)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[24].OneofWrappers = []interface{}{
		(*ChunkedPayloadResponse_RequestTransfer)(nil),
		(*ChunkedPayloadResponse_AcceptTransfer)(nil),
		(*ChunkedPayloadResponse_ResendChunks)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_meshtastic_mesh_proto_rawDesc,
			NumEnums:      9,
			NumMessages:   25,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_meshtastic_mesh_proto_goTypes,
		DependencyIndexes: file_meshtastic_mesh_proto_depIdxs,
		EnumInfos:         file_meshtastic_mesh_proto_enumTypes,
		MessageInfos:      file_meshtastic_mesh_proto_msgTypes,
	}.Build()
	File_meshtastic_mesh_proto = out.File
	file_meshtastic_mesh_proto_rawDesc = nil
	file_meshtastic_mesh_proto_goTypes = nil
	file_meshtastic_mesh_proto_depIdxs = nil
}
